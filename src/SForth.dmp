# David Smith 2022 david.a.c.v.smith@gmail.com http://dacvs.neocities.org/
# This is the 1st of the 2 files that define SmithForth, a subroutine-threaded Forth for x86-64.

# Understanding this file may be easier if first you watch my video series on hand-made
# Linux x86 executables (featuring the ELF header and general-purpose x86 instructions):
#     https://www.youtube.com/playlist?list=PLZCIHSjpQ12woLj0sjsnqDH8yVuXwTy3p

# ============= ELF FILE HEADER
#
# Linux will run a computing job given the name of an executable file. An executable file
# contains machine code for the processor and information for the operating system about the
# layout of the file and the dimensions of the job. Working without the usual development
# tools, we write this information by hand.

7F 45 4C 46                 # e_ident[EI_MAG]: ELF magic number
            02              # e_ident[EI_CLASS]: 1: 32-bit, 2: 64-bit
               01           # e_ident[EI_DATA]: 1: little-endian, 2: big-endian
                  01        # e_ident[EI_VERSION]: ELF header version; must be 1
                     00     # e_ident[EI_OSABI]: Target OS ABI; should be 0
00                          # e_ident[EI_ABIVERSION]: ABI version; 0 is ok for Linux
   00 00 00 00 00 00 00     # e_ident[EI_PAD]: unused, should be 0
02 00                       # e_type: object file type; 2: executable
      F3 00                 # e_machine: instruction set architecture; 3: x86, 3E: amd64
            01 00 00 00     # e_version: ELF identification version; must be 1
78 00 00 00 00 00 00 00     # e_entry: memory address of entry point (where process starts)
40 00 00 00 00 00 00 00     # e_phoff: file offset where program headers begin (34: 32-bit, 40: 64)
00 00 00 00 00 00 00 00     # e_shoff: file offset where section headers begin
00 00 00 00                 # e_flags: 0 for x86
            40 00           # e_ehsize: size of this header (34: 32-bit, 40: 64-bit)
                  38 00     # e_phentsize: size of each program header (20: 32-bit, 38: 64-bit)
01 00                       # e_phnum: number of program headers
      40 00                 # e_shentsize: size of each section header (28: 32-bit, 40: 64-bit)
            00 00           # e_shnum: number of section headers
                  00 00     # e_shstrndx: index of section header containing section names

# ============= ELF PROGRAM HEADER

01 00 00 00                 # p_type: segment type; 1: loadable
            07 00 00 00     # p_flags: segment-dependent flags (1: X, 2: W, 4: R)
00 00 00 00 00 00 00 00     # p_offset: file offset where segment begins
00 00 00 00 00 00 00 00     # p_vaddr: virtual address of segment in memory (amd64: 00400000)
00 00 00 00 00 00 00 00     # p_paddr: physical address of segment, unspecified by 386 supplement
02 1E 01 00 00 00 00 00 ##### p_filesz: size in bytes of the segment in the file image (see make.sh)
00 00 C0 7F 00 00 00 00     # p_memsz: (>= filesz) size in bytes of the segment in memory
00 10 00 00 00 00 00 00     # p_align: 1000 for x86

# Exercise: Exit with status 7.
# 93 08 D0 05  		    # a7 <- 93 (0x5D, exit syscall #) 		# addi a7, x0, 0x5D		# 00000101 1101|0000 0|000|1000 1|0010011
# 13 05 70 00  		    # a0 <- 7 (0x07, status)			# addi a0, x0, 0x07		# 00000000 0111|0000 0|000|0101 0|0010011
# 73 00 00 00  		    # syscall					# ecall	       			# 00000000 0000|0000 0|000|0000 0|1110011

# 00 00 00 00

# ============= 64-BIT EXTENSIONS
#
# SmithForth has 64-bit Forth cells (i.e., integers) and uses the instruction set
# x86-64 (a.k.a. amd64). Changes from x86 to x86-64 are explained in Intel's
# manual (and in AMD's). See for instance Vol 1 Sec 3.2.1, Vol 2 Sec 2.2.1, and the
# instruction set reference, Vol 2 Chs 3, 4, 5. There are many subtle details. 
#
# In a nutshell, general-purpose registers are widened from 32 bits to 64. The old eight
# 32-bit general-purpose registers EAX, ECX, ..., EDI are still available as operands.
# They are the lower halves of their new 64-bit counterparts RAX, RCX, ..., RDI.
# There are also 8 new 64-bit general-purpose registers R8, R9, ..., R15.
#
# The x86-64 instruction set is almost a superset of x86. Many of the extensions are
# 64-bit counterparts to old 32-bit instructions. Often an instruction on 64-bit operands
# is obtained from a 32-bit instruction by adding a REX prefix byte valued 40 ... 4F (see below).
# Bytes ModR/M and SIB are used in x86-64 as in x86. These bytes provide only 3-bit fields to
# select operands. If we want to select a new register R8 ... R15 as an operand, each 3-bit field
# should have another bit. These bits occur in the REX byte.
#
# The 4 high bits of REX are 0100 (=4). The 4 low bits are named WRXB: (see Intel manual Vol 2 Sec 2.2.1)
#   W=1 iff certain operands are 64 bits wide
#       "REX.W" (W=1) or "REX" (W=0) appears in the instruction reference for most of our instructions.
#   R=1 iff a register R8 ... R15 is referred to by:
#       field reg (middle) of the ModR/M byte;
#   X=1 iff a register R8 ... R15 is referred to by:
#       field index of the SIB byte;
#   B=1 iff a register R8 ... R15 is referred to by:
#       field r/m (last) of the ModR/M byte,
#       field base of the SIB byte, or
#       field reg of the opcode.
#
# Most operations that set a 32-bit register (the lower half of a 64-bit register) also zero
# out the higher 32 bits of the containing 64-bit register. For example, XOR EAX, EAX = 31 C0
# (even without prefix REX) sets all 64 bits of RAX to 0.
#
# Q: In an x86-64 instruction like CMP r/m8, imm8 with opcode 80 /7 ib, does ModR/M byte 00 111 000 refer to [eax] or to [rax]?
# A: [rax]. Register ax contains an address, not an operand. The default AddressSize in 64-bit mode is 64 bits.
# AddressSize is defined not in our usual Volume 2 of Intel's manual, but in Volume 1. See Table 3-4.
# See also AMD's manual, Table 1-3 (p. 9) of https://www.amd.com/system/files/TechDocs/24594.pdf

# ============= FORTH INTERPRETER
#
# Forth words are defined in terms of more primitive Forth words. The most primitive
# SmithForth words are defined in machine language. SmithForth is written "from scratch."
# In the beginning, there is only machine code. We want to switch from writing machine
# code to writing (more pleasant) Forth. Our immediate goal is to write a simple Forth
# interpreter in machine code. Here is an example of Forth input:
#
#     1 2 + . ( Interpreting, not compiling, so far. )
#     : newWord ( -- ) ." After colon, compiling." ; ( After semicolon, interpreting. )
#     newWord ( Interpreting: newWord is executed )
#
# The interpreter reads words and executes them until it reaches a colon. After the colon,
# the interpreter stops executing and starts compiling. To keep the design simple, perhaps
# the colon should require no special treatment. Let the colon, when executed, add a new word
# to the dictionary. We have the following TENTATIVE PLAN:
#
# Interpret:
#     Consume the next word (from the input stream).
#     Find it in the dictionary.
#     Execute it.
#     Go to Interpret.
#
# Colon:
#     Name:
#         Consume the next word (the first word of the colon definition) and write a new Forth
#         header signifying a new dictionary entry named by this word.
#     Constituent:
#         Consume the next word.
#         If it is a semicolon, exit routine Colon. Else:
#         Find the word in the dictionary.
#         Compile the word (append x86 instr. CALL to the dict. entry of the current definition).
#         Go to Constituent.
#
# Loops Interpret and Constituent are similar.
# We can combine them into one loop if we remember whether we are
#     outside a definition (STATE = Interpreting) or
#     inside a definition (STATE = Compiling).
# Some words like semicolon should not be compiled, even when Compiling.
# Such words are labeled "immediate" and treated specially. We have:
#
# ============= THE PLAN
#     (a typical Forth interpreter, simplified)
#
# Set STATE to Interpreting.
# Loop:
#     Consume the next word.
#     Find it in the dictionary.
#     If STATE is Interpreting, or if the word is immediate:
#         Execute the word.
#     Else:
#         Compile the word.
#     Go to Loop.
#
# Colon:
#     Consume the next word and make it the name of a new dictionary entry.
#     Set STATE to Compiling.
#     Return from subroutine Colon.
#
# Semicolon, an immediate word:
#     Set STATE to Interpreting.
#     Return from subroutine Semicolon.
#
# Our first interpreter cannot recognize whole words. We provide special
# commands to start a definition or compile or execute a word. The input
# stream is binary. This binary interpreter (bi) transmits most bytes (all
# but 99) unchanged. A command begins with byte 99. After 99 is a 1-byte
# argument indicating which command is issued. If the command indicates a
# definition, the argument also encodes the length of the word's name, and
# the name of the word is given in full. If the command is to execute or
# compile the word, only the first character of the name is provided, encoded
# in the argument.
#
################################################################### MACHINE CODE ############ INTENTION ############ 78 INSTRUCTION ####### OPCODE ######## ModR/M #### SIB ######
                  
         	  # /# Global variable ~INPUT~./                  # BE B2 00 40 00          #:rsi(input)  = 004000__    mov r32, imm32      B8+rd id				
37 04 00 00	  # ~INPUT@s0 ← 0x000000EC;~                                                                                                              
13 04 C4 0E	  #                                               
           	  # /# Global variable ~OUTPUT~./                 # BF 30 00 00 10          # rdi(output) = 10000030    mov r32, imm32      B8+rd id				
B7 04 00 10	  # ~OUTPUT@s1 ← 0x10000030;~                     											
93 84 04 03	  #                                               
	   	  # /# Global variable ~VARS~./                   
37 09 00 10	  # ~VARS@s2 ← 0x10000000;~                       
13 09 09 00       #

# 00 00 00 00

################################# binary interpreter
                     # ~_bi:~                                           
                     # {{{i(1)}}} /# Loop the binary interpreter./      
EF 00 80 00          # {{{i(1)}}} ~call bi();~                          
6F F0 DF FF          # {{{i(1)}}} ~goto _bi.~                           
                     # ~bi():~                                          
                     # {{{i(1)}}} /# Read next byte from ~INPUT~./      
83 42 04 00          # {{{i(1)}}} ~chr@t0 ← [INPUT@s0++];~              
13 04 14 00          # {{{i(1)}}}                                       
                     # {{{i(1)}}} /# Does it start a command?/          
13 03 90 09          # {{{i(1)}}} ~if chr@t0 = 0x99:~                   
63 88 62 00          # {{{i(2)}}}     ~goto _command.~                  
                     # {{{i(1)}}} /# If not, just copy the byte/        
                     # {{{i(1)}}} /# to ~OUTPUT~ and return./           
23 80 54 00          # {{{i(1)}}} ~[OUTPUT@s1++] ← chr@t0;~             
93 84 14 00          # {{{i(1)}}}                                       
67 80 00 00          # {{{i(1)}}} ~return.~                             
                     # ~_command:~                                      
                     # {{{i(1)}}} /# Get latest dictionary word/        
                     # {{{i(1)}}} /# from ~LATEST~ (~VARS + 40~):/      
03 35 89 02          # {{{i(1)}}} ~xt@a0 ← [LATEST];~                   
                     # {{{i(1)}}}                                       
                     # {{{i(1)}}} /# Read command argument./            
83 45 04 00          # {{{i(1)}}} ~arg@a1 ← [INPUT@s0++];~              
13 04 14 00          # {{{i(1)}}}                                       
                     # {{{i(1)}}} /# Command type by argument:/         
                     # {{{i(1)}}} /# – ~0bi00ccccc~: define;/           
                     # {{{i(1)}}} /# – ~0b011ccccc~: compile;/          
                     # {{{i(1)}}} /# – ~0b111ccccc~: execute./          
93 F2 05 06          # {{{i(1)}}} ~if arg@a1~ ~&~ ~0b01100000~ ~=~ ~0:~ 
                     # {{{i(2)}}}     /# _Define_ a new word./          
63 85 02 06          # {{{i(2)}}}     ~goto Head.~                      
                     # ~_find1:~                                        
93 F2 F5 07          # {{{i(1)}}} ~chr@t0~ ~←~ ~arg@a1~ ~&~ ~0b0111111;~
03 43 15 01          # {{{i(1)}}} ~if chr@t0 = [xt@a0 + 17]:~           
                     # {{{i(2)}}}     /# We found a word whose/         
                     # {{{i(2)}}}     /# name begins with ~chr~./       
63 86 62 00          # {{{i(2)}}}     ~goto _match.~                    
                     # {{{i(1)}}} /# Follow word's link pointer/        
                     # {{{i(1)}}} /# to previous entry and repeat./     
03 35 85 00          # {{{i(1)}}} ~xt@a0 ← [xt@a0 + 8];~                
6F F0 1F FF          # {{{i(1)}}} ~goto _find1.~                        
                     # ~_match:~                                        
93 F2 05 08          # {{{i(1)}}} ~if arg@a1 & 0b1000000 = 0:~          
                     # {{{i(2)}}}     /# _Compile_./                    
63 8A 02 00          # {{{i(2)}}}     ~goto COMPL.~                     
                     # {{{i(1)}}} /# _Execute_ word's code./            
83 32 05 00          # {{{i(1)}}} ~goto [xt@a0].~                       
67 80 02 00          # {{{i(1)}}}                                       


######################### Interpreter subroutines ################################################

99 05 43 4F 4D 50 4C ####### COMPL Forth's COMPILE
00    	       	     #
                     # /# 1. Load code address from ~xt~./                                                            
83 62 05 00          # ~t0 ← [xt@a0];~                                                                                
                     #                                                                                                
                     # /# 2. Assemble and write ~lui~ instr./                                                         
37 F3 FF FF          # ~t1 ← 0xFFFFF000;~                                                                             
33 73 53 00          # ~t1 &= t0;~                                                                                    
13 03 73 2B          # ~t1 += 0x2B7;~  /# 12 fixed bits in ~lui~./                                                    
23 A0 64 00          # ~[OUTPUT@s1++4] ← t1;~                                                                         
93 84 44 00          #                                                                                                
                     # /# 3. Assemble and write ~jalr~ instruction./                                                  
37 73 0E 28          # ~t1 ← 0x280E7000;~  /# 20 fixed bits in ~jalr~./                                               
13 53 C3 00          # ~t1 >>>= 12;~                                                                                  
93 92 42 01          # ~t0 <<= 20;~                                                                                   
33 63 53 00          # ~t1~ \vert​~= t0;~                                                                                  
23 A0 64 00          # ~[OUTPUT@s1++4] ← t1;~                                                                         
93 84 44 00          #                                                                                                
67 80 00 00          # ~return.~  /# To interpreter loop./                                                           


99 04 48 65 61 64 ################## Head ================= CB
      	       	     #
                     # {{{c(2)}}}​/# 16-bit align ~OUTPUT~./                               
93 84 F4 00          # {{{c(2)}}}​~OUTPUT@s1 += 0x00F;~                                     
93 F4 04 FF          # {{{c(2)}}}​~OUTPUT@s1 &= 0xFF0;~                                     
                     #                                                                    
                     # {{{c(2)}}}​/# New word starts here./                                
B3 E2 94 00          # {{{c(2)}}}​~xt@t0 ← OUTPUT@s1;~                                     
                     #                                                                    
                     # {{{c(2)}}}​/# Fill the new dictionary entry:/                       
                     # {{{c(2)}}}​/#/                                                      
                     # {{{c(2)}}}​/# 1. Set the _link_ field, then point/                  
                     # {{{c(2)}}}​/# ~LATEST~ (~VARS+40~) to new word./                    
23 B4 A2 00          # {{{c(2)}}}​~[xt@t0 + 8] ← latest@a0;~                               
23 34 59 02          # {{{c(2)}}}​~[LATEST] ← xt@t0;~                                      
                     #                                                                    
                     # {{{c(2)}}}​/# 2. Set the _flag+length_ field./                      
23 88 B2 00          # {{{c(2)}}}​~[xt@t0 + 16] ← flag@a1;~                                
                     #                                                                    
                     # {{{c(2)}}}​/# 3. Extract name length from/                          
                     # {{{c(2)}}}​/# ~flag~ and copy into _name_ field./                   
13 F3 F5 01          # {{{c(2)}}}​~length@t1 ← flag@a1 & 0x1F;~                            
93 84 12 01          # {{{c(2)}}}​~OUTPUT@s1 ← xt@t0 + 17;~                                
                     # ~_begin:~                                                          
83 43 04 00          # {{{c(2)}}}​~chr@t2 ← [INPUT@s0++];~                                 
13 04 14 00          #                                                                    
23 80 74 00          # {{{c(2)}}}​~[OUTPUT@s1] ← chr@t2;~                                  
93 84 14 00          #                                                                    
13 03 F3 FF          # {{{c(2)}}}​~length@t1--;~                                           
                     # {{{c(2)}}}​~if length@t1 != 0:~                                     
E3 16 03 FE          # {{{c(4)}}}​  ~goto _begin;~                                         
                     #                                                                       
                     # {{{c(2)}}}​/# One padding byte might follow/                             
                     # {{{c(2)}}}​/# the word's name to abide by/                             
                     # {{{c(2)}}}​/# RISC-V's requirement to align/                           
                     # {{{c(2)}}}​/# instructions to even addresses [cite:@riscv_spec_vol_i]./
                     # {{{c(2)}}}​/# Both ~INPUT~ and ~OUTPUT~ need to/                       
                     # {{{c(2)}}}​/# be 1-bit aligned: the former to keep/                    
                     # {{{c(2)}}}​/# instructions in the executable/                          
                     # {{{c(2)}}}​/# aligned and former to make sure/                         
                     # {{{c(2)}}}​/# that compiled code is also aligned./                     
13 04 14 00          # {{{c(2)}}}​~INPUT@s0 += 0x001;~                                        
13 74 E4 FF          # {{{c(2)}}}​~INPUT@s0 &= 0xFFE;~                                        
93 84 14 00          # {{{c(2)}}}​~OUTPUT@s1 += 0x001;~                                       
93 F4 E4 FF          # {{{c(2)}}}​~OUTPUT@s1 &= 0xFFE;~                                       
                     #                                                                       
                     # {{{c(2)}}}​/# 4b. Point _code_ field to the code/                      
                     # {{{c(2)}}}​/# about to be generated at ~OUTPUT~./                      
23 B0 92 00          # {{{c(2)}}}​~[xt@t0 + 0] ← OUTPUT@s1;~                                  
67 80 00 00          # {{{c(2)}}}​~return.~  /# To interpreter loop./                         

# ============= DICTIONARY FORMAT
#
# Each SmithForth dictionary entry begins with:
#     (8 bytes)         Code
#     (8 bytes)         Link
#     (1 byte)          Flag (3 bits) and Length (5 bits) of Name
#     (Length bytes)    Name, where Length < 2^5.
# Each subroutine call refers to its callee. See argument ZZ in the following example:
#
# WW WW WW WW WW WW WW WW # Code: address of a subroutine (usually right after Name)
# XX XX XX XX XX XX XX XX # Link: address of the next earlier dictionary entry
# YY                      # Flag: 80=IMMEDIATE, 40=HIDDEN ; Name Length
# 2E 53                   # Name: .S ( -- ) show the values on the data stack
# 4D 89 7F F8             # [r15-8] = r15 (obuf)      mov r/m64, r64      REX.W 89 /r     01 111 111
# 49 C7 47 F0 00 00 00 10 # [r15-10] = 10000000 (len) mov r/m64, imm32    REX.W C7 /0 id  01 000 111
# 4D 29 7F F0             # [r15-10] -= r15           sub r/m64, r64      REX.W 29 /r     01 111 111
# 49 83 EF 10             # r15 -= 2 cells            sub r/m64, imm8     REX.W 83 /5 ib  11 101 111
# FF 14 25 ZZ ZZ ZZ ZZ    # call TYPE                 call r/m64          FF /2           00 010 100  00 100 101
# C3                      # return                    ret                 C3

99 03 42 59 45 ############ BYE ( -- ) =============================================================
00                   #
                     # /# Goodbye, world (exit syscall)./
93 08 D0 05          # ~nr@a7 ← 0x93;~  /# ~__NR_exit~./ 
                     #                                   
13 05 00 00          # ~status@RDI ← 0;~                 
73 00 00 00          # ~syscall exit(status@RDI).~       


# 99 C2                # BYE

# Linux syscall: ( RDI RSI RDX R10 R8 R9 RAX=syscall# -- RAX=stat RCX=? R11=? )
#     Manual pages on system calls: `man 2 syscalls ; man 2 exit ; man 2 read ; man 2 write ; man 2 mmap`
#     syscall numbers: /usr/include/x86_64-linux-gnu/asm/unistd_64.h
#     syscall error numbers: /usr/include/asm-generic/errno-base.h
#     mmap flag values: /usr/include/asm-generic/mman-common.h

99 04 54 59 50 45 ####### TYPE ( a0=addr a1=u -- ) show memory [addr, addr+u) ======
                     #
                     # {{{i(1)}}} /# Use saved registers to preserve/                                                
                     # {{{i(1)}}} /# values of ~addr~ and ~a1~ across/                      
                     # {{{i(1)}}} /# the ~write~ system calls [cite:@system_v_psabi_riscv]./
                     # {{{i(1)}}} /# Also save the return address./                         
13 01 81 FE          # {{{i(1)}}} ~save s10, s11, ra;~                                      
23 38 11 00          #                                                                      
23 34 B1 01          #                                                                      
23 30 A1 01          #                                                                      
13 0D 05 00          # {{{i(1)}}} ~addr@s10 ← addr@a0;~                                     
93 8D 05 00          # {{{i(1)}}} ~u@s11 ← u@a1;~                                           
                     #                                                                      
                     # ~_begin:~                                                            
13 05 10 00          # {{{i(1)}}} ~fd@a0 ← 1;~  /# ~STDOUT_FILENO~./                        
93 05 0D 00          # {{{i(1)}}} ~addr@a1 ← addr@s10;~                                     
13 86 0D 00          # {{{i(1)}}} ~u@a2 ← u@s11;~                                           
93 08 00 04          # {{{i(1)}}} ~nr@a7 ← 64;~  /# ~__NR_write~./                          
                     # {{{i(1)}}} ~syscall write(fd@a0,~                                    
                     # {{{i(1)}}}{{{c(14)}}}    ~addr@a1,~                                  
73 00 00 00          # {{{i(1)}}}{{{c(14)}}}    ~u@a2);~                                    
                     # {{{i(1)}}} ~if ret@a0 < 0:~                                          
                     # {{{i(2)}}} /# An error occured./                                     
63 48 05 00          # {{{i(2)}}}     ~goto _end.~                                          
                     # {{{i(1)}}} /# Advance by ~ret~ (printed) bytes./                     
33 0D AD 00          # {{{i(1)}}} ~addr@s10 += ret@a0;~                                     
                     # {{{i(1)}}} /# Fewer bytes left to print./                            
B3 8D AD 40	     # {{{i(1)}}} ~u@s11 -= ret@a0;~                                        
           	     # {{{i(1)}}} ~if u@s11 > 0:~                                           
           	     # {{{i(2)}}}     /# We still have bytes to print./                     
E3 40 B0 FF	     # {{{i(2)}}}     ~goto _begin.~                                        
           	     # ~_end:~                                                              
           	     # {{{i(1)}}} /# Restore saved registers and return./                   
03 3D 01 00	     # {{{i(1)}}} ~restore s10, s11, ra;~                                   
83 3D 81 00	     #                                                                      
83 30 01 01	     #		                                                                           
13 01 81 01	     #                                                                      
67 80 00 00	     # {{{i(1)}}} ~return.~                                                 


# ============= DEBUGGING
#
# During development, a program like this one may crash with an uninformative error message like
# "Segmentation fault" or "Illegal instruction." How can we work in such an environment?
# We start with a trivial program that works (i.e., simply invokes syscall exit, as in BYE),
# and then expand it gradually until it does what we want. When a program breaks after a small
# change, we know where the bug is. Here is one way to go.
#
# Insert a jump to BYE at the top of the program. You have to compute the length of the jump.
# After this chore, updating it is easy if you expand the program only one instruction at a time.
# You will want to disable and enable parts of the program as you expand it. The most basic ways:
# -- Hide unwanted code in comments. If this disrupts byte counts, replace lost bytes by no-op
#    instructions NOP = 90.
# -- Inside a subroutine, leave early by inserting a return instruction RET = C3.

99 03 64 62 67 ########## dbg ( -- ) show stack and data; use `./SForth | xxd -o 0x0fffffe0` =====
00     	             #
		     #
13 01 81 FF          # ~save ra;~                            
23 30 11 00          #	                                      
                     #	                                      
                     # /# Dump memory contents using/        
                     # /# subroutine ~TYPE~./                
37 05 00 10          # ~addr@a0 ← 0x0FFFFFE0;~               
13 05 05 FE          #                                       
B7 15 00 00	     # ~u@a1 ← 0xA00;~                       
93 85 05 A0          #                                       
                     # /# Compile a call to ~TYPE(addr, u)~./
99 54      	     # ~call TYPE;~  /# Compiled./           
           	     #                                       
83 30 01 00	     # ~restore ra;~                         
13 01 81 00	     #                                       
           	     #                                       
67 80 00 00	     # ~return.~                             

# 99 E4 99 C2          # dbg BYE


99 03 72 65 67 ########## reg ( -- ) show registers; use `./SForth | xxd` ========================
00                   # /# Allocate stack space for the/      
                     # /# return address and for the 32/     
                     # /# RISC-V registers (8 + 256)./       
13 01 81 EF          # ~save ra;~                            
23 30 11 10          #                                       
                     #                                       
23 30 01 00          # /# Push the 32 registers on the/      
23 34 01 01          # /# stack so that when printed/        
23 38 11 00          # /# they're displayed like this:/      
23 3C 11 01          # /#/                                   
23 30 21 02          # /#/{{{c(4)}}} ~·---------·~           
23 34 21 03          # /#/{{{c(4)}}} ~¦~​{{{c(1)}}}​~ra ¦ a7 ¦~
23 38 31 02          # /#/{{{c(4)}}} ~¦~​{{{c(1)}}}​~sp ¦ s2 ¦~
23 3C 31 03          # /#/{{{c(4)}}} ~¦~​{{{c(1)}}}​~·· ¦ ·· ¦~
23 30 41 04          # /#/{{{c(4)}}} ~¦~​{{{c(1)}}}​~a5 ¦ t6 ¦~
23 34 41 05          # /#/{{{c(4)}}} ~¦~​{{{c(1)}}}​~a6 ¦ pc ¦~
23 38 51 04          # /#/{{{c(4)}}} ~·---------·~           
23 3C 51 05          #                                       
23 30 61 06          #                                       
23 34 61 07          #                                       
23 38 71 06          #                                       
23 3C 71 07          #                                       
23 30 81 08          #                                       
23 34 81 09          #                                       
23 38 91 08          #                                       
23 3C 91 09          #                                       
23 30 A1 0A          #                                       
23 34 A1 0B          #                                       
23 38 B1 0A          #                                       
23 3C B1 0B          #                                       
23 30 C1 0C          #                                       
23 34 C1 0D          #                                       
23 38 D1 0C          #                                       
23 3C D1 0D          #                                       
23 30 E1 0E          #                                       
23 34 E1 0F          #                                       
23 38 F1 0E          #
23 3C F1 0F          #
                     # /# Print top 256 stack bytes/         
                     # /# using subroutine ~TYPE~./          
13 05 01 00          # ~addr@a0 ← sp;~                       
93 05 00 10          # ~u@a1 ← 0x100;~                       
99 54                # ~call TYPE;~  /# Compiled./           
                     #                                       
                     # /# Restore return address and/        
                     # /# clean the stack./                  
83 30 01 10          # ~restore ra;~                         
13 01 81 10          #                                       
67 80 00 00          # ~return.~

# 99 F2 99 C2          # reg BYE


# ============= TEXT INTERPRETER
#
# Standard Forth handles input one line at a time.
# SmithForth's text interpreter is a simple interpreter in the standard Forth style.
# SVAL (see standard Forth's EVALUATE) interprets each line.
# REFILL fetches a line of input, including its trailing LF, and sets the input source state.
#     10000000 #IN      cell contains #characters in the current line.
#     10000008 TIB      cell contains the address where the current line begins.
#     10000010 >IN      cell contains #characters in the current line that have been parsed.
#     10000020 STATE    cell contains 0(Interpreting) or 1(Compiling).
#     10000028 Latest   cell contains the execution token (xt) of the latest defined Forth word.
# In Forth, to parse is to remove from the input stream. As a line is parsed, [>IN] increases from 0 to [#IN].
# Forth's "parse area" is the part of the line not yet parsed.

99 06 52 45 46 49 4C 4C # REFILL ( -- ) ==========================================================
                     # {{{i(1)}}} /# Advance ~TIB~​ by ~#IN~./      
                     # {{{i(1)}}} /#/                                  
                     # {{{i(1)}}} /# Note:         ~#IN~ is ~VARS+0~,/ 
                     # {{{i(1)}}} /# {{{i(2.35)}}} ~TIB~ is ~VARS+8~,/ 
                     # {{{i(1)}}} /# {{{i(2.35)}}} ~>IN~ is ~VARS+16~./
83 32 09 00          # {{{i(1)}}} ~#in@t0 ← [#IN];~                    
03 33 89 00          # {{{i(1)}}} ~tib@t1 ← [TIB] + #in@t0;~           
33 03 53 00          # {{{i(1)}}}                                      
23 34 69 00          # {{{i(1)}}} ~[TIB] ← tib@t1;~                    
                     # {{{i(1)}}}                                      
                     # {{{i(1)}}} /# Reset ~#IN~ and ~>IN~ to 0./      
93 02 00 00          # {{{i(1)}}} ~#in@t0 &= 0;~                       
23 38 09 00          # {{{i(1)}}} ~[>IN] &= 0;~                        
                     # {{{i(1)}}}                                      
                     # {{{i(1)}}} /# Advance ~#IN~ until just/         
                     # {{{i(1)}}} /# after first ~LF~ character./      
                     # ~_begin:~                                       
93 82 12 00          # {{{i(1)}}} ~#in@t0++;~                          
b3 03 53 00          # {{{i(1)}}} ~chr@t3 ← [tib@t1 + #in@t0 - 1];~    
03 ce f3 ff          # {{{i(1)}}}                                      
                     # {{{i(1)}}} /# Newline character?/               
93 0e a0 00          # {{{i(1)}}} ~if chr != 0x0A:~                    
e3 18 de ff          # {{{i(2)}}}   ~goto _begin.~                     
                     # {{{i(1)}}}                                      
                     # {{{i(1)}}} /# Store the new ~#IN~./             
23 30 59 00          # {{{i(1)}}} ~[#IN] ← #in@t0;~                    
67 80 00 00          # {{{i(1)}}} ~return.~


99 04 73 65 65 6B ####### seek ( cl dl "ccc" -- eflags ) parse until 1st char of parse area is within [cl, dl) or parse area is empty
13 0f 00 00          # {{{c(2)}}} ~eof@a0 ← 0;~                        
                     # {{{c(2)}}} ~high'@a1 ← high@a1~                 
b3 85 a5 40          # {{{c(11)}}}         ~- low@a0;~                 
83 33 09 01          # {{{c(2)}}} ~>in@t2 ← [>IN];~                    
83 32 09 00          # {{{c(2)}}} ~#in@t0 ← [#IN];~                    
                     # ~_begin:~                                       
                     # {{{c(2)}}} /# Is parse area empty?/             
                     # {{{c(2)}}} ~if >in@t2~ \ge{{{unsigned}}} ~#in@t0:~
63 f0 53 02          # {{{c(4)}}}   ~goto _end_eof.~                   
                     # {{{c(2)}}} /# Get current character./           
03 33 89 00          # {{{c(2)}}} ~tib@t1 ← [TIB];~                    
                     # {{{c(2)}}} ~chr@t3 ← [tib@t1~                   
b3 0e 73 00          # {{{c(10)}}}        ~+ >in@t2];~                 
03 ce 0e 00          # {{{c(2)}}}                                      
                     # {{{c(2)}}} /# Is ~chr~ in ~[low, high)~?/       
                     # {{{c(2)}}} ~chr'@t3 ← chr@t3~                   
33 0e ae 40          # {{{c(10)}}}        ~- low@a0;~                  
                     # {{{c(2)}}} ~if t3~ \lt{{{unsigned}}} ~high'@a1:~  
63 68 be 00          # {{{c(4)}}}   ~goto _end.~                       
                     # {{{c(2)}}} /# Go to next character./            
93 83 13 00          # {{{c(2)}}} ~>in@t2++;~                          
6f f0 5f fe          # {{{c(2)}}} ~goto _begin.~                       
                     # ~_end_eof:~                                     
13 0f 10 00          # {{{c(2)}}} ~eof@a0 ← 1;~                        
                     # ~_end:~                                         
23 38 79 00          # {{{c(2)}}} ~[>IN] ← >in@t2;~                    
13 05 0f 00          # {{{c(2)}}} ~eof@a0 ← eof@t5;~                                        
67 80 00 00          # {{{c(2)}}} ~return.~


99 05 50 41 52 53 45 #### PARSE ( cl dl "ccc<char>" -- rbp=addr rax=u ) addr: where ccc begins ; u: length of ccc
00                   #
13 01 01 ff          # {{{c( 2)}}} ~push ra;~                         
23 34 11 00          # {{{c( 2)}}}                                    
83 32 09 01          # {{{c( 2)}}} ~start@t0 ← [>IN];~                
23 30 51 00          # {{{c( 2)}}} ~push start@t0;~                   
                     # {{{c( 2)}}} /# Compile a call to ~seek~/       
                     # {{{c( 2)}}} /# that advances ~>IN~./           
99 73                # {{{c( 2)}}} ~call seek;~  /# Compiled./        
03 33 09 01          # {{{c( 2)}}} ~end@t1 ← [>IN];~                  
83 32 01 00          # {{{c( 2)}}} ~restore start@t0;~                
                     # {{{c( 2)}}} /# Did ~seek()~ encounter the/     
                     # {{{c( 2)}}} /# end of the parse area?/         
                     # {{{c( 2)}}} ~if eof@a0 != 0:~                   
63 96 02 00          # {{{c( 4)}}}   ~goto _end.~                     
                     # {{{c( 2)}}} /# A character in range/           
                     # {{{c( 2)}}} /# ~[low, high)~ was found./       
93 03 13 00          # {{{c( 2)}}} ~[>IN]++;~  /# Skip it./           
23 38 79 00          # {{{c( 2)}}}                                    
                     # ~_end:~                                        
                     # {{{c( 2)}}} /# Compute address and/            
                     # {{{c( 2)}}} /# length of parsed input./        
83 33 89 00          # {{{c( 2)}}} ~addr@a0 ← [TIB]~                  
33 85 53 00          # {{{c(10)}}}         ~+ start@t0;~              
b3 05 53 40          # {{{c( 2)}}} ~u@a0~ ~←~ ~end@t1~ ~-~ ~start@t0;~
83 30 81 00          # {{{c( 2)}}} ~pop ra;~                          
13 01 01 01          # {{{c( 2)}}}                                    
67 80 00 00          # {{{c( 2)}}} ~return.~                          


99 05 70 6E 61 6D 65 #### pname ( "<spaces>ccc<space>" -- rbp=addr rax=u ) PARSE-NAME ============
00                   #
13 01 81 ff          # ~push ra;~                        
23 30 11 00          #                                   
                     # /# Skip non-printables./          
13 05 10 02          # ~low@a0 ← 0x21;~   /# Char ~'!'~./
93 05 f0 07          # ~high@a1 ← 0x7F;~  /# Char ~DEL~./
99 73                # ~call seek;~  /# Compiled./       
                     # /# Parse token, stopping at first/
                     # /# non-printable character./      
13 05 f0 07          # ~low@a0 ← 0x7F;~                  
93 05 10 02          # ~high@a1 ← 0x21;~                 
99 50                # ~call PARSE;~  /# Compiled./      
83 30 01 00          # ~pop ra;~                         
13 01 81 00          #                                   
67 80 00 00          # ~return.~


99 03 61 62 63 ############# abc ( -- ) testing function ============================================= TEMPORARY ============= 0x00000000100003f4
00                   #
b7 09 00 10          # {{{c(2)}}} ~STACK@s3 ← 0x10000000;~     
93 89 09 00          # {{{c(2)}}}                              
23 34 89 00          # {{{c(2)}}} ~[TIB] ← INPUT@s0;~          
99 52                # {{{c(2)}}} ~call REFILL;~  /# Compiled./
                     # ~_begin:~                               
99 70                # {{{c(2)}}} ~call pname;~   /# Compiled./
6f f0 9f ff          # {{{c(2)}}} ~goto _begin.~               

99 e1                # abc
