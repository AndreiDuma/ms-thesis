#+TITLE: From Assembly Forth to Lisp (and Back)
#+SUBTITLE: A Journey through the Imperative, Concatenative and Functional Realms
#+DATE: September 2024
#+AUTHOR: Andrei Dorian Duma
#+EMAIL: andrei-dorian.duma@s.unibuc.ro
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 29.2 (Org mode 9.6.15)

#+BIBLIOGRAPHY: References.bib
#+CITE_EXPORT: csl csl/ieee.csl

#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:{} arch:headline
#+OPTIONS: author:nil broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:nil todo:t |:t

#+STARTUP: logdrawer

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,8pt]
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:
#+LATEX_ENGRAVED_THEME:
#+LATEX_COMPILER: pdflatex

# --- Nice author line ---
#+LATEX_HEADER: \usepackage{authblk}
#+LATEX_HEADER: \author[1]{Andrei Dorian Duma\thanks{andrei-dorian.duma@s.unibuc.ro}}
#+LATEX_HEADER: \affil[1]{Master of Distributed Systems}

# --- Allow hiding table columns in the LaTeX export
#+LATEX_HEADER: \usepackage{array}
#+LATEX_HEADER: \newcolumntype{H}{>{\setbox0=\hbox\bgroup}c<{\egroup}@{}}

# TODO: remove if not needed.
#+LATEX_HEADER: \usepackage{unicode-math}

# --- Indentation helper macros.
#+MACRO: t   \hspace{1em}  # TODO: rewrite this one to use {{{c(x)}}}.
#+MACRO: i   (eval (format "\\hspace{%sem}" $1))
#+MACRO: c   (eval (format "\\hspace{%fem}" (* 0.5265 (string-to-number $1))))
#+MACRO: b   (eval (format "\\hspace{%fem}" (* 3 0.5265 (string-to-number $1))))

# --- Byte annotation macros.
#+MACRO: modrm   ~$1~​$^{\text{\tiny ModR/M}}_{\text{\tiny $2·$3·$4}}$
#+MACRO:   sib   ~$1~​$^{\text{\tiny    SIB}}_{\text{\tiny $1·$2·$3}}$
#+MACRO: offset  _~$1~_​$_{\text{\tiny $2}}$
#+MACRO: displ   $^{\text{\tiny +}}$​_~$1~_

# --- Byte interpreter macros.
#+MACRO: define  ~[99~ $^{d}$​~$1~ _~$2~_​~]~
#+MACRO: compile ~[99~ $^{c}$​~$1~​$_{$2}$​~]~
#+MACRO: execute ~[99~ $^{e}$​~$1~​$_{$2}$​~]~

# -- Other annotation macros.
#+MACRO: addr     (eval (if (string-equal $1 "00") (format "$\\overline{\\texttt{%s}}$" $1) (format "\\texttt{%s}" $1)))
#+MACRO: unsigned $^{u}$

# Additional options are set in `.dir-locals.el`.


# Don't show abstract for now.
# #+begin_abstract
# In this thesis we explore the process of implementing a high-level
# programming language, beginning with only a limited set of
# foundational elements: the =x86_64= architecture, several simple Linux
# system calls, the GNU Assembler and the shell. We are interested in
# how the level of abstraction is progressively increased by defining
# higher-level linguistic constructs in terms of more primitive
# ones. The approach will be pedagogical, favoring implementation
# choices that are clear and understandable.

# Our final goal is implementing a usable high-level language in the
# LISP family, which we will call /quectoLISP/ (following the tradition
# of prefixing names of small languages with SI submultiples). We
# accomplish this in three stages. First, we write (in assembly) a
# threaded interpreter for /quectoFORTH/, a small language inheriting
# from Chuck Moore's Forth. Then, using this interpreter, we implement a
# simple /quectoLISP/ interpreter providing the most useful language
# features. Finally, we write a /quectoLISP/ compiler in /quectoLISP/
# itself, running it in the stage-two interpreter. This compiler emits
# =x86_64= assembly and becomes self-hosted, being able to compile
# itself.
# #+end_abstract
# \clearpage

# Don't show TOC for now.
# #+TOC: headlines 2
# \clearpage


* Introduction                                                     :noexport:

** Our Objectives

#+begin_comment
What are the objectives of this thesis?
- Learn low-level processor programming, interpreter & compiler
  design.
- Understand how high-level languages are translated all the way to
  machine code; understand all intermediate steps.
- Find a short(est) path to high-level programming from nothing but
  machine code and Linux system calls.
#+end_comment


** An Incremental Approach

#+begin_comment
Why this approach?
- Reference inspiration paper: "An incremental approach to compiler
  construction".
#+end_comment


* Stage 1: A Forth Interpreter in Machine Code

** The =x86-64= Architecture                                       :noexport:

#+CAPTION: Instruction prefixes.
#+LABEL: tbl:instruction-prefixes
| Prefix                | Hex |
|-----------------------+-----|
| REPNE/REPNZ           | F2  |
| REP, REPE/REPZ        | F3  |
| Operand-size override | 66  |
| Address-size override | 67  |

#+CAPTION: Useful =x86-64= instructions.
#+LABEL: tbl:instructions
| Mnemonic | Opcode (hex) |
|----------+--------------|
| CALL     | =E8=         |
|          | =FF=         |


** The Linux Environment

*** Linux System Calls                                             :noexport:

#+CAPTION: Calling convention for Linux system calls under =x86-64=.
#+LABEL: tbl:syscall-calling-convention
|------------+---------------------------------------------------------------------|
| *Register* | *Usage*                                                             |
|------------+---------------------------------------------------------------------|
| RAX        | Syscall number (the identifier of the system call being requested). |
|------------+---------------------------------------------------------------------|
| RDI        | First argument to the syscall.                                      |
| RSI        | Second argument to the syscall.                                     |
| RDX        | Third argument to the syscall.                                      |
| R10        | Fourth argument to the syscall.                                     |
| R8         | Fifth argument to the syscall.                                      |
| R9         | Sixth argument to the syscall.                                      |
|------------+---------------------------------------------------------------------|

#+CAPTION: Linux system calls used in this Forth implementation.
#+LABEL: tbl:syscalls
| *Syscall* | *Name* | *RAX*  | *RDI*               | *RSI*             | *RDX*          |
|-----------+--------+--------+---------------------+-------------------+----------------|
|         0 | read   | =0x00= | =unsigned int fd=   | =char *buf=       | =size_t count= |
|         1 | write  | =0x01= | =unsigned int fd=   | =const char *buf= | =size_t count= |
|        12 | brk    | =0x0C= | =unsigned long brk= | –                 | –              |
|        60 | exit   | =0x3C= | =int error_code=    | –                 | –              |


*** ELF: The _E_​xecutable _F_​ile _F_​ormat

Cite Chapter 4 (/Object Files/) of [cite:@system_v_abi].

**** ELF File Header

#+CAPTION: ELF file header for an =x86-64= Linux executable.
#+LABEL: tbl:elf-file-header
#+ATTR_LATEX: :align l|l|l
| *&*            | *File Header Bytes*                 | *Explanation*                                                                      |
|----------------+-------------------------------------+------------------------------------------------------------------------------------|
| {{{addr(00)}}} | {{{b(0)}}}​~7F 45 4C 46~             | ~e_ident[EI_MAG]~: ELF magic number.                                               |
|                | {{{b(4)}}}​~02~                      | ~e_ident[EI_CLASS]~: ~1~ → 32-bit, _~2~ → 64-bit_.                                 |
|                | {{{b(5)}}}​~01~                      | ~e_ident[EI_DATA]~: _~1~ → little-endian_, ~2~ → big-endian.                       |
|                | {{{b(6)}}}​~01~                      | ~e_ident[EI_VERSION]~: ELF header version; must be ~1~.                            |
|                | {{{b(7)}}}​~00~                      | ~e_ident[EI_OSABI]~: Target OS ABI; ~ELFOSABI_NONE~ (~0~) is fine for Linux.       |
|                | {{{b(0)}}}​~00~                      | ~e_ident[EI_ABIVERSION]~: ABI version; should be ~0~ for Linux.                    |
|                | {{{b(1)}}}​~00 00 00 00 00 00 00~    | ~e_ident[EI_PAD]~: Padding; unused; should be ~0~.                                 |
|----------------+-------------------------------------+------------------------------------------------------------------------------------|
|                | {{{b(0)}}}​~02 00~                   | ~e_type~: Object file type; ~2~ → executable.                                      |
|                | {{{b(2)}}}​~3E 00~                   | ~e_machine~: Instruction set architecture; _~0x3E~ → ~x86-64~_, ~0xF3~ → ~RISC-V~. |
|                | {{{b(4)}}}​~01 00 00 00~             | ~e_version~: ELF identification version; must be ~1~.                              |
|                | {{{b(0)}}}​~78 00 40 00 00 00 00 00~ | ~e_entry~: Memory address of entry point (where process starts).                   |
|                | {{{b(0)}}}​~40 00 00 00 00 00 00 00~ | ~e_phoff~: File offset of program headers; ~0x34~ → ~32-bit~, _~0x40~ → 64-bit_.   |
|                | {{{b(0)}}}​~00 00 00 00 00 00 00 00~ | ~e_shoff~: File offset section headers (we don't have any sections).               |
|----------------+-------------------------------------+------------------------------------------------------------------------------------|
|                | {{{b(0)}}}​~00 00 00 00~             | ~e_flags~: 0 for the ~x86-64~ architecture.                                        |
|                | {{{b(4)}}}​~40 00~                   | ~e_ehsize~: Size of this header; ~0x34~ → 32-bit, _~0x40~ → 64-bit_.               |
|                | {{{b(6)}}}​~38 00~                   | ~e_phentsize~: Size of each program header; ~0x20~ → 32-bit, _~0x38~ → 64-bit_.    |
|                | {{{b(0)}}}​~01 00~                   | ~e_phnum~: Number of program headers; here ~1~.                                    |
|                | {{{b(2)}}}​~40 00~                   | ~e_shentsize~: Size of each section header; ~0x28~ → 32-bit, _~0x40~ → 64-bit_.    |
|                | {{{b(4)}}}​~00 00~                   | ~e_shnum~: Number of section headers; here ~0~.                                    |
|                | {{{b(6)}}}​~00 00~                   | ~e_shstrndx~: Index of section header containing section names; N/A.               |
|----------------+-------------------------------------+------------------------------------------------------------------------------------|
| {{{addr(40)}}} |                                     |                                                                                    |

**** ELF Program Header

#+CAPTION: ELF program header.
#+LABEL: tbl:elf-program-header
#+ATTR_LATEX: :align l|l|l
| *&*            | *File Header Bytes*                 | *Explanation*                                                                                       |
|----------------+-------------------------------------+-----------------------------------------------------------------------------------------------------|
| {{{addr(40)}}} | {{{b(0)}}}​~01 00 00 00~             | ~p_type~: Segment type; ~1~ → loadable.                                                             |
|                | {{{b(4)}}}​~07 00 00 00~             | ~p_flags~: Segment-wise permissions; _1 → execute_, _2 → write_, _4 → read_.                        |
|                | {{{b(0)}}}​~00 00 00 00 00 00 00 00~ | ~p_offset~: Offset of segment in file; we load the whole file, so ~0~.                              |
|                | {{{b(0)}}}​~00 00 40 00 00 00 00 00~ | ~p_vaddr~: Virtual address of segment in memory; ~0x400000~ on ~x86-64~ [cite:@system_v_abi_amd64]. |
|                | {{{b(0)}}}​~00 00 00 00 00 00 00 00~ | ~p_paddr~: Only used on systems where physical address is relevant.                                 |
|                | {{{b(0)}}}​~02 1E 01 00 00 00 00 00~ | ~p_filesz~: Size of the segment in the file image (~TODO~).                                         |
|                | {{{b(0)}}}​~00 00 C0 7F 00 00 00 00~ | ~p_memsz~: Size of the segment in memory (\ge ~p_filesz~).                                            |
|                | {{{b(0)}}}​~00 10 00 00 00 00 00 00~ | ~p_align~: Align segment to ~x86-64~ page size (4096 or ~0x1000~) [cite:@system_v_abi_amd64].       |
|----------------+-------------------------------------+-----------------------------------------------------------------------------------------------------|
| {{{addr(78)}}} |                                     |                                                                                                     |


** Implementing FORTH

:LOGBOOK:
- Note taken on [2024-07-27 Sat 13:49] \\
  Maybe collect all global variables in one place?
- Note taken on [2024-07-29 Mon 10:23] \\
  Maybe rename ~Head~ to ~DEFN~ (to resemble ~COMPL~)?
:END:

*** Global variables

| *Variable* | *Register*​/​*Address*   | *Contents*                                                    |
|------------+------------------------+---------------------------------------------------------------|
| ~INPUT~    | ~RSI~                  | Source address of binary interpreter data and commands.       |
| ~OUTPUT~   | ~RDI~                  | Destination address of binary interpreter operations.         |
| ~#IN~      | ~0x10000000 (VARS)~    | The number of characters in the current line.                 |
| ~TIB~      | ~0x10000008 (VARS+8)~  | The address where the current line begins.                    |
| ~>IN~      | ~0x10000010 (VARS+16)~ | The number of /parsed/ characters in the current line.        |
| ~STATE~    | ~0x10000020 (VARS+32)~ | Either ~0~ (/interpreting/ state) or ~1~ (/compiling/ state). |
| ~LATEST~   | ~0x10000028 (VARS+40)~ | The execution token (/xt/) of the latest defined Forth word.  |


#+CAPTION: Global variables =INPUT= and =OUTPUT=.
#+LABEL: tbl:forth:globals
#+ATTR_LATEX: :align l|ll|l|l
| *Pseudocode*                  | *Instruction*    | *Opcode*   | *&*            | *Machine code*       |
|-------------------------------+------------------+------------+----------------+----------------------|
| /# Global variable ~INPUT~./  |                  |            |                |                      |
| ~INPUT@RSI ← 0x004000B2;~     | MOV r32, /imm32/ | B8+rd /id/ | {{{addr(78)}}} | ~BE~ /~B2 00 40 00~/ |
| /# Global variable ~OUTPUT~./ |                  |            |                |                      |
| ~OUTPUT@RDI ← 0x10000030;~    | MOV r32, /imm32/ | B8+rd /id/ | {{{addr(7D)}}} | ~BF~ /~30 00 00 10~/ |
|                               |                  |            | {{{addr(82)}}} |                      |


*** Binary interpreter                                             :noexport:

#+CAPTION: The binary interpreter routine and loop.
#+LABEL: tbl:forth:bi
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                  | *Instruction*    | *Opcode*      | *&*            | *Machine code*                          | *Intention*             |
|-----------------------------------------------+------------------+---------------+----------------+-----------------------------------------+-------------------------|
| ~_bi:~                                        |                  |               | {{{addr(82)}}} |                                         |                         |
| {{{i(1)}}} /# Loop the binary interpreter./   |                  |               |                |                                         |                         |
| {{{i(1)}}} ~call bi();~                       | CALL _rel32_     | E8 _cb_[fn:1] |                | ~E8~ {{{offset(02 00 00 00,89-87)}}}    | call bi()               |
| {{{i(1)}}} ~goto _bi.~                        | JMP _rel8_       | EB _cb_       | {{{addr(87)}}} | ~EB~ {{{offset(F9,82-89)}}}             | jump _bi                |
| ~bi():~                                       |                  |               | {{{addr(89)}}} |                                         |                         |
| {{{i(1)}}} /# Read next byte from ~INPUT~./   |                  |               |                |                                         |                         |
| {{{i(1)}}} ~chr@AL ← [INPUT@RSI++];~          | LODS m8          | AC            |                | ~AC~                                    | al = [rsi++]            |
| {{{i(1)}}} /# Does it start a command?/       |                  |               |                |                                         |                         |
| {{{i(1)}}} ~if chr@AL = 0x99:~                | CMP AL, /imm8/   | 3C /ib/       |                | ~3C~ /~99~/                             | cmp al, 99(command)     |
| {{{i(2)}}}     ~goto _command.~               | JE _rel8_        | 74 _cb_       |                | ~74~ {{{offset(02,90-8E)}}}             | jump _command if ==     |
| {{{i(1)}}} /# If not, just copy the byte/     |                  |               |                |                                         |                         |
| {{{i(1)}}} /# to ~OUTPUT~ and return./        |                  |               |                |                                         |                         |
| {{{i(1)}}} ~[OUTPUT@RDI++] <- chr@AL;~        | STOS m8          | AA            | {{{addr(8E)}}} | ~AA~                                    | [rdi++] = al (xmit)     |
| {{{i(1)}}} ~return.~                          | RET              | C3            |                | ~C3~                                    | return                  |
| ~_command:~                                   |                  |               | {{{addr(90)}}} |                                         |                         |
| {{{i(1)}}} /# Global variable ~LATEST~./      |                  |               |                |                                         |                         |
| {{{i(1)}}} ~LATEST@RDX ← 0x10000028;~         | MOV r32, /imm32/ | B8+rd /id/    |                | ~BA~ /~28 00 00 10~/                    | rdx = Latest            |
| {{{i(1)}}} /# Read command argument./         |                  |               |                |                                         |                         |
| {{{i(1)}}} ~arg@AL ← [INPUT@RSI++];~          | LODS m8          | AC            |                | ~AC~                                    | al = [rsi++] (argument) |
| {{{i(1)}}} /# Command type by argument:/      |                  |               |                |                                         |                         |
| {{{i(1)}}} /# – ~0bx00xxxxx~: define;/        |                  |               |                |                                         |                         |
| {{{i(1)}}} /# – ~0b011xxxxx~: compile;/       |                  |               |                |                                         |                         |
| {{{i(1)}}} /# – ~0b111xxxxx~: execute./       |                  |               |                |                                         |                         |
| {{{i(1)}}} ~if arg & 0b01100000 = 0:~         | TEST AL, /imm8/  | A8 /ib/       |                | ~A8~ /~60~/                             | al & 60(graphic)?       |
| {{{i(2)}}}     /# Define a new word./         |                  |               |                |                                         |                         |
| {{{i(2)}}}     ~goto Head.~                   | JZ _rel8_        | 74 _cb_       |                | ~74~ {{{offset(31,CB-9A)}}}             | jump Head if zero       |
| {{{i(1)}}} /# Get latest dictionary entry./   |                  |               | {{{addr(9A)}}} |                                         |                         |
| {{{i(1)}}} ~entry@RBX ← *LATEST;~             | MOV r64, r/m64   | REX.W 8B /r   |                | ~48 8B~ {{{modrm(1A,00,011,010)}}}      | rbx = [rdx]             |
| ~_find1:~                                     |                  |               | {{{addr(9D)}}} |                                         |                         |
| {{{i(1)}}} ~save arg@AL on the stack;~        | PUSH r64         | 50+rd         |                | ~50~                                    | push al                 |
| {{{i(1)}}} ~chr@AL &= 0b0111111;~             | AND AL, /imm8/   | 24 /ib/       |                | ~24 7F~                                 | al &= 7F                |
| {{{i(1)}}} ~if char@AL = [entry + 11]:~       | CMP r8, r/m8     | REX 3A /r     |                | ~3A 43~ {{{modrm(11,00,010,001)}}}      | cmp al, [rbx+11]        |
| {{{i(2)}}}     /# We found an entry whose/    |                  |               |                |                                         |                         |
| {{{i(2)}}}     /# name begins with ~chr~./    |                  |               |                |                                         |                         |
| {{{i(2)}}}     ~restore arg@AL;~              | POP r64          | 58+rd         |                | ~58~                                    | pop al                  |
| {{{i(2)}}}     ~goto _match.~                 | JE _rel8_        | 74 _cb_       |                | ~74~ {{{offset(06,AC-A6)}}}             | jump _match if ==       |
| {{{i(1)}}} /# Follow entry's link pointer/    |                  |               | {{{addr(A6)}}} |                                         |                         |
| {{{i(1)}}} /# to previous entry and repeat./  |                  |               |                |                                         |                         |
| {{{i(1)}}} ~entry ← [entry + 8];~             | MOV r64, r/m64   | REX.W 8B /r   |                | ~48 8B~ {{{modrm(5B,01,011,011)}}} ~08~ | rbx = [rbx+8]           |
| {{{i(1)}}} ~goto _find1.~                     | JMP _rel8_       | EB _cb_       |                | ~EB~ {{{offset(F1,9D-AC)}}}             | jump _find1             |
| ~_match:~                                     |                  |               | {{{addr(AC)}}} |                                         |                         |
| {{{i(1)}}} ~if arg & 0b1000000 = 0:~          | TEST AL, /imm8/  | A8 /ib/       |                | ~A8~ /~80~/                             | al & 80(exec) ?         |
| {{{i(2)}}}     /# Compile./                   |                  |               |                |                                         |                         |
| {{{i(2)}}}     ~goto COMPL.~                  | JZ _rel8_        | 74 _cb_       |                | ~74~ {{{offset(09,B9-B0)}}}             | jump COMPL if zero      |
| {{{i(1)}}} /# Execute: jump to entry's code./ |                  |               | {{{addr(B0)}}} |                                         |                         |
| {{{i(1)}}} ~goto [entry@RBX].~                | JMP r/m64        | REX FF /4     |                | ~FF~ {{{modrm(23,00,100,011)}}}         | jump [rbx] (exec)       |
|                                               |                  |               | {{{addr(B2)}}} |                                         |                         |

**** COMPL                                                         :noexport:

#+CAPTION: =COMPL=, the FORTH compiler.
#+LABEL: tbl:forth:compl
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                                                                | *Instruction*  | *Opcode*   | *&*            | *Machine code*                  | *Intention*                                        |
|---------------------------------------------------------------------------------------------+----------------+------------+----------------+---------------------------------+----------------------------------------------------|
| /# Define:/ _~COMPL~_                                                                       | ---            | ---        | {{{addr(B2)}}} | {{{define(99,43 4F 4D 50 4C)}}} | define COMPL                                       |
| /# In/Out:/ ~( xt@EBX -- )~                                                                 |                |            |                |                                 |                                                    |
|                                                                                             |                |            |                |                                 |                                                    |
| /# Generate a CALL instr. to ~OUTPUT~:/                                                     |                |            |                |                                 |                                                    |
| /# – instruction: CALL r/m64/                                                               |                |            |                |                                 |                                                    |
| /# – opcode: FF /2/                                                                         |                |            |                |                                 |                                                    |
| /#/                                                                                         |                |            |                |                                 |                                                    |
| /# Thus we generate code as follows:/                                                       |                |            |                |                                 |                                                    |
| /#/{{{c(2)}}}​~FF~ {{{modrm(14,00,010,100)}}} {{{sib(25,00,100,101)}}} _~??~ ~??~ ~??~ ~??~_ |                |            |                |                                 |                                                    |
|                                                                                             |                |            |                |                                 |                                                    |
| /# 1. Write opcode of CALL (0x99)./                                                         |                |            |                |                                 |                                                    |
| ~op@AL ← 0xFF;~                                                                             | MOV r8, /imm8/ | B0+rb /ib/ | {{{addr(B9)}}} | ~B0~ /FF/                       | compile: call r/m64 (FF /2, 00 010 100, 00 100 101 |
| ~[OUTPUT@RDI++] ← op@AL;~                                                                   | STOS m8        | AA         |                | ~AA~                            |                                                    |
| /# 2. Write ModR/M byte (0x14)./                                                            |                |            |                |                                 |                                                    |
| ~modrm@AL ← 0x14;~                                                                          | MOV r8, /imm8/ | B0+rb /ib/ |                | ~B0~ /14/                       | al = _                                             |
| ~[OUTPUT@RDI++] ← op@AL;~                                                                   | STOS m8        | AA         |                | ~AA~                            |                                                    |
| /# 3. Write SIB byte (0x25)./                                                               |                |            |                |                                 |                                                    |
| ~sib@AL ← 0x25;~                                                                            | MOV r8, /imm8/ | B0+rb /ib/ |                | ~B0~ /25/                       | [rdi++] = al                                       |
| ~[OUTPUT@RDI++] ← op@AL;~                                                                   | STOS m8        | AA         |                | ~AA~                            |                                                    |
| /# 4. Write 4-byte code address./                                                           |                |            |                |                                 |                                                    |
| ~xt@EAX ← xt@EBX;~                                                                          | XCHG EAX, r32  | 90+rd      |                | ~93~                            | eax = ebx                                          |
| ~[OUTPUT@RDI++4] ← xt@EAX;~                                                                 | STOS m32       | AB         |                | ~AB~                            | [rdi(++4)] = eax                                   |
|                                                                                             |                |            |                |                                 |                                                    |
| ~return.~  /# From binary interpreter./                                                     | RET            | C3         |                | ~C3~                            | return                                             |
|                                                                                             |                |            | {{{addr(C5)}}} |                                 |                                                    |

**** Head                                                          :noexport:

#+CAPTION: Subroutine =Head= defines new words in the dictionary.
#+LABEL: tbl:forth:head
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                               | *Instruction*     | *Opcode*         | *&*            | *Machine code*                          | *Intention*   |
|--------------------------------------------+-------------------+------------------+----------------+-----------------------------------------+---------------|
| /# Define:/ _~Head~_                       | ---               | ---              | {{{addr(C5)}}} | {{{define(04,48 65 61 64)}}}            | define Head   |
| /# In/Out:/ ~( flag@AL -​- )~               |                   |                  |                |                                         |               |
|                                            |                   |                  |                |                                         |               |
| /# 16-bit align ~OUTPUT~./                 |                   |                  |                |                                         |               |
| ~OUTPUT@RDI += 0x0F;~                      | ADD r/m64, /imm8/ | REX.W 83 /0 /ib/ | {{{addr(CB)}}} | ~48 83~ {{{modrm(C7,11,000,111)}}} ~0F~ | rdi += 0F     |
| ~OUTPUT@RDI &= 0xF0;~                      | AND r/m64, /imm8/ | REX.W 83 /4 /ib/ |                | ~48 83~ {{{modrm(E7,11,100,111)}}} ~F0~ | rdi &= F0     |
|                                            |                   |                  |                |                                         |               |
| /# Fill the new dictionary entry:/         |                   |                  |                |                                         |               |
|                                            |                   |                  |                |                                         |               |
| /# 1. Set the _link field_, then set/      |                   |                  |                |                                         |               |
| /#{{{c(3)}}}LATEST to the new entry./      |                   |                  |                |                                         |               |
| ~latest@RCX ← [LATEST@RDX];~               | MOV r64, r/m64    | REX.W 8B /r      |                | ~48 8B~ {{{modrm(0A,00,001,010)}}}      | rcx = [rdx]   |
| ~[OUTPUT@RDI+8] ← latest@RCX;~             | MOV r/m64, r64    | REX.W 89 /r      |                | ~48 89~ {{{modrm(4F,01,001,111)}}} ~08~ | [rdi+8] = rcx |
| ~[LATEST@RDX] ← OUTPUT@RDI;~               | MOV r/m64, r64    | REX.W 89 /r      |                | ~48 89~ {{{modrm(3A,00,111,010)}}}      | [rdx] = rdi   |
|                                            |                   |                  |                |                                         |               |
| /# 2. Set the _flag+length field_./        |                   |                  |                |                                         |               |
| ~OUTPUT@RDI += 0x10;~                      | ADD r/m64, /imm8/ | REX.W 83 /0 /ib/ |                | ~48 83~ {{{modrm(C7,11,000,111)}}} ~10~ | rdi += 10     |
| ~[OUTPUT@RDI++] ← flag@AL;~                | STOS m8           | AA               |                | ~AA~                                    | [rdi++] = al  |
|                                            |                   |                  |                |                                         |               |
| /# 3. Extract name length from flag/       |                   |                  |                |                                         |               |
| /#{{{c(3)}}}and copy _name field_./        |                   |                  |                |                                         |               |
| ~flag@ECX ← flag@AL;~                      | XCHG EAX, r32     | 90+rd            |                | ~91~                                    | ecx = eax     |
| ~length@ECX ← flag@ECX & 0x1F;~            | AND r/m32, /imm8/ | 83 /​4 /ib/       |                | ~83~ {{{modrm(E1,11,100,001)}}} ~1F~    | ecx &= 1F     |
| ~copy      length@ECX bytes~               |                   |                  |                |                                         |               |
| {{{c(5)}}}​~from INPUT@RSI~                 |                   |                  |                |                                         |               |
| {{{c(5)}}}​~to OUTPUT@RDI;~                 | REP MOVS m8, m8   | F3 A4            |                | ~F3 A4~                                 | copy Name     |
|                                            |                   |                  |                |                                         |               |
| /# 4. Point _code field_ to the machine/   |                   |                  |                |                                         |               |
| /#{{{c(3)}}}code that follows at ~INPUT~./ |                   |                  |                |                                         |               |
| ~code@RCX ← [LATEST@RDX];~                 | MOV r64, r/m64    | REX.W 8B /r      |                | ~48 8B~ {{{modrm(0A,00,001,010)}}}      | rcx = [rdx]   |
| ~[code@RCX] ← INPUT@RDI;~                  | MOV r/m64, r64    | REX.W 89 /r      |                | ~48 89~ {{{modrm(39,00,111,001)}}}      | [rcx] = rdi   |
| ~return.~  /# From binary interpreter./    | RET               | C3               |                | ~C3~                                    | return        |


*** Subroutine BYE                                                 :noexport:

#+CAPTION: Subroutine ~BYE~ terminates the program by performing an ~exit~ syscall.
#+LABEL: tbl:forth:bye
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                       | *Instruction*  | *Opcode* | *Machine code*                  | *Intention*            |
|------------------------------------+----------------+----------+---------------------------------+------------------------|
| /# Define:/ _~BYE~_                | ---            | ---      | {{{define(03,42 59 45)}}}       | define BYE             |
| /# In/Out: ~( -​- )~/               |                |          |                                 |                        |
|                                    |                |          |                                 |                        |
| /# Goodbye, world (exit syscall)./ |                |          |                                 |                        |
| ~nr@RAX ← 0x3C;~  /# ~__NR_exit~./ | PUSH /imm8/    | 6A /ib/  | ~6A~ /~3C~/                     | rax = exit (no return) |
|                                    | POP            | 58+rd    | ~58~                            |                        |
| ~status@RDI ← 0;~                  | XOR r/m32, r32 | 31 /r    | ~31~ {{{modrm(FF,11,111,111)}}} | rdi = stat             |
| ~syscall exit(status@RDI).~        | SYSCALL        | 0F 05    | ~0F 05~                         | syscall                |
|                                    |                |          |                                 |                        |


*** Subroutine TYPE                                                :noexport:
:LOGBOOK:
- Note taken on [2024-07-29 Mon 13:19] \\
  Why not save ~RSI~ and ~RDI~ inside ~TYPE~ rather than at call sites?
:END:

#+CAPTION: Subroutine ~TYPE~ dumps a memory range to ~STDOUT~.
#+LABEL: tbl:forth:type
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                     | *Instruction*   | *Opcode*    | *&*                  | *Machine code*                     | *Intention*           |
|--------------------------------------------------+-----------------+-------------+----------------------+------------------------------------+-----------------------|
| /# Define:/ _~TYPE~_                             | ---             | ---         |                      | {{{define(04,54 59 50 45)}}}       | define TYPE           |
| /# In/Out: ~( addr@RSI u@RDX~/                   |                 |             |                      |                                    |                       |
| /#{{{c(6)}}} ~-​- ?@RSI ?@RDI )~/                 |                 |             |                      |                                    |                       |
| /#/                                              |                 |             |                      |                                    |                       |
| /# Dump memory range ~[addr, addr+u)~./          |                 |             |                      |                                    |                       |
|                                                  |                 |             |                      |                                    |                       |
| {{{i(1)}}} ~fd@RDI ← 1;~ /# ~STDOUT_FILENO~./    | PUSH /imm8/     | 6A /ib/     |                      | ~6A~ /~01~/                        | rdi(fd) = stdout = 1  |
|                                                  | POP             | 58+rd       |                      | ~5F~                               |                       |
| ~_beg:~                                          |                 |             | {{{addr(00)}}}[fn:2] |                                    |                       |
| {{{i(1)}}} /# ~__NR_write~ is also 1./           |                 |             |                      |                                    |                       |
| {{{i(1)}}} ~nr@RAX ← fd@RDI;~                    | MOV r32, r/m32  | 8B /r       |                      | ~8B~ {{{modrm(C7,11,000,111)}}}    | rax = write = 1 = rdi |
| {{{i(1)}}} ~syscall write(fd@RDI,~               |                 |             |                      |                                    |                       |
| {{{i(1)}}}{{{c(14)}}}    ~addr@RSI,~             |                 |             |                      |                                    |                       |
| {{{i(1)}}}{{{c(14)}}}    ~u@RDX);~               | SYSCALL         | 0F 05       |                      | ~0F 05~                            | syscall               |
| {{{i(1)}}} ~if ret@RAX < 0:~                     | TEST r/m64, r64 | REX.W 85 /r |                      | ~48 85~ {{{modrm(C0,11,000,000)}}} | cmp rax, 0            |
| {{{i(2)}}} /# An error occured./                 |                 |             |                      |                                    |                       |
| {{{i(2)}}}     ~goto _end.~                      | JL _rel8_       | 7C _cb_     |                      | ~7C~ {{{offset(08,11-09)}}}        | +jump _end if <       |
| {{{i(1)}}} /# Advance by ~ret~ (printed) bytes./ |                 |             | {{{addr(09)}}}       |                                    |                       |
| {{{i(1)}}} ~addr@RSI += ret@RAX;~                | ADD r/m64, r64  | REX.W 01 /r |                      | ~48 01~ {{{modrm(C6,11,000,110)}}} | rsi(buf) += rax       |
| {{{i(1)}}} /# Fewer bytes left to print./        |                 |             |                      |                                    |                       |
| {{{i(1)}}} ~u@RDX -= ret@RAX;~                   | SUB r/m64, r64  | REX.W 29 /r |                      | ~48 29~ {{{modrm(C2,11,000,010)}}} | rdx(count) -= rax     |
| {{{i(1)}}} ~if count > 0:~                       |                 |             |                      |                                    |                       |
| {{{i(2)}}}     /# We still have bytes to print./ |                 |             |                      |                                    |                       |
| {{{i(2)}}}     ~goto _beg.~                      | JG _rel8_       | 7F _cb_     |                      | ~7F~ {{{offset(EF,00-11)}}}        | -jump _beg if >       |
| ~_end:~                                          |                 |             | {{{addr(11)}}}       |                                    |                       |
| {{{i(1)}}} ~return.~                             | RET             | C3          |                      | ~C3~                               | return                |


*** Debugging utilities                                            :noexport:

#+CAPTION: Subroutine ~dbg~ dumps the working memory to ~STDOUT~.
#+LABEL: tbl:forth:dbg
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                           | *Instruction*    | *Opcode*   | *Machine code*            | *Intention* |
|----------------------------------------+------------------+------------+---------------------------+-------------|
| /# Define:/ _~dbg~_                    | ---              | ---        | {{{define(03,64 52 67)}}}​ | define dbg  |
| /# In/Out: ~( -​- )~/                   |                  |            |                           |             |
| /#/                                    |                  |            |                           |             |
| /# Dump the working memory./           |                  |            |                           |             |
|                                        |                  |            |                           |             |
| ~save INPUT@RSI on the stack;~         | PUSH r64         | 50+rd      | ~56~                      | push rsi    |
| ~save OUTPUT@RDI on the stack;~        | PUSH r64         | 50+rd      | ~57~                      | push rdi    |
| /# Dump memory contents using/         |                  |            |                           |             |
| /# subroutine ~TYPE~./                 |                  |            |                           |             |
| ~addr@RSI ← 0x0FFFFFE0;~               | MOV r32, /imm32/ | B8+rd /id/ | ~BE~ /~E0 FF FF 0F~/      | rsi = addr  |
| ~u@RDX ← 0x0A00;~                      | MOV r32, /imm32/ | B8+rd /id/ | ~BA~ /~00 0A 00 00~/      | rdx = u     |
| /# Compile a CALL to ~TYPE(addr, u)~./ |                  |            |                           |             |
| ~call TYPE;~  /# Compiled./            | ---              | ---        | {{{compile(54,T)}}}       | Call TYPE   |
| /# Restore registers and return./      |                  |            |                           |             |
| ~restore OUTPUT@RDI;~                  | POP r64          | 58+rd      | ~5F~                      | pop rdi     |
| ~restore INPUT@RSI;~                   | POP r64          | 58+rd      | ~5E~                      | pop rsi     |
| ~return.~                              | RET              | C3         | ~C3~                      | return      |
|                                        |                  |            |                           |             |

#+CAPTION: Subroutine ~reg~ dumps the registers to ~STDOUT~.
#+LABEL: tbl:forth:reg
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                             | *Instruction*     | *Opcode*         | *Machine code*                        | *Intention*             |
|------------------------------------------+-------------------+------------------+---------------------------------------+-------------------------|
| /# Define:/ _~reg~_                      | ---               | ---              | {{{define(03,72 65 67)}}}             | define reg              |
| /# In/Out: ~( -​- )~/                     |                   |                  |                                       |                         |
| /#/                                      |                   |                  |                                       |                         |
| /# Dump the registers./                  |                   |                  |                                       |                         |
|                                          |                   |                  |                                       |                         |
| ~save INPUT@RSI;~                        | PUSH r64          | 50+rd            | ~56~                                  | push rsi                |
| ~save OUTPUT@RDI;~                       | PUSH r64          | 50+rd            | ~57~                                  | push rdi                |
|                                          |                   |                  |                                       |                         |
| /# Push the 16 registers on the/         | PUSH r64          | REX 50+rd        | ~41 57~                               | push r15, rdi, r14, rsi |
| /# stack so that when printed/           | PUSH r64          | 50+rd            | ~57~                                  | push r13, rbp, r12, rsp |
| /# they're displayed like this:/         | PUSH r64          | REX 50+rd        | ~41 56~                               | push r11, rbx, r10, rdx |
| /#/                                      | PUSH r64          | 50+rd            | ~56~                                  | push r9 , rcx, r8 , rax |
| /#/{{{c(4)}}} ~·-----------·~            | PUSH r64          | REX 50+rd        | ~41 55~                               |                         |
| /#/{{{c(4)}}} ~¦~​{{{c(1)}}}​~R15 ¦ RDI ¦~ | PUSH r64          | 50+rd            | ~55~                                  |                         |
| /#/{{{c(4)}}} ~¦~​{{{c(1)}}}​~R14 ¦ RSI ¦~ | PUSH r64          | REX 50+rd        | ~41 54~                               |                         |
| /#/{{{c(4)}}} ~¦~​{{{c(1)}}}​~··· ¦ ··· ¦~ | PUSH r64          | 50+rd            | ~54~                                  |                         |
| /#/{{{c(4)}}} ~¦~​{{{c(2)}}}​~R8  ¦ RAX ¦~ | PUSH r64          | REX 50+rd        | ~41 53~                               |                         |
| /#/{{{c(4)}}} ~·-----------·~            | PUSH r64          | 50+rd            | ~53~                                  |                         |
|                                          | PUSH r64          | REX 50+rd        | ~41 52~                               |                         |
|                                          | PUSH r64          | 50+rd            | ~52~                                  |                         |
|                                          | PUSH r64          | REX 50+rd        | ~41 51~                               |                         |
|                                          | PUSH r64          | 50+rd            | ~51~                                  |                         |
|                                          | PUSH r64          | REX 50+rd        | ~41 50~                               |                         |
|                                          | PUSH r64          | 50+rd            | ~50~                                  |                         |
| /# Print top 128 stack bytes using/      |                   |                  |                                       |                         |
| /# subroutine ~TYPE(addr, u)~./          |                   |                  |                                       |                         |
| ~addr@RSI ← RSP;~                        | MOV r64, r/m64    | REX.W 8B /r      | ~48 8B~ {{{modrm(F4,11,110,100)}}}    | rsi = rsp               |
| ~u@RDX <- 0x80;~                         | MOV r32, /imm32/  | B8+rd /id/       | ~BA~ /~80 00 00 00~/                  | rdx = u                 |
| ~call TYPE;~  /# Compiled./              | ---               | ---              | {{{compile(54,T)}}}                   | Call TYPE               |
| /# Clean the stack./                     |                   |                  |                                       |                         |
| ~pop 16 quads;~                          | SUB r/m64, /imm8/ | REX.W 83 /5 /ib/ | ~48 83~ {{{modrm(EC,11,101,100)}}} 80 | rsp -= -80              |
| ~restore OUTPUT@RDI;~                    | POP r64           | 58+rd            | ~5F~                                  | pop rdi                 |
| ~restore INPUT@RSI;~                     | POP r64           | 58+rd            | ~5E~                                  | pop rsi                 |
| ~return.~                                | RET               | C3               | ~C3~                                  | return                  |
|                                          |                   |                  |                                       |                         |


*** Text interpreter

# ============= TEXT INTERPRETER
#
# Standard Forth handles input one line at a time.
# SmithForth's text interpreter is a simple interpreter in the standard Forth style.
# SVAL (see standard Forth's EVALUATE) interprets each line.
# REFILL fetches a line of input, including its trailing LF, and sets the input source state.
#     10000000 #IN      cell contains #characters in the current line.
#     10000008 TIB      cell contains the address where the current line begins.
#     10000010 >IN      cell contains #characters in the current line that have been parsed.
#     10000020 STATE    cell contains 0(Interpreting) or 1(Compiling).
#     10000028 Latest   cell contains the execution token (xt) of the latest defined Forth word.
# In Forth, to parse is to remove from the input stream. As a line is parsed, [>IN] increases from 0 to [#IN].
# Forth's "parse area" is the part of the line not yet parsed.

**** REFILL                                                        :noexport:

#+CAPTION: Subroutine ~REFILL~ TODO.
#+LABEL: tbl:forth:refill
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                     | *Instruction*      | *Opcode*         | *&*            | *Machine code*                                            | *Intention*      |
|--------------------------------------------------+--------------------+------------------+----------------+-----------------------------------------------------------+------------------|
| /# Define:/ _~REFILL~_                           | ---                | ---              |                | {{{define(06,52 45 46 49 4C 4C)}}}                        | define REFILL    |
| /# In/Out: ~( -​- )~/                             |                    |                  |                |                                                           |                  |
| /#/                                              |                    |                  |                |                                                           |                  |
| /# Advance ~TIB~ and ~#IN~ so/                   |                    |                  |                |                                                           |                  |
| /# that ~[TIB, #IN)~ contains/                   |                    |                  |                |                                                           |                  |
| /# a new line to be parsed./                     |                    |                  |                |                                                           |                  |
|                                                  |                    |                  |                |                                                           |                  |
| {{{i(1)}}} /# Base address of globals./          |                    |                  |                |                                                           |                  |
| {{{i(1)}}} ~VARS@R9 ← 0x10000000;~               | MOV r/m64, /imm32/ | REX.W C7 /​0 /id/ |                | ~49 C7~ {{{modrm(C1,11,000,001)}}} /~00 00 00 10~/        | r9 = VAR         |
|                                                  |                    |                  |                |                                                           |                  |
| {{{i(1)}}} /# Advance ~TIB~​ by ~#IN~./           |                    |                  |                |                                                           |                  |
| {{{i(1)}}} /#/                                   |                    |                  |                |                                                           |                  |
| {{{i(1)}}} /# Note:         ~#IN~ is ~VARS+0~,/  |                    |                  |                |                                                           |                  |
| {{{i(1)}}} /# {{{i(2.35)}}} ~TIB~ is ~VARS+8~,/  |                    |                  |                |                                                           |                  |
| {{{i(1)}}} /# {{{i(2.35)}}} ~>IN~ is ~VARS+16~./ |                    |                  |                |                                                           |                  |
| {{{i(1)}}} ~nIN@RAX ← [#IN];~                    | MOV r64, r/m64     | REX.W 8B /r      |                | ~49 8B~ {{{modrm(01,00,000,001)}}}                        | rax = [#IN]      |
| {{{i(1)}}} ~[TIB] += nIN@RAX;~                   | ADD r/m64, r64     | REX.W 01 /r      |                | ~49 01~ {{{modrm(41,01,000,001)}}} {{{displ(08)}}}        | [TIB] += rax     |
| {{{i(1)}}} /# Reset ~#IN~ and ~>IN~ to 0./       |                    |                  |                |                                                           |                  |
| {{{i(1)}}} ~[#IN] &= 0;~                         | AND r/m64, /imm8/  | REX.W 83 /​4 /ib/ |                | ~49 83~ {{{modrm(21,00,100,001)}}} /~00~/                 | [#IN] = 0        |
| {{{i(1)}}} ~[>IN] &= 0;~                         | AND r/m64, /imm8/  | REX.W 83 /​4 /ib/ |                | ~49 83~ {{{modrm(61,01,100,001)}}} {{{displ(10)}}} /~00~/ | [>IN] = 0        |
|                                                  |                    |                  |                |                                                           |                  |
| {{{i(1)}}} /# Advance ~#IN~ until just/          |                    |                  |                |                                                           |                  |
| {{{i(1)}}} /# after first ~LF~ character./       |                    |                  |                |                                                           |                  |
| ~_beg:~                                          |                    |                  | {{{addr(00)}}} |                                                           | _beg:            |
| {{{i(1)}}} ~[#IN]++;~                            | INC r/m64          | REX.W FF /0      |                | ~49 FF~ {{{modrm(01,00,000,001)}}}                        | [#IN]++          |
| {{{i(1)}}} ~RAX ← [TIB];~                        | MOV r64, r/m64     | REX.W 8B /r      |                | ~49 8B~ {{{modrm(41,01,000,001)}}} {{{displ(08)}}}        | rax = [TIB]      |
| {{{i(1)}}} ~RAX += [#IN];~                       | ADD r64, r/m64     | REX.W 03 /r      |                | ~49 03~ {{{modrm(01,00,000,001)}}}                        | rax += [#IN]     |
| {{{i(1)}}} /# Newline character?/                |                    |                  |                |                                                           |                  |
| {{{i(1)}}} ~if [RAX-1] != 0x0A:~                 | CMP r/m8, /imm8/   | 80 /​7 /ib/       |                | ~80~ {{{modrm(78,01,111,000)}}} {{{displ(FF)}}} /~0A~/    | cmp [rax-1], LF  |
| {{{i(2)}}}   ~goto _beg.~                        | JNE _rel8_         | 75 _cb_          |                | ~75~ {{{offset(F0,00-10)}}}                               | -jump _beg if != |
| {{{i(1)}}} ~return.~                             | RET                | C3               | {{{addr(10)}}} | ~C3~                                                      | return           |

**** seek                                                          :noexport:

#+CAPTION: Subroutine ~seek~ parses characters until it finds one in a given range.
#+LABEL: tbl:forth:seek
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                  | *Instruction*      | *Opcode*         | *&*            | *Machine code*                                     | *Intention*                                 |
|-----------------------------------------------+--------------------+------------------+----------------+----------------------------------------------------+---------------------------------------------|
| /# Define:/ _~seek~_                          | ---                | ---              |                | {{{define(04,73 65 65 6B)}}}                       | define seek                                 |
| /# In/Out:    ~( low@CL high@DL~/             |                    |                  |                |                                                    |                                             |
| /# {{{c(8)}}} ​~"ccc"~/                        |                    |                  |                |                                                    |                                             |
| /# {{{c(5)}}}​ ~-​- FLAGS )~/                   |                    |                  |                |                                                    |                                             |
| /#/                                           |                    |                  |                |                                                    |                                             |
| /# Advance ~>IN~ until next/                  |                    |                  |                |                                                    |                                             |
| /# char is within ~[low, high)~/              |                    |                  |                |                                                    |                                             |
| /# or parse area is empty./                   |                    |                  |                |                                                    |                                             |
|                                               |                    |                  |                |                                                    |                                             |
| {{{c(2)}}} ~VARS@R9 ← 0x10000000;~            | MOV r/m64, /imm32/ | REX.W C7 /​0 /id/ |                | ~49 C7~ {{{modrm(C1,11,000,001)}}} /~00 00 00 10~/ | r9 = VAR                                    |
| {{{c(2)}}} ~high@DL -= low@CL;~               | SUB r8, r/m8       | 2A /r            |                | ~2A~ {{{modrm(D1,11,010,001)}}}                    | dl -= cl                                    |
| ~_beg:~                                       |                    |                  | {{{addr(00)}}} |                                                    | # _beg:  like WITHIN ( al cl dl -- eflags ) |
| {{{c(2)}}} /# Is parse area empty?/           |                    |                  |                |                                                    |                                             |
| {{{c(2)}}} ~RAX ← [>IN];~                     | MOV r64, r/m64     | REX.W 8B /r      |                | ~49 8B~ {{{modrm(41,01,000,001)}}} {{{displ(10)}}} | rax = [>IN]                                 |
| {{{c(2)}}} ~if RAX~ \ge{{{unsigned}}} ~[#IN]:~  | CMP r64, r/m64     | REX.W 3B /r      |                | ~49 3B~ {{{modrm(01,00,000,001)}}}                 | cmp rax, [#IN]                              |
| {{{c(4)}}}   ~goto _end.~                     | JAE _rel8_         | 73 _cb_          |                | ~73~ {{{offset(16,1F-09)}}}                        | +jump _end if U>=                           |
| {{{c(2)}}} /# Get current character./         |                    |                  | {{{addr(09)}}} |                                                    |                                             |
| {{{c(2)}}} ~RAX ← [TIB];~                     | MOV r64, r/m64     | REX.W 8B /r      |                | ~49 8B~ {{{modrm(41,01,000,001)}}} {{{displ(08)}}} | rax = [TIB]                                 |
| {{{c(2)}}} ~RAX += [>IN];~                    | ADD r64, r/m64     | REX.W 03 /r      |                | ~49 03~ {{{modrm(41,01,000,001)}}} {{{displ(10)}}} | rax += [>IN]                                |
| {{{c(2)}}} ~chr@AL ← [RAX];~                  | MOV r8, r/m8       | 8A /r            |                | ~8A~ {{{modrm(00,00,000,000)}}}                    | al = [rax]                                  |
| {{{c(2)}}} /# Is ~chr~ in ~[low, high)~?/     |                    |                  |                |                                                    |                                             |
| {{{c(2)}}} ~AL -= low@CL;~                    | SUB r8, r/m8       | 2A /r            |                | ~2A~ {{{modrm(C1,11,000,001)}}}                    | al -= cl                                    |
| {{{c(2)}}} ~if AL~ \lt{{{unsigned}}} ~high@DL:~ | CMP r8, r/m8       | 3A /r            |                | ~3A~ {{{modrm(C2,11,000,010)}}}                    | cmp al, dl                                  |
| {{{c(4)}}}   ~goto _end.~                     | JB _rel8_          | 72 _cb_          |                | ~72~ {{{offset(06,1F-19)}}}                        | +jump _end if U<                            |
| {{{c(2)}}} /# Go to next character./          |                    |                  | {{{addr(19)}}} |                                                    |                                             |
| {{{c(2)}}} ~[>IN]++;~                         | INC r/m64          | REX.W FF /0      |                | ~49 FF~ {{{modrm(41,01,000,001)}}} {{{displ(10)}}} | [>IN]++                                     |
| {{{c(2)}}} ~goto _beg.~                       | JMP _rel8_         | EB _cb_          |                | ~EB~ {{{offset(E1,00-1F)}}}                        | -jump _beg                                  |
| ~_end:~                                       |                    |                  | {{{addr(1F)}}} |                                                    | # _end:                                     |
| {{{c(2)}}} ~return.~                          | RET                | C3               |                | ~C3~                                               | return                                      |

**** PARSE                                                         :noexport:

#+CAPTION: Subroutine ~PARSE~ returns the address and size of a newly parsed string.
#+LABEL: tbl:forth:parse
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                               | *Instruction*      | *Opcode*         | *&*            | *Machine code*                                     | *Intention*                                                                         |
|--------------------------------------------+--------------------+------------------+----------------+----------------------------------------------------+-------------------------------------------------------------------------------------|
| /# Define:/ _~PARSE~_                      | ---                | ---              |                | {{{define(04,50 41 52 53 45)}}}                    | define PARSE                                                                        |
| /# In/Out:    ~( low@CL high@DL~/          |                    |                  |                |                                                    |                                                                                     |
| /# {{{c(8)}}} ​~"ccc<char>"~/               |                    |                  |                |                                                    |                                                                                     |
| /# {{{c(5)}}}​ ~-​- addr@RBP u@RAX )~/       |                    |                  |                |                                                    |                                                                                     |
| /#/                                        |                    |                  |                |                                                    |                                                                                     |
| /# *TODO*:/                                |                    |                  |                |                                                    |                                                                                     |
| /# -- addr: where ccc begins/              |                    |                  |                |                                                    |                                                                                     |
| /# -- u: length of ccc/                    |                    |                  |                |                                                    |                                                                                     |
|                                            |                    |                  |                |                                                    |                                                                                     |
| {{{c( 2)}}} ~VARS@R9 ← 0x10000000;~        | MOV r/m64, /imm32/ | REX.W C7 /​​0 /id/ |                | ~49 C7~ {{{modrm(C1,11,000,001)}}} /~00 00 00 10~/ | r9 = VAR                                                                            |
| {{{c( 2)}}} ~start@RBP ← [>IN];~           | MOV r64, r/m64     | REX.W 8B /r      |                | ~49 8B~ {{{modrm(69,01,101,001)}}} {{{displ(10)}}} | rbp = [>IN]                                                                         |
| {{{c( 2)}}} /# Compile a call to ~seek~/   |                    |                  |                |                                                    |                                                                                     |
| {{{c( 2)}}} /# that advances ~>IN~./       |                    |                  |                |                                                    |                                                                                     |
| {{{c( 2)}}} ~call seek;~  /# Compiled./    | ---                | ---              |                | {{{compile(73,s)}}}                                | Call seek  (parse until 1st instance within [cl, dl) is parsed or parse area empty) |
| {{{c( 2)}}} ~end@RAX ← [>IN];~             | MOV r64, r/m64     | REX.W 8B /r      |                | ~49 8B~ {{{modrm(41,01,000,001)}}} {{{displ(10)}}} | rax = [>IN]                                                                         |
| {{{c( 2)}}} /# Did ~seek()~ encounter the/ |                    |                  |                |                                                    |                                                                                     |
| {{{c( 2)}}} /# end of the parse area?/     |                    |                  |                |                                                    |                                                                                     |
| {{{c( 2)}}} ~if parse area empty:~         |                    |                  |                |                                                    |                                                                                     |
| {{{c( 4)}}}   ~goto _end.~                 | JAE _rel8_         | 73 _cb_          |                | ~73~ {{{offset(04,04-00)}}}                        | +jump _end if U>=                                                                   |
| {{{c( 2)}}} ~[>IN]++;~  /# ???/            | INC r/m64          | REX.W FF /0      | {{{addr(00)}}} | ~49 FF~ {{{modrm(41,01,000,001)}}} {{{displ(10)}}} | [>IN]++                                                                             |
| ~_end:~                                    |                    |                  | {{{addr(04)}}} |                                                    | # _end:                                                                             |
| {{{c( 2)}}} /# Compute address and/        |                    |                  |                |                                                    |                                                                                     |
| {{{c( 2)}}} /# size of parsed input./      |                    |                  |                |                                                    |                                                                                     |
| {{{c( 2)}}} ~u@RAX = end@RAX~              |                    |                  |                |                                                    |                                                                                     |
| {{{c( 8)}}}       ~- start@RBP;~           | SUB r/m64, r64     | REX.W 29 /r      |                | ~48 29~ {{{modrm(E8,11,101,000)}}}                 | rax -= rbp                                                                          |
| {{{c( 2)}}} ~addr@RBP = bgn@RBP~           | ADD r64, r/m64     | REX.W 03 /r      |                | ~49 03~ {{{modrm(69,01,101,001)}}} {{{displ(08)}}} | rbp += [TIB]                                                                        |
| {{{c(11)}}}          ~+ [TIB];~            |                    |                  |                |                                                    |                                                                                     |
| {{{c( 2)}}} ~return.~                      | RET                | C3               |                | ~C3~                                               | return                                                                              |

**** pname                                                         :noexport:

#+CAPTION: Subroutine ~pname~ TODO.
#+LABEL: tbl:forth:pname
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                            | *Instruction*  | *Opcode*   | *Machine code*                  | *Intention*            |
|-----------------------------------------+----------------+------------+---------------------------------+------------------------|
| /# Define:/ _~pname~_                   | ---            | ---        | {{{define(05,70 6E 61 6D 65)}}} | define pname           |
| /# In/Out:    ~( "<spaces>ccc<space>"~/ |                |            |                                 |                        |
| /# {{{c(6)}}}​ ~-​- addr@RBP u@RAX )~/    |                |            |                                 |                        |
| /#/                                     |                |            |                                 |                        |
| /# *TODO*: PARSE-NAME???/               |                |            |                                 |                        |
| /# -- addr: where ccc begins/           |                |            |                                 |                        |
| /# -- u: length of ccc/                 |                |            |                                 |                        |
|                                         |                |            |                                 |                        |
| ~low@CL ← 0x21;~   /# ??/               | MOV r8, /imm8/ | B0+rb /ib/ | ~B1~ /~21~/                     |                        |
| ~high@DL ← 0x7F;~  /# ??/               | MOV r8, /imm8/ | B0+rb /ib/ | ~B2~ /~7F~/                     | (cl, dl) = (BL+1, ...) |
| ~call seek;~  /# Compiled./             | ---            | ---        | {{{compile(73,s)}}}             | Call seek              |
| ~low@CL ← 0x7F;~                        | MOV r8, /imm8/ | B0+rb /ib/ | ~B1~ /~7F~/                     |                        |
| ~high@DL ← 0x21;~                       | MOV r8, /imm8/ | B0+rb /ib/ | ~B2~ /~21~/                     | (cl, dl) = (..., BL+1) |
| ~call PARSE;~  /# Compiled./            |                |            | {{{compile(50,P)}}}             | Call PARSE             |
| ~return.~                               | RET            | C3         | ~C3~                            | return                 |

**** [                                                             :noexport:

#+CAPTION: Subroutine ~'['~ changes Forth's ~STATE~ to interpreting.
#+LABEL: tbl:forth:lbracket
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                      | *Instruction* | *Opcode* | *Machine code*                                                                    | *Intention*          |
|-----------------------------------+---------------+----------+-----------------------------------------------------------------------------------+----------------------|
| /# Define immediate:/ _~[~_       | ---           | ---      | {{{define(81,5B)}}}                                                               | define [             |
| /# In/Out:    ~( -​- )~/           |               |          |                                                                                   |                      |
| /#/                               |               |          |                                                                                   |                      |
| /# Switch to interpreting state./ |               |          |                                                                                   |                      |
|                                   |               |          |                                                                                   |                      |
| /# Set STATE to 0./               |               |          |                                                                                   |                      |
| ~push 0;~                         | PUSH /imm8/   | 6A /ib/  | ~6A~ /~00~/                                                                       | push 0(Interpreting) |
| ~[STATE] ← pop;~                  | POP r/m64     | 8F /0    | ~8F~ {{{modrm(04,00,000,100)}}} {{{sib(25,00,100,101)}}} {{{displ(20 00 00 10)}}} | pop [STATE]          |
| ~return.~                         | RET           | C3       | ~C3~                                                                              | return               |

**** ]                                                             :noexport:

#+CAPTION: Subroutine ~']'~ changes Forth's ~STATE~ to compiling.
#+LABEL: tbl:forth:rbracket
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                   | *Instruction* | *Opcode* | *Machine code*                                                                    | *Intention*       |
|--------------------------------+---------------+----------+-----------------------------------------------------------------------------------+-------------------|
| /# Define:/ _~]~_              | ---           | ---      | {{{define(01,5D)}}}                                                               | define ]          |
| /# In/Out: ~( -​- )~/           |               |          |                                                                                   |                   |
| /#/                            |               |          |                                                                                   |                   |
| /# Switch to compiling state./ |               |          |                                                                                   |                   |
|                                |               |          |                                                                                   |                   |
| /# Set STATE to 1./            |               |          |                                                                                   |                   |
| ~push 1;~                      | PUSH /imm8/   | 6A /ib/  | ~6A~ /~01~/                                                                       | push 1(Compiling) |
| ~[STATE] ← pop;~               | POP r/m64     | 8F /0    | ~8F~ {{{modrm(04,00,000,100)}}} {{{sib(25,00,100,101)}}} {{{displ(20 00 00 10)}}} | pop [STATE]       |
| ~return.~                      | RET           | C3       | ~C3~                                                                              | return            |

**** \                                                             :noexport:

#+CAPTION: Subroutine ~'\'~ implements line comments.
#+LABEL: tbl:forth:backslash
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                    | *Instruction*  | *Opcode*    | *Machine code*                                                                       | *Intention* |
|---------------------------------+----------------+-------------+--------------------------------------------------------------------------------------+-------------|
| /# Define immediate:/ _~\~_     | ---            | ---         | {{{define(81,5C)}}}                                                                  | define \    |
| /# In/Out: ~( "ccc<eol>" -​- )~/ |                |             |                                                                                      |             |
| /#/                             |                |             |                                                                                      |             |
| /# Consumes all characters/     |                |             |                                                                                      |             |
| /# left on the current line./   |                |             |                                                                                      |             |
|                                 |                |             |                                                                                      |             |
| ~RAX ← [#IN];~                  | MOV r64, r/m64 | REX.W 8B /r | ~48 8B~ {{{modrm(04,00,000,100)}}} {{{sib(25,00,100,101)}}} {{{displ(00 00 00 10)}}} | rax = [#IN] |
| ~[>IN] ← RAX;~                  | MOV r/m64, r64 | REX.W 89 /r | ~48 89~ {{{modrm(04,00,000,100)}}} {{{sib(25,00,100,101)}}} {{{displ(10 00 00 10)}}} | [>IN] = rax |
| ~return.~                       | RET            | C3          | ~C3~                                                                                 | return      |

**** (                                                             :noexport:

#+CAPTION: Subroutine ~'('~ implements inline comments (ending with a corresponding ~')'~).
#+LABEL: tbl:forth:lparen
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                               | *Instruction*  | *Opcode*   | *Machine code*      | *Intention*                                                                 |
|--------------------------------------------+----------------+------------+---------------------+-----------------------------------------------------------------------------|
| /# Define immediate:/ _~(~_                | ---            | ---        | {{{define(81,28)}}} | define (                                                                    |
| /# In/Out: ~( "ccc<rparen>" -​- )~/         |                |            |                     |                                                                             |
| /#/                                        |                |            |                     |                                                                             |
| /# Consume characters until a ')' occurs./ |                |            |                     |                                                                             |
|                                            |                |            |                     |                                                                             |
| ~low@CL ← ')';~                            | MOV r8, /imm8/ | B0+rb /ib/ | ~B1~ /~29~/         |                                                                             |
| ~high@DL ← ')' + 1;~                       | MOV r8, /imm8/ | B0+rb /ib/ | ~B2~ /~2A~/         | (cl, dl) = (RP, RP+1)                                                       |
| ~call PARSE;~  /# Compiled./               | ---            | ---        | {{{compile(50,P)}}} | Call PARSE            Forth 2012 implies comment ends at rparen or newline. |
| ~return.~                                  | RET            | C3         | ~C3~                | return                                                                      |

**** :                                                             :noexport:

#+CAPTION: Subroutine ~:~ (colon) begins compiling a word after setting up its dictionary entry.
#+LABEL: tbl:forth:colon
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                              | *Instruction*     | *Opcode*          | *Machine code*                            | *Intention*                            |
|-------------------------------------------+-------------------+-------------------+-------------------------------------------+----------------------------------------|
| /# Define:/ _~':'~_                       | ---               | ---               | {{{define(01,3A)}}}                       | define :                               |
| /# In/Out: ~( "<spaces>ccc<space>" -​- )~/ |                   |                   |                                           |                                        |
| /#/                                       |                   |                   |                                           |                                        |
| /# *TODO*​/                                |                   |                   |                                           |                                        |
|                                           |                   |                   |                                           |                                        |
| /# TODO./                                 |                   |                   |                                           |                                        |
| ~call pname;~  /# Compiled./              | ---               | ---               | {{{compile(70,p)}}}                       | Call pname  (See Forth 2012 Table 2.1) |
| ~RSI ← RBP;~                              | MOV r/m64, r64    | REX.W 89 /r       | ~48 89~ {{{modrm(EE,11,101,110)}}}        | rsi = rbp                              |
| ~RDX ← LATEST;~                           | MOV r32, /imm32/  | B8+rd /id/        | ~BA~ /~28 00 00 10~/                      | rdx = Latest                           |
| ~call Head;~  /# Compiled./               | ---               | ---               | {{{compile(48,H)}}}                       | Call Head                              |
|                                           |                   |                   |                                           |                                        |
| /# Set the HIDDEN flag (~0x40~)/          |                   |                   |                                           |                                        |
| /# on the dictionary entry./              |                   |                   |                                           |                                        |
| ~RCX ← [RDX];~                            | MOV r64, r/m64    | REX.W 8B /r       | ~48 8B~ {{{modrm(0A,00,001,010)}}}        | rcx = [rdx]                            |
| ~RCX += 16;~                              | ADD r/m64, /imm8/ | 9REX.W 83 /​0 /ib/ | ~48 83~ {{{modrm(C1,11,000,001)}}} /~10~/ | rcx += 10                              |
| ~[RCX]~ \vert{}​~=~ ~0x40;~                      | OR r/m8, /imm8/   | 80 /​1 /ib/        | ~80~ {{{modrm(09,00,001,001)}}} /~40~/    | [rcx] ¦= 40 HIDDEN                     |
|                                           |                   |                   |                                           |                                        |
| /# Switch to compiling state./            |                   |                   |                                           |                                        |
| ~call rbracket;~  /# Compiled./           | ---               | ---               | {{{compile(5D,])}}}                       | Call ]                                 |
| ~return.~                                 | RET               | C3                | ~C3~                                      | return                                 |

**** ;                                                             :noexport:

#+CAPTION: Subroutine ~';'~ (semicolon) wraps up a colon definition and goes back to interpreting.
#+LABEL: tbl:forth:semicolon
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                              | *Instruction*     | *Opcode*         | *Machine code*                                              | *Intention*          |
|-------------------------------------------+-------------------+------------------+-------------------------------------------------------------+----------------------|
| /# Define immediate:/ _~;~_               | ---               | ---              | {{{define(81,3B)}}}                                         | define ;             |
| /# In/Out: ~( C: -​- )~/                   |                   |                  |                                                             |                      |
| /#/                                       |                   |                  |                                                             |                      |
| /# Finalize a colon definition and/       |                   |                  |                                                             |                      |
| /# switch back to interpreting state./    |                   |                  |                                                             |                      |
|                                           |                   |                  |                                                             |                      |
| /# Write a RET instr. to ~OUTPUT~./       |                   |                  |                                                             |                      |
| ~op@AL ← 0xC3;~  /# RET opcode./          | MOV r8, /imm8/    | B0+rb /ib/       | ~B0~ /~C3~/                                                 | al = opcode ret      |
| ~[OUTPUT@RDI++] ← op@AL;~                 | STOS m8           | AA               | ~AA~                                                        | [rdi++] = al         |
|                                           |                   |                  |                                                             |                      |
| /# Clear the HIDDEN flag (~0x40~)/        |                   |                  |                                                             |                      |
| /# on the dictionary entry./              |                   |                  |                                                             |                      |
| ~RCX ← [LATEST];~                         | MOV r64, r/m64    | REX.W 8B /r      | ~48 8B~ {{{modrm(0C,00,001,100)}}} {{{sib(25,00,100,101)}}} | rcx = [Latest]       |
|                                           |                   |                  | \hookrightarrow {{{c(2)}}} {{{displ(28 00 00 10)}}}         |                      |
| ~RCX += 0x10;~                            | ADD r/m64, /imm8/ | REX.W 83 /​0 /ib/ | ~48 83~ {{{modrm(C1,11,000,001)}}} /10/                     | rcx += 10            |
| ~[flagRCX] &= 0b10111111;~                | AND r/m8, /imm8/  | 80 /4 /ib/       | ~80~ {{{modrm(21,00,100,001)}}} /BF/                        | [rcx] &= BF(~HIDDEN) |
|                                           |                   |                  |                                                             |                      |
| /# Switch to interpreting state./         |                   |                  |                                                             |                      |
| ~call lbracket;~  /# Compiled./           |                   |                  | {{{compile(5B,[)}}}                                         | Call [               |
| ~return.~                                 | RET               | C3               | ~C3~                                                        | return               |

**** .                                                             :noexport:

#+CAPTION: Subroutine ~'.'~ TODO.
#+LABEL: tbl:forth:dot
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                     | *Instruction*     | *Opcode*         | *Machine code*                          | *Intention*  |
| /# Define:/ _~.~_                | ---               | ---              | {{{define(01,2E)}}}                     | define .     |
| /# In/Out: ~( chr -​- )~/         |                   |                  |                                         |              |
| /#/                              |                   |                  |                                         |              |
| /# Non-standard name for ~C,~./  |                   |                  |                                         |              |
| /#/                              |                   |                  |                                         |              |
| /# Pop a byte off the stack and/ |                   |                  |                                         |              |
| /# write it to ~OUTPUT~./        |                   |                  |                                         |              |
|                                  |                   |                  |                                         |              |
| ~AL ← [R15]~                     | MOV r8, r/m8      | REX 8A /r        | ~41 8A~ {{{modrm(07,00,000,111)}}}      | al = [r15]   |
| ~R15 += 8;~                      | ADD r/m64, /imm8/ | REX.W 83 /​0 /ib/ | ~49 83~ {{{modrm(C7,11,000,111)}}} /08/ | r15 += 8     |
| ~[RDI++] ← AL;~                  | STOS m8           | AA               | ~AA~                                    | [rdi++] = al |
| ~return.~                        | RET               | C3               | ~C3~                                    | return       |

**** LIT                                                           :noexport:

#+CAPTION: Subroutine ~LIT~ compiles a literal byte into a word definition.
#+LABEL: tbl:forth:lit
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                                                | *Instruction*     | *Opcode*         | *Machine code*                          | *Intention*             |
|-------------------------------------------------------------+-------------------+------------------+-----------------------------------------+-------------------------|
| /# Define immediate:/ _~LIT~_                               | ---               | ---              | {{{define(83,4C 49 54)}}}               | define LIT              |
| /# In/Out: ~( C: x -​- ) ( -- x )~/                          |                   |                  |                                         |                         |
| /#/                                                         |                   |                  |                                         |                         |
| /# Pop a byte off the data stack at compile time/           |                   |                  |                                         |                         |
| /# Compile it as the immediate byte of a PUSH/              |                   |                  |                                         |                         |
| /# instruction that inserts it on the data stack/           |                   |                  |                                         |                         |
| /# when the word being defined is executed./                |                   |                  |                                         |                         |
|                                                             |                   |                  |                                         |                         |
| /# Let ~lit~ be the top byte on the data stack./            |                   |                  |                                         |                         |
| /# We will generate three instructions that will/           |                   |                  |                                         |                         |
| /# effectively push ~lit~ on the data stack at/             |                   |                  |                                         |                         |
| /# execution time:/                                         |                   |                  |                                         |                         |
| /# – a SUB instruction that allocates a slot on/            |                   |                  |                                         |                         |
| /# the data stack;/                                         |                   |                  |                                         |                         |
| /# – a pair of PUSH & POP instructions that copy/           |                   |                  |                                         |                         |
| /# ~lit~ to the newly allocated slot./                      |                   |                  |                                         |                         |
|                                                             |                   |                  |                                         |                         |
| /# 1. SUB instruction:/                                     |                   |                  |                                         |                         |
| /# – effect: ~R15 -= 8;~/                                   |                   |                  |                                         |                         |
| /# – instruction: SUB r/m64, imm8/                          |                   |                  |                                         |                         |
| /# – opcode: REX.W 83 /5 ib/                                |                   |                  |                                         |                         |
| /# – machine code: ~49 83~ {{{modrm(EF,11,101,111)}}} ~08~/ |                   |                  |                                         |                         |
| ~EAX ← 0x08EF8349;~                                         | MOV r32, /imm32/  | B8+rd /id/       | ~B8~ /49 83 EF 08/                      | eax = "r15 -= 8"        |
| ~[OUTPUT@RDI++4] ← EAX;~                                    | STOS m32          | AB               | ~AB~                                    | [rdi(++4)] = eax        |
|                                                             |                   |                  |                                         |                         |
| /# 2. PUSH instruction:/                                    |                   |                  |                                         |                         |
| /# – effect: ~push lit;~/                                   |                   |                  |                                         |                         |
| /# – instruction: PUSH imm8/                                |                   |                  |                                         |                         |
| /# – opcode: 6A ib/                                         |                   |                  |                                         |                         |
| /# – machine code: ~6A ??~ (imm. ignored for now)/          |                   |                  |                                         |                         |
| /# Here we only write 0x6A to ~OUTPUT~. Note that/          |                   |                  |                                         |                         |
| /# the three bytes of the next instruction are also/        |                   |                  |                                         |                         |
| /# loaded in EAX at this step, but not yet written./        |                   |                  |                                         |                         |
| ~EAX ← 0x078F416A;~                                         | MOV r32, /imm32/  | B8+rd /id/       | ~B8~ /6A 41 8F 07/                      | eax = push x; pop [r15] |
| ~[OUTPUT@RDI++] ← AL;~  /# Writes only 0x6A./               | STOS m8           | AA               | ~AA~                                    | [rdi++] = al            |
|                                                             |                   |                  |                                         |                         |
| /# 3. POP instruction:/                                     |                   |                  |                                         |                         |
| /# – effect: ~[R15] ← pop;~/                                |                   |                  |                                         |                         |
| /# – instruction: POP r/m64/                                |                   |                  |                                         |                         |
| /# – opcode: REX 8F /0/                                     |                   |                  |                                         |                         |
| /# – machine code: ~41 8F~ {{{modrm(07,00,000,111)}}}/      |                   |                  |                                         |                         |
| /# Here we write the immediate byte of the PUSH/            |                   |                  |                                         |                         |
| /# instruction (in AL) and the POP instruction/             |                   |                  |                                         |                         |
| /# (in the rest of EAX)./                                   |                   |                  |                                         |                         |
| ~AL ← [stack@R15];~                                         | MOV r8, r/m8      | REX 8A /r        | ~41 8A~ {{{modrm(07,00,000,111)}}}      | al = [r15]              |
| ~[OUTPUT@RDI++4] ← EAX;~                                    |                   |                  | ~AB~                                    | [rdi(++4)] = eax        |
|                                                             |                   |                  |                                         |                         |
| /# Pop ~lit~ off the data stack./                           |                   |                  |                                         |                         |
| ~stack@R15 += 8;~                                           | ADD r/m64, /imm8/ | REX.W 83 /​0 /ib/ | ~49 83~ {{{modrm(C7,11,000,111)}}} /08/ | r15 += 8                |
| ~return.~                                                   | RET               | C3               | ~C3~                                    | return                  |

**** xt=                                                           :noexport:

#+CAPTION: Subroutine ~xt=~ compares an execution token's name with a given string.
#+LABEL: tbl:forth:xt=
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                       | *Instruction*     | *Opcode*         | *&*            | *Machine code*                                     | *Intention*             |
|----------------------------------------------------+-------------------+------------------+----------------+----------------------------------------------------+-------------------------|
| /# Define:/ _~xt=~_                                | ---               | ---              |                | {{{define(03,78 74 3D)}}}                          | define xt=              |
| /# In/Out:    ~( addr@RBP u@RAX xt@RBX~/           |                   |                  |                |                                                    |                         |
| /# {{{c(6)}}}​~-​- xt@RBX FLAGS~/                    |                   |                  |                |                                                    |                         |
| /# {{{c(8)}}}   ~?@RAX ?@RDI )~/                   |                   |                  |                |                                                    |                         |
| /#/                                                |                   |                  |                |                                                    |                         |
| /# Checks if execution token ~xt~ is/              |                   |                  |                |                                                    |                         |
| /# either zero or is not hidden and/               |                   |                  |                |                                                    |                         |
| /# its name matches the string given/              |                   |                  |                |                                                    |                         |
| /# by address ~addr~ and length ~u~./              |                   |                  |                |                                                    |                         |
|                                                    |                   |                  |                |                                                    |                         |
| {{{c(2)}}} /# Return if ~xt~ is zero (~ZF~ set)./  |                   |                  |                |                                                    |                         |
| {{{c(2)}}} ~if xt@RBX & xt@RBX != 0:~              | TEST r/m64, r64   | REX.W 85 /r      |                | ~48 85~ {{{modrm(DB,11,011,011)}}}                 | rbx(xt) ?               |
| {{{c(4)}}}   ~goto _nonzero.~                      | JNZ _rel8_        | 75 _cb_          |                | ~75~ {{{offset(01,01-00)}}}                        | +jump _nonzero if != 0  |
| {{{c(2)}}} ~return.~                               | RET               | C3               | {{{addr(00)}}} | ~C3~                                               | return                  |
| ~_nonzero:~                                        |                   |                  | {{{addr(01)}}} |                                                    | _nonzero:               |
| {{{c(2)}}} /# Save ~u~ in RCX; to be used later./  |                   |                  |                |                                                    |                         |
| {{{c(2)}}} ~u@RCX ← u@RAX;~                        | MOV r64, r/m64    | REX.W 8B /r      |                | ~48 8B~ {{{modrm(C8,11,001,000)}}}                 | rcx = rax(u)            |
| {{{c(2)}}} /# Point RSI to the flag field./        |                   |                  |                |                                                    |                         |
| {{{c(2)}}} ~RSI ← xt@RBX + 0x10;~                  | LEA r64,m         | REX.W 8D /r      |                | ~48 8D~ {{{modrm(73,01,110,011)}}} {{{displ(10)}}} | rsi = rbx(xt) + 10      |
| {{{c(2)}}} /# Extract flag and advance RSI/        |                   |                  |                |                                                    |                         |
| {{{c(2)}}} /# to the name field (used later)./     |                   |                  |                |                                                    |                         |
| {{{c(2)}}} ~flag@AL ← [RSI++];~                    | LODS m8           | AC               |                | ~AC~                                               | al = [rsi++]            |
| {{{c(2)}}} /# Return if hidden word (~ZF~ unset)./ |                   |                  |                |                                                    |                         |
| {{{c(2)}}} ~if flag@AL & 0x40 = 0:~                | TEST AL, /imm8/   | A8 /ib/          |                | ~A8~ /~40~/                                        | al & 40(HIDDEN) ?       |
| {{{c(4)}}}   ~goto _unhidden.~                     | JZ _rel8_         | 74 _cb_          |                | ~74~ {{{offset(01,01-00)}}}                        | +jump _unhidden if == 0 |
| {{{c(2)}}} ~return.~                               | RET               | C3               | {{{addr(00)}}} | ~C3~                                               | return                  |
| ~_unhidden:~                                       |                   |                  | {{{addr(01)}}} |                                                    | _unhidden:              |
| {{{c(2)}}} /# Keep only name length in RAX./       |                   |                  |                |                                                    |                         |
| {{{c(2)}}} ~length@RAX ← flag@RAX & 0x1F;~         | AND r/m64, /imm8/ | REX.W 83 /​4 /ib/ |                | ~48 83~ {{{modrm(E0,11,100,000)}}} /~1F~/          | rax &= 1F(Length)       |
| {{{c(2)}}} /# Return if length doesn't match/      |                   |                  |                |                                                    |                         |
| {{{c(2)}}} /# (~ZF~ unset)./                       |                   |                  |                |                                                    |                         |
| {{{c(2)}}} ~if length@RAX = u@RCX:~                | CMP r/m64, r64    | REX.W 39 /r      |                | ~48 39~ {{{modrm(C8,11,001,000)}}}                 | cmp rax, rcx            |
| {{{c(4)}}}   ~goto _lengthEq.~                     | JE _rel8_         | 74 _cb_          |                | ~74~ {{{offset(01,01-00)}}}                        | +jump _lengthEq if ==   |
| {{{c(2)}}} ~return.~                               | RET               | C3               | {{{addr(00)}}} | ~C3~                                               | return                  |
| ~_lengthEq:~                                       |                   |                  | {{{addr(01)}}} |                                                    | _lengthEq:              |
| {{{c(2)}}} /# Compare ~addr~ and ~name@RSI~/       |                   |                  |                |                                                    |                         |
| {{{c(2)}}} /# upto length ~u~./                    |                   |                  |                |                                                    |                         |
| {{{c(2)}}} ~addr@RDI ← addr@RBP;~                  | MOV r64, r/m64    | REX.W 8B /r      |                | ~48 8B~ {{{modrm(FD,11,111,101)}}}                 | rdi = rbp               |
| {{{c(2)}}} ~strncmp(name@RSI,~                     |                   |                  |                |                                                    |                         |
| {{{c(10)}}}        ~addr@RDI,~                     |                   |                  |                |                                                    |                         |
| {{{c(10)}}}        ~u@RCX);~  /# (Un)sets ~ZF~./   | REPE CMPS m8, m8  | F3 A6            |                | ~F3 A6~                                            | strings equal ?         |
| {{{c(2)}}} ~return.~                               | RET               | C3               |                | ~C3~                                               | return                  |

**** FIND                                                          :noexport:

#+CAPTION: Subroutine ~FIND~ searches the dictionary for a word matching a given name.
#+LABEL: tbl:forth:find
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                               | *Instruction*  | *Opcode*    | *&*            | *Machine code*                                              | *Intention*      |
|--------------------------------------------+----------------+-------------+----------------+-------------------------------------------------------------+------------------|
| /# Define:/ _~FIND~_                       | ---            | ---         |                | {{{define(04,46 49 4E 44)}}}                                | define FIND      |
| /# In/Out:    ~( addr@RBP u@RAX~/          |                |             |                |                                                             |                  |
| /# {{{c(6)}}}​~-​- addr@RBP u@RAX~/          |                |             |                |                                                             |                  |
| /# {{{c(8)}}}   ~xt@RBX )~/                |                |             |                |                                                             |                  |
| /#/                                        |                |             |                |                                                             |                  |
| /# Search the dictionary for a/            |                |             |                |                                                             |                  |
| /# word with name matching/                |                |             |                |                                                             |                  |
| /# ~addr~​/​~u~. Return ~xt = 0~ if/         |                |             |                |                                                             |                  |
| /# no matching word is found./             |                |             |                |                                                             |                  |
|                                            |                |             |                |                                                             |                  |
| {{{c(2)}}} /# Begin search at ~LATEST~./   |                |             |                |                                                             |                  |
| {{{c(2)}}} ~xt@RBX ← [LATEST];~            | MOV r64, r/m64 | REX.W 8B /r |                | ~48 8B~ {{{modrm(1C,00,011,100)}}} {{{sib(25,00,100,101)}}} | rbx = [Latest]   |
|                                            |                |             |                | \hookrightarrow {{{c(2)}}} {{{displ(28 00 00 10)}}}         |                  |
| ~_beg:~                                    |                |             | {{{addr(00)}}} |                                                             | # _beg:          |
| {{{c(2)}}} ~call FIND();~                  | CALL _rel32_   | E8 _cd_     |                | ~E8~ {{{offset(03 00 00 00,05-02)}}}                        | +call (FIND)     |
| {{{c(2)}}} ~if !ZF:~                       |                |             | {{{addr(05)}}} |                                                             |                  |
| {{{c(4)}}}   ~goto _beg.~                  | JNE _rel8_     | 75 _cb_     |                | ~75~ {{{offset(F9,00-07)}}}                                 | -jump _beg if != |
| {{{c(2)}}} ~return.~                       | RET            | C3          | {{{addr(07)}}} | ~C3~                                                        | return           |
| ~FIND():~                                  |                |             | {{{addr(08)}}} |                                                             | (FIND):          |
| {{{c(2)}}} /# Save registers./             |                |             |                |                                                             |                  |
| {{{c(2)}}} ~push RAX;~                     | PUSH r64       | 50+rd       |                | ~50~                                                        | push rax         |
| {{{c(2)}}} ~push RDI;~                     | PUSH r64       | 50+rd       |                | ~57~                                                        | push rdi         |
| {{{c(2)}}} /# Does ~xt~ match ~addr~​/​~u~?/ |                |             |                |                                                             |                  |
| {{{c(2)}}} ~call xt=;~  /# Compiled./      | ---            | ---         |                | {{{compile(78,x)}}}                                         | Call xt=         |
| {{{c(2)}}} ~pop RDI;~                      | POP r64        | 58+rd       |                | ~5F~                                                        | pop rdi          |
| {{{c(2)}}} ~pop RAX;~                      | POP r64        | 58+rd       |                | ~58~                                                        | pop rax          |
| {{{c(2)}}} /# If matched, we're done!/     |                |             |                |                                                             |                  |
| {{{c(2)}}} /# Otherwise, follow ~xt~'s/    |                |             |                |                                                             |                  |
| {{{c(2)}}} /# link pointer./               |                |             |                |                                                             |                  |
| {{{c(2)}}} ~if ZF:~  /# Set by ~xt=()~./   | JE _rel8_      | 74 _cb_     |                | ~74~ {{{offset(04,04-00)}}}                                 | +jump _end if == |
| {{{c(4)}}}   ~goto _end.~                  |                |             | {{{addr(00)}}} |                                                             |                  |
| {{{c(2)}}} ~RBX ← [RBX+8];~                | MOV r64, r/m64 | REX.W 8B /r |                | ~48 8B~ {{{modrm(5B,01,011,011)}}} {{{displ(08)}}}          | rbx = [rbx+8]    |
| ~_end:~                                    |                |             | {{{addr(04)}}} |                                                             | # _end:          |
| {{{c(2)}}} ~return.~                       | RET            | C3          |                | ~C3~                                                        | return           |

**** Num                                                           :noexport:

#+CAPTION: Subroutine ~Num~ parses a character string as a number and returns it on the stack.
#+LABEL: tbl:forth:num
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                             | *Instruction*     | *Opcode*         | *&*            | *Machine code*                            | *Intention*        |
|------------------------------------------+-------------------+------------------+----------------+-------------------------------------------+--------------------|
| /# Define:/ _~Num~_                      | ---               | ---              |                | {{{define(03,4E 75 6D)}}}                 | define Num         |
| /# In/Out:    ~( addr@RBP u@RAX~/        |                   |                  |                |                                           |                    |
| /# {{{c(6)}}}​~-​- n )~/                   |                   |                  |                |                                           |                    |
| /#/                                      |                   |                  |                |                                           |                    |
| /# Parse string given by ~addr~​/​~u~/     |                   |                  |                |                                           |                    |
| /# as a number and return it on/         |                   |                  |                |                                           |                    |
| /# the data stack./                      |                   |                  |                |                                           |                    |
|                                          |                   |                  |                |                                           |                    |
| {{{c(2)}}} /# Allocate stack space for/  |                   |                  |                |                                           |                    |
| {{{c(2)}}} /# the parsed number./        |                   |                  |                |                                           |                    |
| {{{c(2)}}} ~stack@R15 -= 8;~             | SUB r/m64, /imm8/ | REX.W 83 /​5 /ib/ |                | ~49 83~ {{{modrm(EF,11,101,111)}}} /~08~/ | r15 -= 8           |
| {{{c(2)}}} ~[stack@R15] ← 0;~            | AND r/m64, /imm8/ | REX.W 83 /​4 /ib/ |                | ~49 83~ {{{modrm(27,00,100,111)}}} /~00~/ | [r15] = 0          |
| {{{c(2)}}} ~u@RCX ← u@RAX;~              | MOV r/m64, r64    | REX.W 89 /r      |                | ~48 89~ {{{modrm(C1,11,000,001)}}}        | rcx = rax          |
| {{{c(2)}}} ~addr@RSI ← addr@RBP;~        | MOV r64, r/m64    | REX.W 8B /r      |                | ~48 8B~ {{{modrm(F5,11,110,101)}}}        | rsi = rbp          |
| ~_beg:~                                  |                   |                  | {{{addr(00)}}} |                                           | # _beg:            |
| {{{c(2)}}} /# Parse one digit./          |                   |                  |                |                                           |                    |
| {{{c(2)}}} ~call Num();~                 | CALL _rel32_      | E8 _cd_          |                | ~E8~ {{{offset(03 00 00 00,08-05)}}}      | +call (Num)        |
| {{{c(2)}}} /# Repeat while there are/    |                   |                  |                |                                           |                    |
| {{{c(2)}}} /# unparsed characters left./ |                   |                  |                |                                           |                    |
| {{{c(2)}}} ~if --u@RCX != 0:~            |                   |                  | {{{addr(05)}}} |                                           |                    |
| {{{c(4)}}}   ~goto _beg.~                | LOOP _rel8_       | E2 _cb_          |                | ~E2~ {{{offset(F9,00-07)}}}               | -jump beg if --rcx |
| {{{c(2)}}} ~return.~                     | RET               | C3               | {{{addr(07)}}} | ~C3~                                      | return             |
| ~Num():~                                 |                   |                  | {{{addr(08)}}} |                                           | (Num)              |
| {{{c(2)}}} ~chr@AL ← [addr@RSI++];~      | LODS m8           | AC               |                | ~AC~                                      | al = [rsi++]       |
| {{{c(2)}}} ~if chr@AL < 'A':~            | CMP AL, /imm8/    | 3C /ib/          |                | ~3C~ /~41~/                               | cmp al, 'A'        |
| {{{c(4)}}}   /# It's a digit./           |                   |                  |                |                                           |                    |
| {{{c(4)}}}   ~goto _digit.~              | JL _rel8_         | 7C _cb_          |                | ~7C~ {{{offset(02,02-00)}}}               | +jump _digit if <  |
| {{{c(2)}}} /# It's a letter./            |                   |                  | {{{addr(00)}}} |                                           | # _letter:         |
| {{{c(2)}}} ~chr@AL -= 7;~                | SUB AL, /imm8/    | 2C /ib/          |                | ~2C~ /~07~/                               | al -= 7            |
| ~_digit:~                                |                   |                  | {{{addr(02)}}} |                                           | # _digit:          |
| {{{c(2)}}} ~digit@AL = chr@AL - '0';~    | SUB AL, /imm8/    | 2C /ib/          |                | ~2C~ /~30~/                               | al -= 30           |
| {{{c(2)}}} /# Multiply by base and add/  |                   |                  |                |                                           |                    |
| {{{c(2)}}} /# the new digit./            |                   |                  |                |                                           |                    |
| {{{c(2)}}} ~[stack@R15] <<= 4~;          | SAL r/m64, /imm8/ | REX.W C1 /​4 /ib/ |                | ~49 C1~ {{{modrm(27,00,100,111)}}} /~04~/ | [r15] <<= 4        |
| {{{c(2)}}} ~[stack@R15]~ \vert​~= digit@RAX;~ | OR r/m64, r64     | REX.W 09 /r      |                | ~49 09~ {{{modrm(07,00,000,111)}}}        | [r15] \vert= rax       |
| {{{c(2)}}} ~return.~                     | RET               | C3               |                | ~C3~                                      | return             |

**** miss                                                          :noexport:

#+CAPTION: Subroutine ~miss~ attempts parsing a word as a number, optionally compiling it as a literal.
#+LABEL: tbl:forth:miss
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                           | *Instruction*     | *Opcode*    | *&*            | *Machine code*                                           | *Intention*           |
|----------------------------------------+-------------------+-------------+----------------+----------------------------------------------------------+-----------------------|
| /# Define:/ _~miss~_                   | ---               | ---         |                | {{{define(04,6D 69 73 73)}}}                             | define miss           |
| /# In/Out:     ~( addr@RBP u@RAX~/     |                   |             |                |                                                          |                       |
| /#{{{c(9)}}}    ~xt@RXB~/              |                   |             |                |                                                          |                       |
| /#{{{c(6)}}}​~-​- [n] xt@RXB )~/         |                   |             |                |                                                          |                       |
| /#/                                    |                   |             |                |                                                          |                       |
| /# If ~xt~ is zero, try parsing/       |                   |             |                |                                                          |                       |
| /# the string given by ~addr~​/​~u~/     |                   |             |                |                                                          |                       |
| /# as a number. If successful/         |                   |             |                |                                                          |                       |
| /# and if we're in compiling/          |                   |             |                |                                                          |                       |
| /# state, compile the number/          |                   |             |                |                                                          |                       |
| /# as a literal./                      |                   |             |                |                                                          |                       |
|                                        |                   |             |                |                                                          |                       |
| {{{c(2)}}} ~if xt@RBX = 0:~            | TEST r/m64, r64   | REX.W 85 /r |                | ~48 85~ {{{modrm(DB,11,011,011)}}}                       | rbx(xt) ?             |
| {{{c(4)}}}   ~goto miss().~            | JZ _rel8_         | 74 _cb_     |                | ~74~ {{{offset(01,01-00)}}}                              | +jump (miss) if == 0  |
| {{{c(2)}}} ~return.~                   | RET               | C3          | {{{addr(00)}}} | ~C3~                                                     | return                |
| ~miss():~                              |                   |             | {{{addr(01)}}} |                                                          | (miss)                |
| {{{c(2)}}} /# We shouldn't call ~Num~/ |                   |             |                |                                                          |                       |
| {{{c(2)}}} /# with ~u~ equal to zero./ |                   |             |                |                                                          |                       |
| {{{c(2)}}} ~if u@RAX != 0:~            | TEST r/m64, r64   | REX.W 85 /r |                | ~48 85~ {{{modrm(C0,11,000,000)}}}                       | rax(u) ?              |
| {{{c(4)}}}   ~goto _nonempty.~         | JNE _rel8_        | 75 _cb_     |                | ~75~ {{{offset(01,01-00)}}}                              | +jump _nonempty if != |
| {{{c(2)}}} ~return.~                   | RET               | C3          | {{{addr(00)}}} | ~C3~                                                     | return                |
| ~_nonempty:~                           |                   |             | {{{addr(01)}}} |                                                          | # _nonempty:          |
| {{{c(2)}}} ~call Num;~  /# Compiled./  |                   |             |                | {{{compile(4E,N)}}}                                      | Call Num              |
| {{{c(2)}}} ~if [STATE] & 1 != 0:~      | TEST r/m8, /imm8/ | F6 /​0 /ib/  |                | ~F6~ {{{modrm(04,00,000,100)}}} {{{sib(25,00,000,100)}}} | [STATE] ?             |
| {{{c(4)}}}   /# Compile top of stack/  |                   |             |                | \hookrightarrow {{{displ(20 00 00 10)}}} /~01~/          |                       |
| {{{c(4)}}}   /# number as literal./    |                   |             |                |                                                          |                       |
| {{{c(4)}}}   ~goto _lit.~              | JNZ _rel8_        | 75 _cb_     |                | ~75~ {{{offset(01,01-00)}}}                              | +jump _lit if != 0    |
| {{{c(2)}}} ~return.~                   | RET               | C3          | {{{addr(00)}}} | ~C3~                                                     | return                |
| ~_lit:~                                |                   |             | {{{addr(01)}}} |                                                          | # _lit:               |
| {{{c(2)}}} ~call LIT;~  /# Compiled./  |                   |             |                | {{{compile(4C,L)}}}                                      | Call LIT              |
| {{{c(2)}}} ~return.~                   | RET               | C3          |                | ~C3~                                                     | return                |

**** EXEC                                                          :noexport:

#+CAPTION: Subroutine ~EXEC~ ???.
#+LABEL: tbl:forth:EXEC
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                    | *Instruction*    | *Opcode*   | *Machine code*                  | *Intention*  |
|---------------------------------+------------------+------------+---------------------------------+--------------|
| /# Define:/ _~EXEC~_            | ---              | ---        | {{{define(04,45 58 45 43)}}}    | define EXEC  |
| /# In/Out: ~( xt@RXB -- )~/     |                  |            |                                 |              |
| /#/                             |                  |            |                                 |              |
| /# ???/                         |                  |            |                                 |              |
| /# ???/                         |                  |            |                                 |              |
|                                 |                  |            |                                 |              |
| ~RCX ← 0x7FFFFFF8~  /# ???/     | MOV r32, /imm32/ | B8+rd /id/ | ~B9~ /~F8 FF FF 7F~/            | rcx = _      |
| ~push RDI;~  /# Save./          | PUSH r64         | 50+rd      | ~57~                            | push rdi     |
| ~RDI ← RCX;~                    | MOV r/m32, r32   | 89 /r      | ~89~ {{{modrm(CF,11,001,111)}}} | rdi = rcx    |
|                                 |                  |            |                                 |              |
| /# Compile a CALL to ~xt~./     |                  |            |                                 |              |
| ~call COMPL;~  /# Compiled./    |                  |            | {{{compile(43,C)}}}             | Call COMPL   |
|                                 |                  |            |                                 |              |
| /# Compile a RET instruction./  |                  |            |                                 |              |
| ~AL ← 0xC3;~                    | MOV r8, /imm8/   | B0+rb /ib/ | ~B0~ /~C3~/                     | al = C3      |
| ~[RDI++] ← AL;~                 | STOS m8          | AA         | ~AA~                            | [rdi++] = al |
|                                 |                  |            |                                 |              |
| ~pop RDI;~  /# Restore./        | POP r64          | 58+rd      | ~5F~                            | pop rdi      |
|                                 |                  |            |                                 |              |
| /# Transfer control to the/     |                  |            |                                 |              |
| /# newly created instructions./ |                  |            |                                 |              |
| ~call [RCX];~                   | CALL r/m64       | FF /2      | ~FF~ {{{modrm(D1,11,010,001)}}} | call rcx     |
| ~return.~                       | RET              | C3         | ~C3~                            | return       |

**** exec

#+CAPTION: Subroutine ~exec~ executes a word if interpreting or if it's immediate.
#+LABEL: tbl:forth:exec
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                    | *Instruction*  | *Opcode* | *&*            | *Machine code*               | *Intention*        |
|-------------------------------------------------+----------------+----------+----------------+------------------------------+--------------------|
| /# Define:/ _~exec~_                            | ---            | ---      |                | {{{define(04,65 78 65 63)}}} | define exec        |
| /# In/Out: ~( imm+state@AL xt@RBX -- )~/        |                |          |                |                              |                    |
| /#/                                             |                |          |                |                              |                    |
| /# Execute ~xt~ if we're in interpreting state/ |                |          |                |                              |                    |
| /# or if it's immediate. In other words,/       |                |          |                |                              |                    |
| /# don't execute if we're both compiling/       |                |          |                |                              |                    |
| /# and the word is not immediate./              |                |          |                |                              |                    |
|                                                 |                |          |                |                              |                    |
| {{{c(2)}}} ~if imm+state@AL != 1:~              | CMP AL, /imm8/ | 3C /ib/  |                | ~3C~ /~01~/                  | cmp al, 1          |
| {{{c(4)}}}   ~goto exec().~                     | JNE _rel8_     | 75 _cb_  |                | ~75~ {{{offset(01,01-00)}}}  | +jump (exec) if != |
| {{{c(2)}}} ~return.~                            | RET            | C3       | {{{addr(00)}}} | ~C3~                         | return             |
| ~exec():~                                       |                |          | {{{addr(01)}}} |                              | (exec)             |
| {{{c(2)}}} ~call EXEC;~  /# Compiled./          |                |          |                | {{{compile(45,E)}}}          | Call EXEC          |
| {{{c(2)}}} ~return.~                            | RET            | C3       |                | ~C3~                         | return             |

**** compl

#+CAPTION: Subroutine ~compl~ compiles a word in compiling state if it's not immediate.
#+LABEL: tbl:forth:compl
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                | *Instruction*  | *Opcode*   | *&*            | *Machine code*                  | *Intention*         |
|---------------------------------------------+----------------+------------+----------------+---------------------------------+---------------------|
| /# Define:/ _~compl~_                       | ---            | ---        |                | {{{define(05,63 6F 6D 70 6C)}}} | define compl        |
| /# In/Out:    ~( imm+state@AL xt@RBX~/      |                |            |                |                                 |                     |
| /# {{{c(5)}}} ~-- imm+state@AL xt@RBX )~/   |                |            |                |                                 |                     |
| /#/                                         |                |            |                |                                 |                     |
| /# Compile ~xt~ in the current definition/  |                |            |                |                                 |                     |
| /# if we're in compiling state and ~xt~ is/ |                |            |                |                                 |                     |
| /# not immediate./                          |                |            |                |                                 |                     |
|                                             |                |            |                |                                 |                     |
| {{{c(2)}}} ~if imm+state@AL = 1:~           | CMP AL, /imm8/ | 3C /ib/    |                | ~3C~ /~01~/                     | cmp al, 1           |
| {{{c(4)}}}   ~goto compl().~                | JE _rel8_      | 74 _cb_    |                | ~74~ {{{offset(01,01-00)}}}     | +jump (compl) if == |
| {{{c(2)}}} ~return.~                        | RET            | C3         | {{{addr(00)}}} | ~C3~                            | return              |
| ~compl():~                                  |                |            | {{{addr(01)}}} |                                 | (compl)             |
| {{{c(2)}}} ~call COMPL;~  /# Compiled./     |                |            |                | {{{compile(43)}}}               | Call COMPL          |
| {{{c(2)}}} /# Restore AL after ~COMPL~./    |                |            |                |                                 |                     |
| {{{c(2)}}} ~imm+state@AL ← 1;~              | MOV r8, /imm8/ | B0+rb /ib/ |                | ~B0~ /~01~/                     | al = 1              |
| {{{c(2)}}} ~return.~                        | RET            | C3         |                | ~C3~                            | return              |

**** hit

#+CAPTION: Subroutine ~hit~ ???.
#+LABEL: tbl:forth:hit
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                      | *Instruction*   | *Opcode*    | *&*            | *Machine code*                                           | *Intention*         |
|---------------------------------------------------+-----------------+-------------+----------------+----------------------------------------------------------+---------------------|
| /# Define:/ _~hit~_                               | ---             | ---         |                | {{{define(03,68 69 74)}}}                                | define hit          |
| /# In/Out: ~( xt@RBX -- )~/                       |                 |             |                |                                                          |                     |
| /#/                                               |                 |             |                |                                                          |                     |
| /# ???/                                           |                 |             |                |                                                          |                     |
| /# ???/                                           |                 |             |                |                                                          |                     |
|                                                   |                 |             |                |                                                          |                     |
| {{{c(2)}}} ~if xt@RBX != 0:~                      | TEST r/m64, r64 | REX.W 85 /r |                | ~48 85~ {{{modrm(DB,11,011,011)}}}                       | rbx(xt) ?           |
| {{{c(4)}}}   ~goto hit().~                        | JNZ _rel8_      | 75 _cb_     |                | ~75~ {{{offset(01,01-00)}}}                              | +jump (hit) if != 0 |
| {{{c(2)}}} ~return.~                              | RET             | C3          | {{{addr(00)}}} | ~C3~                                                     | return              |
| ~hit():~                                          |                 |             | {{{addr(01)}}} |                                                          | (hit)               |
| {{{c(2)}}} /# Combine word's immediate/           |                 |             |                |                                                          |                     |
| {{{c(2)}}} /# flag with current state./           |                 |             |                |                                                          |                     |
| {{{c(2)}}} ~flag@AL ← [xt@RBX+10];~               | MOV r8, r/m8    | REX 8A /r   |                | ~40 8A~ {{{modrm(43,01,000,011)}}} {{{displ(10)}}}       | al = [rbx+10]       |
| {{{c(2)}}} ~imm@AL &= 0x80;~                      | AND AL, /imm8/  | 24 /ib/     |                | ~24~ /~80~/                                              | al &= 80(IMMEDIATE) |
| {{{c(2)}}} ~imm+state@AL~ \vert​~=~ ~[STATE];~         | OR r8, r/m8     | 0A /r       |                | ~0A~ {{{modrm(04,00,000,100)}}} {{{sib(25,00,100,101)}}} | al \vert= [STATE]       |
|                                                   |                 |             |                | \hookrightarrow {{{i(0)}}} {{{displ(20 00 00 10)}}}      |                     |
| {{{c(2)}}} ~call compl;~  {{{c(0)}}}​/# Compiled./ |                 |             |                | {{{compile(63,c)}}}                                      | Call compl          |
| {{{c(2)}}} ~call exec;~   {{{c(1)}}}​/# Compiled./ |                 |             |                | {{{compile(65,e)}}}                                      | Call exec           |
| {{{c(2)}}} ~return.~                              | RET             | C3          |                | ~C3~                                                     | return              |

**** SVAL

#+CAPTION: Subroutine ~SVAL~ ???.
#+LABEL: tbl:forth:SVAL
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                      | *Instruction*  | *Opcode*    | *&*            | *Machine code*                                              | *Intention*     |
|---------------------------------------------------+----------------+-------------+----------------+-------------------------------------------------------------+-----------------|
| /# Define:/ _~SVAL~_                              | ---            | ---         |                | {{{define(04,53 56 41 4C)}}}                                | define SVAL     |
| /# In/Out: ~( i*x -- j*x )~/                      |                |             |                |                                                             |                 |
| /#/                                               |                |             |                |                                                             |                 |
| /# ???/                                           |                |             |                |                                                             |                 |
| /# ???/                                           |                |             |                |                                                             |                 |
|                                                   |                |             |                |                                                             |                 |
| ~_SVAL:~                                          |                |             | {{{addr(00)}}} |                                                             |                 |
| {{{c(2)}}} ~call SVAL();~                         | CALL _rel32_   | E8 _cd_     |                | ~E8~ {{{offset(03 00 00 00,08-05)}}}                        | +call (SVAL)    |
| {{{c(2)}}} ~if ???:~                              |                |             | {{{addr(05)}}} |                                                             |                 |
| {{{c(4)}}}   ~goto _SVAL.~                        | JL _rel8_      | 7C _cb_     |                | ~7C~ {{{offset(F9,00-07)}}}                                 | -jump SVAL if < |
| {{{c(2)}}} ~return.~                              | RET            | C3          | {{{addr(07)}}} | ~C3~                                                        | return          |
| ~SVAL():~                                         |                |             | {{{addr(08)}}} |                                                             | (SVAL)          |
| {{{c(2)}}} ~call pname;~  {{{c(0)}}}​/# Compiled./ |                |             |                | {{{compile(70,p)}}}                                         | Call pname      |
| {{{c(2)}}} ~call FIND;~   {{{c(1)}}}​/# Compiled./ |                |             |                | {{{compile(46,F)}}}                                         | Call FIND       |
| {{{c(2)}}} ~call miss;~   {{{c(1)}}}​/# Compiled./ |                |             |                | {{{compile(6D,m)}}}                                         | Call miss       |
| {{{c(2)}}} ~call hit;~    {{{c(2)}}}​/# Compiled./ |                |             |                | {{{compile(68,h)}}}                                         | Call hit        |
| {{{c(2)}}} ~RAX ← [>IN];~                         | MOV r64, r/m64 | REX.W 8B /r |                | ~48 8B~ {{{modrm(04,00,000,100)}}} {{{sib(25,00,100,101)}}} | rax = [>IN]     |
|                                                   |                |             |                | \hookrightarrow {{{i(0)}}} {{{displ(10 00 00 10)}}}         |                 |
| {{{c(2)}}} ~???~                                  | CMP r64, r/m64 | REX.W 3B /r |                | ~48 3B~ {{{modrm(04,00,000,100)}}} {{{sib(25,00,100,101)}}} | cmp rax, [#IN]  |
|                                                   |                |             |                | \hookrightarrow {{{i(0)}}} {{{displ(00 00 00 10)}}}         |                 |
| {{{c(2)}}} ~return.~                              | RET            | C3          |                | ~C3~                                                        | return          |

**** ti

#+CAPTION: Subroutine ~ti~ ???.
#+LABEL: tbl:forth:ti
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                       | *Instruction*      | *Opcode*         | *&*            | *Machine code*                                     | *Intention*           |
|----------------------------------------------------+--------------------+------------------+----------------+----------------------------------------------------+-----------------------|
| /# Define:/ _~ti~_                                 | ---                | ---              |                | {{{define(02,74 69)}}}                             | define ti             |
| /# In/Out: ~( -- )~/                               |                    |                  |                |                                                    |                       |
| /#/                                                |                    |                  |                |                                                    |                       |
| /# text interpreter ???/                           |                    |                  |                |                                                    |                       |
| /# ???/                                            |                    |                  |                |                                                    |                       |
|                                                    |                    |                  |                |                                                    |                       |
| {{{c(2)}}} ~stack@R15 ← 0x10000000;~               | MOV r/m64, /imm32/ | REX.W C7 /​0 /id/ |                | ~49 C7~ {{{modrm(C7,11,000,111)}}} /~00 00 00 10~/ | r15(stack) = 10000000 |
| {{{c(2)}}} ~[TIB] ← INPUT@RSI;~                    | MOV r/m64, r64     | REX.W 89 /r      |                | ~49 89~ {{{modrm(77,01,110,111)}}} {{{displ(08)}}} | [TIB] = rsi           |
| {{{c(2)}}} ~call [;~  /# Compiled./                |                    |                  |                | {{{compile(5B,[)}}}                                | Call [                |
| ~_beg:~                                            |                    |                  | {{{addr(00)}}} |                                                    | # _beg:               |
| {{{c(2)}}} ~call ti();~                            | CALL _rel32_       | E8 _cd_          |                | ~E8~ {{{offset(02 00 00 00,07-05)}}}               | +call (ti)            |
| {{{c(2)}}} ~goto _beg.~                            | JMP _rel8_         | EB _cb_          | {{{addr(05)}}} | ~EB~ {{{offset(F9,00-07)}}}                        | -jump _beg            |
| ~ti():~                                            |                    |                  | {{{addr(07)}}} |                                                    | (ti)                  |
| {{{c(2)}}} ~call REFILL;~  {{{c(0)}}}​/# Compiled./ |                    |                  |                | {{{compile(52,R)}}}                                | Call REFILL           |
| {{{c(2)}}} ~call SVAL;~    {{{c(2)}}}​/# Compiled./ |                    |                  |                | {{{compile(53,S)}}}                                | Call SVAL             |
| {{{c(2)}}} ~return.~                               | RET                | C3               |                | ~C3~                                               | return                |


* Footnotes

[fn:2] We reset the address counter since no jumps occur from the code
below this point to the code above or vice versa. This has the
advantage of keeping the counter value contained to one byte. We will
use an overlined {{{addr(00)}}} when we do this again.

[fn:1] SmithForth misses the opcode here.


* Bibliography

#+PRINT_BIBLIOGRAPHY:


* Notes                                                            :noexport:

*** TODOs
- [X] Convert all *&* columns to use the ~addr~ macro.
- [X] Find places where it makes sense to restart address counts.
- [X] Convert all /N/A/​s to ~---~.
- [X] Check all returns/gotos end with ~.~ and all calls with ~;~.
- [X] Check that compiled calls don't end in ~()~.
- [ ] Properly align /In/Out/ sections.
- [ ] Add a ~rex~ macro to annotate the REX byte?
- [ ] Align ~\hookrightarrow~ properly.
- [ ] If supported, make all subroutine table labels case-sensitive.
- [ ] Check there's no ~???~ or ~TODO~ left.
  
*** Sections that I should include in the thesis
- Legend explaining the typographic conventions.
  - Do it by column for the code tables.
- Call graph of the subroutines to show how they are related.
- Comparison between SmithForth, sectorforth, milliForth, other (?).
  
*** Useful Sections in the Intel Manual

Volume 2:
- 2.1 INSTRUCTION FORMAT FOR PROTECTED MODE, REAL-ADDRESS MODE, AND
  VIRTUAL-8086 MODE
- 2.2 IA-32E MODE
  - 2.2.1 REX Prefixes
- 3.1.1.1 Opcode Column in the Instruction Summary Table (Instructions without VEX Prefix)
- 3.1.1.3 Instruction Column in the Opcode Summary Table
- B.1 MACHINE INSTRUCTION FORMAT
  - B.1.4.2 Reg Field (reg) for 64-Bit Mode
  - B.1.4.7 Condition Test (tttn) Field
  - B.2.1 General Purpose Instruction Formats and Encodings for 64-Bit
    Mode

*** Maybe consider porting to RISC-V?
The Wikipedia [[https://en.wikipedia.org/wiki/RISC-V][article]] states that "RISC-V encourages academic usage"
and that "the simplicity of the integer subset permits basic student
exercises". This is probably the ideal ISA to target after
=x86-64=. All work done for x86 could be relegated to an appendix so
that it's not wasted.

*** RISC-V Forth implementations
- https://github.com/jjyr/jonesforth_riscv
- https://github.com/theandrew168/derzforth
- https://github.com/mcmenaminadrian/riscyforth

