#+TITLE: From Assembly Forth to Lisp (and Back)
#+SUBTITLE: A Journey through the Imperative, Concatenative and Functional Realms
#+DATE: September 2024
#+AUTHOR: Andrei Dorian Duma
#+EMAIL: andrei-dorian.duma@s.unibuc.ro
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 29.2 (Org mode 9.6.15)

#+BIBLIOGRAPHY: references.bib
#+CITE_EXPORT:

#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:{} arch:headline
#+OPTIONS: author:nil broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:nil todo:t |:t

#+STARTUP: logdrawer

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,8pt]
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:
#+LATEX_ENGRAVED_THEME:
#+LATEX_COMPILER: pdflatex

# --- Nice author line ---
#+LATEX_HEADER: \usepackage{authblk}
#+LATEX_HEADER: \author[1]{Andrei Dorian Duma\thanks{andrei-dorian.duma@s.unibuc.ro}}
#+LATEX_HEADER: \affil[1]{Master of Distributed Systems}

# --- Allow hiding table columns in the LaTeX export
#+LATEX_HEADER: \usepackage{array}
#+LATEX_HEADER: \newcolumntype{H}{>{\setbox0=\hbox\bgroup}c<{\egroup}@{}}

# --- Indentation helper macros.
#+MACRO: t   \hspace{1em}
#+MACRO: i   (eval (format "\\hspace{%sem}" $1))
#+MACRO: c   (eval (format "\\hspace{%fem}" (* 0.5265 (string-to-number $1))))

# --- ModR/M and SIB helper macros.
#+MACRO: modrm   $^{\text{\tiny ModR/M}}_{\text{\tiny $1·$2·$3}}$
#+MACRO:   sib   $^{\text{\tiny    SIB}}_{\text{\tiny $1·$2·$3}}$
#+MACRO: displ   $_{\text{\tiny $1}}_$

# Additional options are set in `.dir-locals.el`.


# Don't show abstract for now.
# #+begin_abstract
# In this thesis we explore the process of implementing a high-level
# programming language, beginning with only a limited set of
# foundational elements: the =x86_64= architecture, several simple Linux
# system calls, the GNU Assembler and the shell. We are interested in
# how the level of abstraction is progressively increased by defining
# higher-level linguistic constructs in terms of more primitive
# ones. The approach will be pedagogical, favoring implementation
# choices that are clear and understandable.

# Our final goal is implementing a usable high-level language in the
# LISP family, which we will call /quectoLISP/ (following the tradition
# of prefixing names of small languages with SI submultiples). We
# accomplish this in three stages. First, we write (in assembly) a
# threaded interpreter for /quectoFORTH/, a small language inheriting
# from Chuck Moore's Forth. Then, using this interpreter, we implement a
# simple /quectoLISP/ interpreter providing the most useful language
# features. Finally, we write a /quectoLISP/ compiler in /quectoLISP/
# itself, running it in the stage-two interpreter. This compiler emits
# =x86_64= assembly and becomes self-hosted, being able to compile
# itself.
# #+end_abstract
# \clearpage

# Don't show TOC for now.
# #+TOC: headlines 2
# \clearpage


* Introduction :noexport:

** Our Objectives

#+begin_comment
What are the objectives of this thesis?
- Learn low-level processor programming, interpreter & compiler
  design.
- Understand how high-level languages are translated all the way to
  machine code; understand all intermediate steps.
- Find a short(est) path to high-level programming from nothing but
  machine code and Linux system calls.
#+end_comment

** An Incremental Approach

#+begin_comment
Why this approach?
- Reference inspiration paper: "An incremental approach to compiler
  construction".
#+end_comment


* Stage 1: A Forth Interpreter in Machine Code

** The =x86-64= Architecture :noexport:

#+CAPTION: Instruction prefixes.
#+LABEL: tbl:instruction-prefixes
| Prefix                | Hex |
|-----------------------+-----|
| REPNE/REPNZ           | F2  |
| REP, REPE/REPZ        | F3  |
| Operand-size override | 66  |
| Address-size override | 67  |

#+CAPTION: Useful =x86-64= instructions.
#+LABEL: tbl:instructions
| Mnemonic | Opcode (hex) |
|----------+--------------|
| CALL     | =E8=         |
|          | =FF=         |


** The Linux Environment :noexport:

*** Linux System Calls

#+CAPTION: Calling convention for Linux system calls under =x86-64=.
#+LABEL: tbl:syscall-calling-convention
|------------+---------------------------------------------------------------------|
| *Register* | *Usage*                                                             |
|------------+---------------------------------------------------------------------|
| RAX        | Syscall number (the identifier of the system call being requested). |
|------------+---------------------------------------------------------------------|
| RDI        | First argument to the syscall.                                      |
| RSI        | Second argument to the syscall.                                     |
| RDX        | Third argument to the syscall.                                      |
| R10        | Fourth argument to the syscall.                                     |
| R8         | Fifth argument to the syscall.                                      |
| R9         | Sixth argument to the syscall.                                      |
|------------+---------------------------------------------------------------------|

#+CAPTION: Linux system calls used in this Forth implementation.
#+LABEL: tbl:syscalls
| *Syscall* | *Name* | *RAX*  | *RDI*               | *RSI*             | *RDX*          |
|-----------+--------+--------+---------------------+-------------------+----------------|
|         0 | read   | =0x00= | =unsigned int fd=   | =char *buf=       | =size_t count= |
|         1 | write  | =0x01= | =unsigned int fd=   | =const char *buf= | =size_t count= |
|        12 | brk    | =0x0C= | =unsigned long brk= | –                 | –              |
|        60 | exit   | =0x3C= | =int error_code=    | –                 | –              |


*** ELF: The _E_​xecutable _F_​ile _F_​ormat

#+CAPTION: ELF file header for an =x86-64= Linux executable.
#+LABEL: tbl:elf-file-header
|---------------------------+----------------------------------------------------------------------------------|
| ~7F 45 4C 46 ·· ·· ·· ··~ | ~e_ident[EI_MAG]~: ELF magic number.                                             |
| ~·· ·· ·· ·· 02 ·· ·· ··~ | ~e_ident[EI_CLASS]~: =1= → 32-bit, _=2= → 64-bit_.                               |
| ~·· ·· ·· ·· ·· 01 ·· ··~ | ~e_ident[EI_DATA]~: _=1= → little-endian_, =2= → big-endian.                     |
| ~·· ·· ·· ·· ·· ·· 01 ··~ | ~e_ident[EI_VERSION]~: ELF header version; must be =1=.                          |
| ~·· ·· ·· ·· ·· ·· ·· 00~ | ~e_ident[EI_OSABI]~: Target OS ABI; =ELFOSABI_NONE= (=0=) is fine for Linux.     |
|---------------------------+----------------------------------------------------------------------------------|
| ~00 ·· ·· ·· ·· ·· ·· ··~ | ~e_ident[EI_ABIVERSION]~: ABI version; should be =0= for Linux.                  |
| ~·· 00 00 00 00 00 00 00~ | ~e_ident[EI_PAD]~: Padding; unused; should be =0=.                               |
|---------------------------+----------------------------------------------------------------------------------|
| ~02 00 ·· ·· ·· ·· ·· ··~ | ~e_type~: Object file type; =2= → executable.                                    |
| ~·· ·· 3E 00 ·· ·· ·· ··~ | ~e_machine~: Instruction set architecture; =0x03= → =x86=, _=0x3E= → =x86-64=_.  |
| ~·· ·· ·· ·· 01 00 00 00~ | ~e_version~: ELF identification version; must be =1=.                            |
|---------------------------+----------------------------------------------------------------------------------|
| ~78 00 40 00 00 00 00 00~ | ~e_entry~: Memory address of entry point (where process starts).                 |
| ~40 00 00 00 00 00 00 00~ | ~e_phoff~: File offset of program headers; =0x34= → =32-bit=, _=0x40= → 64-bit_. |
| ~00 00 00 00 00 00 00 00~ | ~e_shoff~: File offset section headers.                                          |
|---------------------------+----------------------------------------------------------------------------------|
| ~00 00 00 00 ·· ·· ·· ··~ | ~e_flags~: 0 for the =x86-64= architecture.                                      |
| ~·· ·· ·· ·· 40 00 ·· ··~ | ~e_ehsize~: Size of this header; =0x34= → 32-bit, _=0x40= → 64-bit_.             |
| ~·· ·· ·· ·· ·· ·· 38 00~ | ~e_phentsize~: Size of each program header; =0x20= → 32-bit, _=0x38= → 64-bit_.  |
|---------------------------+----------------------------------------------------------------------------------|
| ~01 00 ·· ·· ·· ·· ·· ··~ | ~e_phnum~: Number of program headers; here =1=.                                  |
| ~·· ·· 40 00 ·· ·· ·· ··~ | ~e_shentsize~: Size of each section header; =0x28= → 32-bit, _=0x40= → 64-bit_.  |
| ~·· ·· ·· ·· 00 00 ·· ··~ | ~e_shnum~: Number of section headers; here =0=.                                  |
| ~·· ·· ·· ·· ·· ·· 00 00~ | ~e_shstrndx~: Index of section header containing section names; doesn't apply.   |
|---------------------------+----------------------------------------------------------------------------------|

#+CAPTION: ELF program header.
#+LABEL: tbl:elf-program-header
|---------------------------+------------------------------------------------------------------------------|
| ~01 00 00 00 ·· ·· ·· ··~ | ~p_type~: Segment type; =1= → loadable.                                      |
| ~·· ·· ·· ·· 07 00 00 00~ | ~p_flags~: Segment-wise permissions; _1 → execute_, _2 → write_, _4 → read_. |
| ~00 00 00 00 00 00 00 00~ | ~p_offset~: Offset of segment in file; we load the whole file, so =0=.       |
| ~00 00 40 00 00 00 00 00~ | ~p_vaddr~: Virtual address of segment in memory; =0x400000= on =x86-64=.     |
| ~00 00 00 00 00 00 00 00~ | ~p_paddr~: Only used on systems where physical address is relevant.          |
| ~02 1E 01 00 00 00 00 00~ | ~p_filesz~: Size of the segment in the file image (=TODO=).                  |
| ~00 00 C0 7F 00 00 00 00~ | ~p_memsz~: Size of the segment in memory (>= =p_filesz=).                    |
| ~00 10 00 00 00 00 00 00~ | ~p_align~: Align segment to =x86-64= page size (4096 or =0x1000=).           |
|---------------------------+------------------------------------------------------------------------------|


** Implementing FORTH
:LOGBOOK:
- Note taken on [2024-07-27 Sat 13:49] \\
  Maybe collect all global variables in one place?
:END:

*** Done :noexport:
#+CAPTION: Global variables =INPUT= and =OUTPUT=.
#+LABEL: tbl:input-output
#+ATTR_LATEX: :align l|ll|l|l
| *Pseudocode*                           | *Instruction*    | *Opcode*   | *&*  | *Machine code*     |
|--------------------------------------+----------------+----------+----+------------------|
| {{{i(0)}}} /# Global variable INPUT./  |                |          |    |                  |
| {{{i(0)}}} ~INPUT@RSI ← 0x004000B2;~   | MOV r32, imm32 | B8+rd id | ~78~ | ~BE~ /~B2 00 40 00~/ |
| {{{i(0)}}} /# Global variable OUTPUT./ |                |          |    |                  |
| {{{i(0)}}} ~OUTPUT@RDI ← 0x10000030;~  | MOV r32, imm32 | B8+rd id | ~7D~ | ~BF~ /~30 00 00 10~/ |
|                                      |                |          | ~82~ |                  |

#+CAPTION: The binary interpreter routine and loop.
#+LABEL: tbl:binary-interpreter
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                  | *Instruction*  | *Opcode*    | *&*  | *Machine code*                         | *Intention*             |
|-----------------------------------------------+----------------+-------------+------+----------------------------------------+-------------------------|
| ~_bi:~                                        |                |             | ~82~ |                                        |                         |
| {{{i(1)}}} /# Loop the binary interpreter./   |                |             |      |                                        |                         |
| {{{i(1)}}} ~call bi().~                       | CALL rel32     | E8 cb[fn:1] |      | ~E8~ _~02 00 00 00~_​{{{displ(89-87)}}} | call (bi)               |
| {{{i(1)}}} ~goto _bi.~                        | JMP rel8       | EB cb       | ~87~ | ~EB~ _~F9~_​{{{displ(82-89)}}}          | jump bi                 |
| ~bi():~                                       |                |             | ~89~ |                                        |                         |
| {{{i(1)}}} /# Get next byte from input./      |                |             |      |                                        |                         |
| {{{i(1)}}} ~chr@AL ← [input@RSI++];~          | LODS m8        | AC          |      | ~AC~                                   | al = [rsi++]            |
| {{{i(1)}}} /# Does it start a command?/       |                |             |      |                                        |                         |
| {{{i(1)}}} ~if chr@AL = 0x99:~                | CMP AL, imm8   | 3C ib       |      | ~3C~ /~99~/                            | cmp al, 99(command)     |
| {{{i(2)}}}     ~goto _command.~               | JE rel8        | 74 cb       |      | ~74~ _~02~_​{{{displ(90-8E)}}}          | jump _command if ==     |
| {{{i(1)}}} ~[output@RDI++] <- chr@AL;~        | STOS m8        | AA          | ~8E~ | ~AA~                                   | [rdi++] = al (xmit)     |
| {{{i(1)}}} ~return.~                          | RET            | C3          |      | ~C3~                                   | return                  |
| ~_command:~                                   |                |             | ~90~ |                                        |                         |
| {{{i(1)}}} /# Global variable LATEST./        |                |             |      |                                        |                         |
| {{{i(1)}}} ~LATEST@RDX ← 0x10000028;~         | MOV r32, imm32 | B8+rd id    |      | ~BA~ /~28 00 00 10~/                   | rdx = Latest            |
| {{{i(1)}}} /# Parse command argument./        |                |             |      |                                        |                         |
| {{{i(1)}}} ~arg@AL ← [intput@RSI++];~         | LODSB[fn:2]    | AC          |      | ~AC~                                   | al = [rsi++] (argument) |
| {{{i(1)}}} ~if arg & x11xxxxx = 0:~           | TEST AL, imm8  | A8 ib       |      | ~A8~ /~60~/                            | al & 60(graphic)?       |
| {{{i(1)}}}     ~goto Head.~                   | JZ rel8        | 74 cb       |      | ~74~ _~31~_​{{{displ(CB-9A)}}}          | jump Head if zero       |
| {{{i(1)}}} /# Latest dictionary entry./       |                |             | ~9A~ |                                        |                         |
| {{{i(1)}}} ~entry@RBX ← *LATEST;~             | MOV r64, r/m64 | REX.W 8B /r |      | ~48 8B 1A~​{{{modrm(00,011,010)}}}      | rbx = [rdx]             |
| ~_find1:~                                     |                |             | ~9D~ |                                        |                         |
| {{{i(1)}}} ~save arg@AL on the stack;~        | PUSH r64       | 50+rd       |      | ~50~                                   | push al                 |
| {{{i(1)}}} ~arg &= 0111111;~                  | AND AL, imm8   | 24 ib       |      | ~24 7F~                                | al &= 7F                |
| {{{i(1)}}} ~if arg = [entry + 11]:~           | CMP r8, r/m8   | REX 3A /r   |      | ~3A 43 11~​{{{modrm(00,010,001)}}}      | cmp al, [rbx+11]        |
| {{{i(2)}}}     /# If arg = first char in/     |                |             |      |                                        |                         |
| {{{i(2)}}}     /# entry's name./              |                |             |      |                                        |                         |
| {{{i(2)}}}     ~restore arg@AL;~              | POP r64        | 58+rd       |      | ~58~                                   | pop al                  |
| {{{i(2)}}}     ~goto _match.~                 | JE rel8        | 74 cb       |      | ~74~ ~06~​{{{displ(AC-A6)}}}            | jump _match if ==       |
| {{{i(1)}}} /# Follow entry's link pointer./   |                |             | ~A6~ |                                        |                         |
| {{{i(1)}}} ~entry ← [entry + 8];~             | MOV r64, r/m64 | REX.W 8B /r |      | ~48 8B 5B~​{{{modrm(01,011,011)}}} ~08~ | rbx = [rbx+8]           |
| {{{i(1)}}} /# Loop; try to match previous/    |                |             |      |                                        |                         |
| {{{i(1)}}} /# dictionary entry./              |                |             |      |                                        |                         |
| {{{i(1)}}} ~goto _find1.~                     | JMP rel8       | EB cb       |      | ~EB~ _~F1~_​{{{displ(9D-AC)}}}          | jump _find1             |
| ~_match:~                                     |                |             | ~AC~ |                                        |                         |
| {{{i(1)}}} ~if arg & 1xxxxxx = 0:~            | TEST AL, imm8  | A8 ib       |      | ~A8~ /~80~/                            | al & 80(exec) ?         |
| {{{i(2)}}}     /# Compile./                   |                |             |      |                                        |                         |
| {{{i(2)}}}     ~goto COMPL.~                  | JZ rel8        | 74 cb       |      | ~74~ _~09~_​{{{displ(B9-B0)}}}          | jump COMPL if zero      |
| {{{i(1)}}} /# Execute: jump to entry's code./ |                |             | ~B0~ |                                        |                         |
| {{{i(1)}}} ~goto _entry.~                     | JMP r/m64      | REX FF /4   |      | ~FF 23~​{{{modrm(00,100,011)}}}         | jump [rbx] (exec)       |
|                                               |                |             | ~B2~ |                                        |                         |

*** Interpreter Subroutines :noexport:

#+CAPTION: =COMPL=, The FORTH compiler.
#+LABEL: tbl:binary-interpreter
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                                                        | *Instruction*   | *Opcode*   | *&*  | *Machine code*           | *Intention*                                          |
|-----------------------------------------------------------------------------------+---------------+----------+----+------------------------+----------------------------------------------------|
| /# Compile subroutine _COMPL_/.                                                     | /N/A/           | /N/A/      | ~B2~ | ~99 05~ _~43 4F 4D 50 4C~_ | COMPL Forth's COMPILE, B9 ( ebx=xt -- )            |
|                                                                                   |               |          |    |                        |                                                    |
| /# Generate a CALL instruction to output:/                                          |               |          |    |                        |                                                    |
| /# – instruction: CALL r/m64/                                                       |               |          |    |                        |                                                    |
| /# – opcode: FF /2/                                                                  |               |          |    |                        |                                                    |
| /#/                                                                                 |               |          |    |                        |                                                    |
| /# Thus we generate machine code as follows:/                                       |               |          |    |                        |                                                    |
| /#/ {{{i(1)}}} ~FF 14~​{{{modrm(00,010,100)}}} ~25~​{{{sib(00,100,101)}}} _~??~ ~??~ ~??~ ~??~_ |               |          |    |                        |                                                    |
|                                                                                   |               |          |    |                        |                                                    |
| /# 1. Write opcode of CALL (0x99)./                                                 |               |          |    |                        |                                                    |
| ~op@AL ← 0xFF;~                                                                     | MOV r8, imm8  | B0+rb ib | ~B9~ | ~B0~ /FF/                  | compile: call r/m64 (FF /2, 00 010 100, 00 100 101 |
| ~[output@RDI++] ← op@AL;~                                                           | STOS m8       | AA       |    | ~AA~                     |                                                    |
| /# 2. Write ModR/M byte (0x14)./                                                    |               |          |    |                        |                                                    |
| ~modrm@AL ← 0x14;~                                                                  | MOV r8, imm8  | B0+rb ib |    | ~B0~ /14/                  | al = _                                             |
| ~[output@RDI++] ← op@AL;~                                                           | STOS m8       | AA       |    | ~AA~                     |                                                    |
| /# 3. Write SIB byte (0x25)./                                                       |               |          |    |                        |                                                    |
| ~sib@AL ← 0x25;~                                                                    | MOV r8, imm8  | B0+rb ib |    | ~B0~ /25/                  | [rdi++] = al                                       |
| ~[output@RDI++] ← op@AL;~                                                           | STOS m8       | AA       |    | ~AA~                     |                                                    |
| /# 4. Write 4-byte code address./                                                   |               |          |    |                        |                                                    |
| ~code@EAX ← entry@EBX;~                                                             | XCHG EAX, r32 | 90+rd    |    | ~93~                     | eax = ebx                                          |
| ~[output@RDI++4] ← op@EAX;~                                                         | STOS m32      | AB       |    | ~AB~                     | [rdi(++4)] = eax                                   |
|                                                                                   |               |          |    |                        |                                                    |
| ~return.~  /# From binary interpreter./                                               | RET           | C3       |    | ~C3~                     | return                                             |
|                                                                                   |               |          | ~C5~ |                        |                                                    |

*** WIP

#+CAPTION: Subroutine =Head= creates dictionary entries.
#+LABEL: tbl:head-subroutine
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                             | *Instruction*   | *Opcode*       | *&*  | *Machine code*                         | *Intention*   |
|------------------------------------------+-----------------+----------------+------+----------------------------------------+---------------|
| /# Compile:/ _~Head~_                    | /N/A/           | /N/A/          | ~C5~ | ~99~ $^{c}$​~04~ _~48 65 61 64~_        | Head          |
| /# In/Out:/ ~( flag@AL -​- )~             |                 |                |      |                                        |               |
|                                          |                 |                |      |                                        |               |
| /# 16-bit align OUTPUT./                 |                 |                |      |                                        |               |
| ~OUTPUT@RDI += 0x0F;~                    | ADD r/m64, imm8 | REX.W 83 /0 ib | ~CB~ | ~48 83 C7~​{{{modrm(11,000,111)}}} ~0F~ | rdi += 0F     |
| ~OUTPUT@RDI &= 0xF0;~                    | AND r/m64, imm8 | REX.W 83 /4 ib |      | ~48 83 E7~​{{{modrm(11,100,111)}}} ~F0~ | rdi &= F0     |
|                                          |                 |                |      |                                        |               |
| /# Fill the new dictionary entry:/       |                 |                |      |                                        |               |
|                                          |                 |                |      |                                        |               |
| /# 1. Set the _link field_, then set/    |                 |                |      |                                        |               |
| /#{{{c(3)}}}LATEST to the new entry./    |                 |                |      |                                        |               |
| ~latest@RCX ← [LATEST@RDX];~             | MOV r64, r/m64  | REX.W 8B /r    |      | ~48 8B 0A~​{{{modrm(00,001,010)}}}      | rcx = [rdx]   |
| ~[OUTPUT@RDI+8] ← latest@RCX;~           | MOV r/m64, r64  | REX.W 89 /r    |      | ~48 89 4F~​{{{modrm(01,001,111)}}} ~08~ | [rdi+8] = rcx |
| ~[LATEST@RDX] ← OUTPUT@RDI;~             | MOV r/m64, r64  | REX.W 89 /r    |      | ~48 89 3A~​{{{modrm(00,111,010)}}}      | [rdx] = rdi   |
|                                          |                 |                |      |                                        |               |
| /# 2. Set the _flag+length field_./      |                 |                |      |                                        |               |
| ~OUTPUT@RDI += 0x10;~                    | ADD r/m64, imm8 | REX.W 83 /0 ib |      | ~48 83 C7~​{{{modrm(11,000,111)}}} ~10~ | rdi += 10     |
| ~[OUTPUT@RDI++] ← flag@AL;~              | STOS m8         | AA             |      | ~AA~                                   | [rdi++] = al  |
|                                          |                 |                |      |                                        |               |
| /# 3. Extract name length from flag/     |                 |                |      |                                        |               |
| /#{{{c(3)}}}and copy _name field_./      |                 |                |      |                                        |               |
| ~flag@ECX ← flag@AL;~                    | XCHG EAX, r32   | 90+rd          |      | ~91~                                   | ecx = eax     |
| ~length@ECX ← flag@ECX & 0x1F;~          | AND r/m32, imm8 | 83 /4 ib       |      | ~83 E1~​{{{modrm(11,100,001)}}} ~1F~    | ecx &= 1F     |
| ~copy      length@ECX bytes~             |                 |                |      |                                        |               |
| {{{c(5)}}}​~from INPUT@RSI~               |                 |                |      |                                        |               |
| {{{c(5)}}}​~to OUTPUT@RDI;~               | REP MOVS m8, m8 | F3 A4          |      | ~F3 A4~                                | copy Name     |
|                                          |                 |                |      |                                        |               |
| /# 4. Point _code field_ to the machine/ |                 |                |      |                                        |               |
| /#{{{c(3)}}}code that follows at INPUT./ |                 |                |      |                                        |               |
| ~code@RCX ← [LATEST@RDX];~               | MOV r64, r/m64  | REX.W 8B /r    |      | ~48 8B 0A~​{{{modrm(00,001,010)}}}      | rcx = [rdx]   |
| ~[code@RCX] ← INPUT@RDI;~                | MOV r/m64, r64  | REX.W 89 /r    |      | ~48 89 39~​{{{modrm(00,111,001)}}}      | [rcx] = rdi   |
| ~return;~  /# From binary interpreter./  | RET             | C3             |      | ~C3~                                   | return        |
|                                          |                 |                | ~EF~ |                                        |               |


* Notes

*** Useful Sections in the Intel Manual
Volume 2:
- 2.1 INSTRUCTION FORMAT FOR PROTECTED MODE, REAL-ADDRESS MODE, AND
  VIRTUAL-8086 MODE
- 2.2 IA-32E MODE
  - 2.2.1 REX Prefixes
- 3.1.1.1 Opcode Column in the Instruction Summary Table (Instructions without VEX Prefix)
- 3.1.1.3 Instruction Column in the Opcode Summary Table
- B.1 MACHINE INSTRUCTION FORMAT
  - B.1.4.2 Reg Field (reg) for 64-Bit Mode
  - B.1.4.7 Condition Test (tttn) Field
  - B.2.1 General Purpose Instruction Formats and Encodings for 64-Bit
    Mode

*** Maybe consider porting to RISC-V?
The Wikipedia [[https://en.wikipedia.org/wiki/RISC-V][article]] states that "RISC-V encourages academic usage"
and that "the simplicity of the integer subset permits basic student
exercises". This is probably the ideal ISA to target after
=x86-64=. All work done for x86 could be relegated to an appendix so
that it's not wasted.

* Footnotes

[fn:1] SmithForth misses the opcode here.

[fn:2] SmithForth uses instruction =LODS m8= with same opcode. We
prefer the less confusing =LODSB=.
