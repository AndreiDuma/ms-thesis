#+TITLE: From Assembly Forth to Lisp (and Back)
#+SUBTITLE: A Journey through the Imperative, Concatenative and Functional Realms
#+DATE: September 2024
#+AUTHOR: Andrei Dorian Duma
#+EMAIL: andrei-dorian.duma@s.unibuc.ro
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 29.2 (Org mode 9.6.15)

#+BIBLIOGRAPHY: references.bib
#+CITE_EXPORT:

#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:{} arch:headline
#+OPTIONS: author:nil broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:nil todo:t |:t

#+STARTUP: logdrawer

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,8pt]
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:
#+LATEX_ENGRAVED_THEME:
#+LATEX_COMPILER: pdflatex

# --- Nice author line ---
#+LATEX_HEADER: \usepackage{authblk}
#+LATEX_HEADER: \author[1]{Andrei Dorian Duma\thanks{andrei-dorian.duma@s.unibuc.ro}}
#+LATEX_HEADER: \affil[1]{Master of Distributed Systems}

# --- Allow hiding table columns in the LaTeX export
#+LATEX_HEADER: \usepackage{array}
#+LATEX_HEADER: \newcolumntype{H}{>{\setbox0=\hbox\bgroup}c<{\egroup}@{}}

#+LATEX_HEADER: \usepackage{unicode-math}

# --- Indentation helper macros.
#+MACRO: t   \hspace{1em}  # TODO: rewrite this one to use {{{c(x)}}}.
#+MACRO: i   (eval (format "\\hspace{%sem}" $1))
#+MACRO: c   (eval (format "\\hspace{%fem}" (* 0.5265 (string-to-number $1))))

# --- Byte annotation macros.
#+MACRO: modrm   ~$1~​$^{\text{\tiny ModR/M}}_{\text{\tiny $2·$3·$4}}$
#+MACRO:   sib   ~$1~​$^{\text{\tiny    SIB}}_{\text{\tiny $1·$2·$3}}$
#+MACRO: offset  _~$1~_​$_{\text{\tiny $2}}$
#+MACRO: displ   $^{\text{\tiny +}}$​_~$1~_
#+MACRO: define  ~[99~ $^{d}$​~$1~ _~$2~_​~]~
#+MACRO: compile ~[99~ $^{c}$​~$1~​$_{$2}$​~]~
#+MACRO: execute ~[99~ $^{e}$​~$1~​$_{$2}$​~]~

# -- Other annotation macros.
#+MACRO: unsigned $^{u}$

# Additional options are set in `.dir-locals.el`.


# Don't show abstract for now.
# #+begin_abstract
# In this thesis we explore the process of implementing a high-level
# programming language, beginning with only a limited set of
# foundational elements: the =x86_64= architecture, several simple Linux
# system calls, the GNU Assembler and the shell. We are interested in
# how the level of abstraction is progressively increased by defining
# higher-level linguistic constructs in terms of more primitive
# ones. The approach will be pedagogical, favoring implementation
# choices that are clear and understandable.

# Our final goal is implementing a usable high-level language in the
# LISP family, which we will call /quectoLISP/ (following the tradition
# of prefixing names of small languages with SI submultiples). We
# accomplish this in three stages. First, we write (in assembly) a
# threaded interpreter for /quectoFORTH/, a small language inheriting
# from Chuck Moore's Forth. Then, using this interpreter, we implement a
# simple /quectoLISP/ interpreter providing the most useful language
# features. Finally, we write a /quectoLISP/ compiler in /quectoLISP/
# itself, running it in the stage-two interpreter. This compiler emits
# =x86_64= assembly and becomes self-hosted, being able to compile
# itself.
# #+end_abstract
# \clearpage

# Don't show TOC for now.
# #+TOC: headlines 2
# \clearpage


* Introduction                                                     :noexport:

** Our Objectives

#+begin_comment
What are the objectives of this thesis?
- Learn low-level processor programming, interpreter & compiler
  design.
- Understand how high-level languages are translated all the way to
  machine code; understand all intermediate steps.
- Find a short(est) path to high-level programming from nothing but
  machine code and Linux system calls.
#+end_comment


** An Incremental Approach

#+begin_comment
Why this approach?
- Reference inspiration paper: "An incremental approach to compiler
  construction".
#+end_comment


* Stage 1: A Forth Interpreter in Machine Code

** The =x86-64= Architecture                                       :noexport:

#+CAPTION: Instruction prefixes.
#+LABEL: tbl:instruction-prefixes
| Prefix                | Hex |
|-----------------------+-----|
| REPNE/REPNZ           | F2  |
| REP, REPE/REPZ        | F3  |
| Operand-size override | 66  |
| Address-size override | 67  |

#+CAPTION: Useful =x86-64= instructions.
#+LABEL: tbl:instructions
| Mnemonic | Opcode (hex) |
|----------+--------------|
| CALL     | =E8=         |
|          | =FF=         |


** The Linux Environment                                           :noexport:

*** Linux System Calls

#+CAPTION: Calling convention for Linux system calls under =x86-64=.
#+LABEL: tbl:syscall-calling-convention
|------------+---------------------------------------------------------------------|
| *Register* | *Usage*                                                             |
|------------+---------------------------------------------------------------------|
| RAX        | Syscall number (the identifier of the system call being requested). |
|------------+---------------------------------------------------------------------|
| RDI        | First argument to the syscall.                                      |
| RSI        | Second argument to the syscall.                                     |
| RDX        | Third argument to the syscall.                                      |
| R10        | Fourth argument to the syscall.                                     |
| R8         | Fifth argument to the syscall.                                      |
| R9         | Sixth argument to the syscall.                                      |
|------------+---------------------------------------------------------------------|

#+CAPTION: Linux system calls used in this Forth implementation.
#+LABEL: tbl:syscalls
| *Syscall* | *Name* | *RAX*  | *RDI*               | *RSI*             | *RDX*          |
|-----------+--------+--------+---------------------+-------------------+----------------|
|         0 | read   | =0x00= | =unsigned int fd=   | =char *buf=       | =size_t count= |
|         1 | write  | =0x01= | =unsigned int fd=   | =const char *buf= | =size_t count= |
|        12 | brk    | =0x0C= | =unsigned long brk= | –                 | –              |
|        60 | exit   | =0x3C= | =int error_code=    | –                 | –              |


*** ELF: The _E_​xecutable _F_​ile _F_​ormat

**** ELF File Header

#+CAPTION: ELF file header for an =x86-64= Linux executable.
#+LABEL: tbl:elf-file-header
|---------------------------+----------------------------------------------------------------------------------|
| ~7F 45 4C 46 ·· ·· ·· ··~ | ~e_ident[EI_MAG]~: ELF magic number.                                             |
| ~·· ·· ·· ·· 02 ·· ·· ··~ | ~e_ident[EI_CLASS]~: =1= → 32-bit, _=2= → 64-bit_.                               |
| ~·· ·· ·· ·· ·· 01 ·· ··~ | ~e_ident[EI_DATA]~: _=1= → little-endian_, =2= → big-endian.                     |
| ~·· ·· ·· ·· ·· ·· 01 ··~ | ~e_ident[EI_VERSION]~: ELF header version; must be =1=.                          |
| ~·· ·· ·· ·· ·· ·· ·· 00~ | ~e_ident[EI_OSABI]~: Target OS ABI; =ELFOSABI_NONE= (=0=) is fine for Linux.     |
|---------------------------+----------------------------------------------------------------------------------|
| ~00 ·· ·· ·· ·· ·· ·· ··~ | ~e_ident[EI_ABIVERSION]~: ABI version; should be =0= for Linux.                  |
| ~·· 00 00 00 00 00 00 00~ | ~e_ident[EI_PAD]~: Padding; unused; should be =0=.                               |
|---------------------------+----------------------------------------------------------------------------------|
| ~02 00 ·· ·· ·· ·· ·· ··~ | ~e_type~: Object file type; =2= → executable.                                    |
| ~·· ·· 3E 00 ·· ·· ·· ··~ | ~e_machine~: Instruction set architecture; =0x03= → =x86=, _=0x3E= → =x86-64=_.  |
| ~·· ·· ·· ·· 01 00 00 00~ | ~e_version~: ELF identification version; must be =1=.                            |
|---------------------------+----------------------------------------------------------------------------------|
| ~78 00 40 00 00 00 00 00~ | ~e_entry~: Memory address of entry point (where process starts).                 |
| ~40 00 00 00 00 00 00 00~ | ~e_phoff~: File offset of program headers; =0x34= → =32-bit=, _=0x40= → 64-bit_. |
| ~00 00 00 00 00 00 00 00~ | ~e_shoff~: File offset section headers.                                          |
|---------------------------+----------------------------------------------------------------------------------|
| ~00 00 00 00 ·· ·· ·· ··~ | ~e_flags~: 0 for the =x86-64= architecture.                                      |
| ~·· ·· ·· ·· 40 00 ·· ··~ | ~e_ehsize~: Size of this header; =0x34= → 32-bit, _=0x40= → 64-bit_.             |
| ~·· ·· ·· ·· ·· ·· 38 00~ | ~e_phentsize~: Size of each program header; =0x20= → 32-bit, _=0x38= → 64-bit_.  |
|---------------------------+----------------------------------------------------------------------------------|
| ~01 00 ·· ·· ·· ·· ·· ··~ | ~e_phnum~: Number of program headers; here =1=.                                  |
| ~·· ·· 40 00 ·· ·· ·· ··~ | ~e_shentsize~: Size of each section header; =0x28= → 32-bit, _=0x40= → 64-bit_.  |
| ~·· ·· ·· ·· 00 00 ·· ··~ | ~e_shnum~: Number of section headers; here =0=.                                  |
| ~·· ·· ·· ·· ·· ·· 00 00~ | ~e_shstrndx~: Index of section header containing section names; doesn't apply.   |
|---------------------------+----------------------------------------------------------------------------------|

**** ELF Program Header

#+CAPTION: ELF program header.
#+LABEL: tbl:elf-program-header
|---------------------------+------------------------------------------------------------------------------|
| ~01 00 00 00 ·· ·· ·· ··~ | ~p_type~: Segment type; =1= → loadable.                                      |
| ~·· ·· ·· ·· 07 00 00 00~ | ~p_flags~: Segment-wise permissions; _1 → execute_, _2 → write_, _4 → read_. |
| ~00 00 00 00 00 00 00 00~ | ~p_offset~: Offset of segment in file; we load the whole file, so =0=.       |
| ~00 00 40 00 00 00 00 00~ | ~p_vaddr~: Virtual address of segment in memory; =0x400000= on =x86-64=.     |
| ~00 00 00 00 00 00 00 00~ | ~p_paddr~: Only used on systems where physical address is relevant.          |
| ~02 1E 01 00 00 00 00 00~ | ~p_filesz~: Size of the segment in the file image (=TODO=).                  |
| ~00 00 C0 7F 00 00 00 00~ | ~p_memsz~: Size of the segment in memory (>= =p_filesz=).                    |
| ~00 10 00 00 00 00 00 00~ | ~p_align~: Align segment to =x86-64= page size (4096 or =0x1000=).           |
|---------------------------+------------------------------------------------------------------------------|


** Implementing FORTH

:LOGBOOK:
- Note taken on [2024-07-27 Sat 13:49] \\
  Maybe collect all global variables in one place?
- Note taken on [2024-07-29 Mon 10:23] \\
  Maybe rename ~Head~ to ~DEFN~ (to resemble ~COMPL~)?
:END:

*** Global variables

| *Variable* | *Register*​/​*Address*   | *Contents*                                                    |
|------------+------------------------+---------------------------------------------------------------|
| ~INPUT~    | ~RSI~                  | Source address of binary interpreter data and commands.       |
| ~OUTPUT~   | ~RDI~                  | Destination address of binary interpreter operations.         |
| ~#IN~      | ~0x10000000 (VARS)~    | The number of characters in the current line.                 |
| ~TIB~      | ~0x10000008 (VARS+8)~  | The address where the current line begins.                    |
| ~>IN~      | ~0x10000010 (VARS+16)~ | The number of /parsed/ characters in the current line.        |
| ~STATE~    | ~0x10000020 (VARS+32)~ | Either ~0~ (/interpreting/ state) or ~1~ (/compiling/ state). |
| ~LATEST~   | ~0x10000028 (VARS+40)~ | The execution token (/xt/) of the latest defined Forth word.  |


#+CAPTION: Global variables =INPUT= and =OUTPUT=.
#+LABEL: tbl:forth:globals
#+ATTR_LATEX: :align l|ll|l|l
| *Pseudocode*                  | *Instruction*  | *Opcode* | *&*  | *Machine code*       |
|-------------------------------+----------------+----------+------+----------------------|
| /# Global variable ~INPUT~./  |                |          |      |                      |
| ~INPUT@RSI ← 0x004000B2;~     | MOV r32, imm32 | B8+rd id | ~78~ | ~BE~ /~B2 00 40 00~/ |
| /# Global variable ~OUTPUT~./ |                |          |      |                      |
| ~OUTPUT@RDI ← 0x10000030;~    | MOV r32, imm32 | B8+rd id | ~7D~ | ~BF~ /~30 00 00 10~/ |
|                               |                |          | ~82~ |                      |


*** Binary interpreter                                             :noexport:

#+CAPTION: The binary interpreter routine and loop.
#+LABEL: tbl:forth:bi
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                  | *Instruction*  | *Opcode*    | *&*  | *Machine code*                          | *Intention*             |
|-----------------------------------------------+----------------+-------------+------+-----------------------------------------+-------------------------|
| ~_bi:~                                        |                |             | ~82~ |                                         |                         |
| {{{i(1)}}} /# Loop the binary interpreter./   |                |             |      |                                         |                         |
| {{{i(1)}}} ~call bi().~                       | CALL rel32     | E8 cb[fn:1] |      | ~E8~ {{{offset(02 00 00 00,89-87)}}}    | call bi()               |
| {{{i(1)}}} ~goto _bi.~                        | JMP rel8       | EB cb       | ~87~ | ~EB~ {{{offset(F9,82-89)}}}             | jump _bi                |
| ~bi():~                                       |                |             | ~89~ |                                         |                         |
| {{{i(1)}}} /# Read next byte from ~INPUT~./   |                |             |      |                                         |                         |
| {{{i(1)}}} ~chr@AL ← [INPUT@RSI++];~          | LODS m8        | AC          |      | ~AC~                                    | al = [rsi++]            |
| {{{i(1)}}} /# Does it start a command?/       |                |             |      |                                         |                         |
| {{{i(1)}}} ~if chr@AL = 0x99:~                | CMP AL, imm8   | 3C ib       |      | ~3C~ /~99~/                             | cmp al, 99(command)     |
| {{{i(2)}}}     ~goto _command.~               | JE rel8        | 74 cb       |      | ~74~ {{{offset(02,90-8E)}}}             | jump _command if ==     |
| {{{i(1)}}} /# If not, just copy the byte/     |                |             |      |                                         |                         |
| {{{i(1)}}} /# to ~OUTPUT~ and return./        |                |             |      |                                         |                         |
| {{{i(1)}}} ~[OUTPUT@RDI++] <- chr@AL;~        | STOS m8        | AA          | ~8E~ | ~AA~                                    | [rdi++] = al (xmit)     |
| {{{i(1)}}} ~return.~                          | RET            | C3          |      | ~C3~                                    | return                  |
| ~_command:~                                   |                |             | ~90~ |                                         |                         |
| {{{i(1)}}} /# Global variable ~LATEST~./      |                |             |      |                                         |                         |
| {{{i(1)}}} ~LATEST@RDX ← 0x10000028;~         | MOV r32, imm32 | B8+rd id    |      | ~BA~ /~28 00 00 10~/                    | rdx = Latest            |
| {{{i(1)}}} /# Read command argument./         |                |             |      |                                         |                         |
| {{{i(1)}}} ~arg@AL ← [INPUT@RSI++];~          | LODS m8        | AC          |      | ~AC~                                    | al = [rsi++] (argument) |
| {{{i(1)}}} /# Command type by argument:/      |                |             |      |                                         |                         |
| {{{i(1)}}} /# – ~0bx00xxxxx~: define;/        |                |             |      |                                         |                         |
| {{{i(1)}}} /# – ~0b011xxxxx~: compile;/       |                |             |      |                                         |                         |
| {{{i(1)}}} /# – ~0b111xxxxx~: execute./       |                |             |      |                                         |                         |
| {{{i(1)}}} ~if arg & 0b01100000 = 0:~         | TEST AL, imm8  | A8 ib       |      | ~A8~ /~60~/                             | al & 60(graphic)?       |
| {{{i(2)}}}     /# Define a new word./         |                |             |      |                                         |                         |
| {{{i(2)}}}     ~goto Head.~                   | JZ rel8        | 74 cb       |      | ~74~ {{{offset(31,CB-9A)}}}             | jump Head if zero       |
| {{{i(1)}}} /# Get latest dictionary entry./   |                |             | ~9A~ |                                         |                         |
| {{{i(1)}}} ~entry@RBX ← *LATEST;~             | MOV r64, r/m64 | REX.W 8B /r |      | ~48 8B~ {{{modrm(1A,00,011,010)}}}      | rbx = [rdx]             |
| ~_find1:~                                     |                |             | ~9D~ |                                         |                         |
| {{{i(1)}}} ~save arg@AL on the stack;~        | PUSH r64       | 50+rd       |      | ~50~                                    | push al                 |
| {{{i(1)}}} ~chr@AL &= 0b0111111;~             | AND AL, imm8   | 24 ib       |      | ~24 7F~                                 | al &= 7F                |
| {{{i(1)}}} ~if char@AL = [entry + 11]:~       | CMP r8, r/m8   | REX 3A /r   |      | ~3A 43~ {{{modrm(11,00,010,001)}}}      | cmp al, [rbx+11]        |
| {{{i(2)}}}     /# We found an entry whose/    |                |             |      |                                         |                         |
| {{{i(2)}}}     /# name begins with ~chr~./    |                |             |      |                                         |                         |
| {{{i(2)}}}     ~restore arg@AL;~              | POP r64        | 58+rd       |      | ~58~                                    | pop al                  |
| {{{i(2)}}}     ~goto _match.~                 | JE rel8        | 74 cb       |      | ~74~ {{{offset(06,AC-A6)}}}             | jump _match if ==       |
| {{{i(1)}}} /# Follow entry's link pointer/    |                |             | ~A6~ |                                         |                         |
| {{{i(1)}}} /# to previous entry and repeat./  |                |             |      |                                         |                         |
| {{{i(1)}}} ~entry ← [entry + 8];~             | MOV r64, r/m64 | REX.W 8B /r |      | ~48 8B~ {{{modrm(5B,01,011,011)}}} ~08~ | rbx = [rbx+8]           |
| {{{i(1)}}} ~goto _find1.~                     | JMP rel8       | EB cb       |      | ~EB~ {{{offset(F1,9D-AC)}}}             | jump _find1             |
| ~_match:~                                     |                |             | ~AC~ |                                         |                         |
| {{{i(1)}}} ~if arg & 0b1000000 = 0:~          | TEST AL, imm8  | A8 ib       |      | ~A8~ /~80~/                             | al & 80(exec) ?         |
| {{{i(2)}}}     /# Compile./                   |                |             |      |                                         |                         |
| {{{i(2)}}}     ~goto COMPL.~                  | JZ rel8        | 74 cb       |      | ~74~ {{{offset(09,B9-B0)}}}             | jump COMPL if zero      |
| {{{i(1)}}} /# Execute: jump to entry's code./ |                |             | ~B0~ |                                         |                         |
| {{{i(1)}}} ~goto [entry@RBX].~                | JMP r/m64      | REX FF /4   |      | ~FF~ {{{modrm(23,00,100,011)}}}         | jump [rbx] (exec)       |
|                                               |                |             | ~B2~ |                                         |                         |


*** Subroutine COMPL                                               :noexport:

#+CAPTION: =COMPL=, the FORTH compiler.
#+LABEL: tbl:forth:compl
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                                                                | *Instruction* | *Opcode* | *&*  | *Machine code*                  | *Intention*                                        |
|---------------------------------------------------------------------------------------------+---------------+----------+------+---------------------------------+----------------------------------------------------|
| /# Define:/ _~COMPL~_                                                                       | /N/A/         | /N/A/    | ~B2~ | {{{define(99,43 4F 4D 50 4C)}}} | define COMPL                                       |
| /# In/Out:/ ~( xt@EBX -- )~                                                                 |               |          |      |                                 |                                                    |
|                                                                                             |               |          |      |                                 |                                                    |
| /# Generate a CALL instr. to ~OUTPUT~:/                                                     |               |          |      |                                 |                                                    |
| /# – instruction: CALL r/m64/                                                               |               |          |      |                                 |                                                    |
| /# – opcode: FF /2/                                                                         |               |          |      |                                 |                                                    |
| /#/                                                                                         |               |          |      |                                 |                                                    |
| /# Thus we generate code as follows:/                                                       |               |          |      |                                 |                                                    |
| /#/{{{c(2)}}}​~FF~ {{{modrm(14,00,010,100)}}} {{{sib(25,00,100,101)}}} _~??~ ~??~ ~??~ ~??~_ |               |          |      |                                 |                                                    |
|                                                                                             |               |          |      |                                 |                                                    |
| /# 1. Write opcode of CALL (0x99)./                                                         |               |          |      |                                 |                                                    |
| ~op@AL ← 0xFF;~                                                                             | MOV r8, imm8  | B0+rb ib | ~B9~ | ~B0~ /FF/                       | compile: call r/m64 (FF /2, 00 010 100, 00 100 101 |
| ~[OUTPUT@RDI++] ← op@AL;~                                                                   | STOS m8       | AA       |      | ~AA~                            |                                                    |
| /# 2. Write ModR/M byte (0x14)./                                                            |               |          |      |                                 |                                                    |
| ~modrm@AL ← 0x14;~                                                                          | MOV r8, imm8  | B0+rb ib |      | ~B0~ /14/                       | al = _                                             |
| ~[OUTPUT@RDI++] ← op@AL;~                                                                   | STOS m8       | AA       |      | ~AA~                            |                                                    |
| /# 3. Write SIB byte (0x25)./                                                               |               |          |      |                                 |                                                    |
| ~sib@AL ← 0x25;~                                                                            | MOV r8, imm8  | B0+rb ib |      | ~B0~ /25/                       | [rdi++] = al                                       |
| ~[OUTPUT@RDI++] ← op@AL;~                                                                   | STOS m8       | AA       |      | ~AA~                            |                                                    |
| /# 4. Write 4-byte code address./                                                           |               |          |      |                                 |                                                    |
| ~code@EAX ← xt@EBX;~                                                                        | XCHG EAX, r32 | 90+rd    |      | ~93~                            | eax = ebx                                          |
| ~[OUTPUT@RDI++4] ← op@EAX;~                                                                 | STOS m32      | AB       |      | ~AB~                            | [rdi(++4)] = eax                                   |
|                                                                                             |               |          |      |                                 |                                                    |
| ~return.~  /# From binary interpreter./                                                     | RET           | C3       |      | ~C3~                            | return                                             |
|                                                                                             |               |          | ~C5~ |                                 |                                                    |


*** Subroutine Head                                                :noexport:

#+CAPTION: Subroutine =Head= defines new words in the dictionary.
#+LABEL: tbl:forth:head
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                               | *Instruction*   | *Opcode*       | *&*  | *Machine code*                          | *Intention*   |
|--------------------------------------------+-----------------+----------------+------+-----------------------------------------+---------------|
| /# Define:/ _~Head~_                       | /N/A/           | /N/A/          | ~C5~ | {{{define(04,48 65 61 64)}}}            | define Head   |
| /# In/Out:/ ~( flag@AL -​- )~               |                 |                |      |                                         |               |
|                                            |                 |                |      |                                         |               |
| /# 16-bit align ~OUTPUT~./                 |                 |                |      |                                         |               |
| ~OUTPUT@RDI += 0x0F;~                      | ADD r/m64, imm8 | REX.W 83 /0 ib | ~CB~ | ~48 83~ {{{modrm(C7,11,000,111)}}} ~0F~ | rdi += 0F     |
| ~OUTPUT@RDI &= 0xF0;~                      | AND r/m64, imm8 | REX.W 83 /4 ib |      | ~48 83~ {{{modrm(E7,11,100,111)}}} ~F0~ | rdi &= F0     |
|                                            |                 |                |      |                                         |               |
| /# Fill the new dictionary entry:/         |                 |                |      |                                         |               |
|                                            |                 |                |      |                                         |               |
| /# 1. Set the _link field_, then set/      |                 |                |      |                                         |               |
| /#{{{c(3)}}}LATEST to the new entry./      |                 |                |      |                                         |               |
| ~latest@RCX ← [LATEST@RDX];~               | MOV r64, r/m64  | REX.W 8B /r    |      | ~48 8B~ {{{modrm(0A,00,001,010)}}}      | rcx = [rdx]   |
| ~[OUTPUT@RDI+8] ← latest@RCX;~             | MOV r/m64, r64  | REX.W 89 /r    |      | ~48 89~ {{{modrm(4F,01,001,111)}}} ~08~ | [rdi+8] = rcx |
| ~[LATEST@RDX] ← OUTPUT@RDI;~               | MOV r/m64, r64  | REX.W 89 /r    |      | ~48 89~ {{{modrm(3A,00,111,010)}}}      | [rdx] = rdi   |
|                                            |                 |                |      |                                         |               |
| /# 2. Set the _flag+length field_./        |                 |                |      |                                         |               |
| ~OUTPUT@RDI += 0x10;~                      | ADD r/m64, imm8 | REX.W 83 /0 ib |      | ~48 83~ {{{modrm(C7,11,000,111)}}} ~10~ | rdi += 10     |
| ~[OUTPUT@RDI++] ← flag@AL;~                | STOS m8         | AA             |      | ~AA~                                    | [rdi++] = al  |
|                                            |                 |                |      |                                         |               |
| /# 3. Extract name length from flag/       |                 |                |      |                                         |               |
| /#{{{c(3)}}}and copy _name field_./        |                 |                |      |                                         |               |
| ~flag@ECX ← flag@AL;~                      | XCHG EAX, r32   | 90+rd          |      | ~91~                                    | ecx = eax     |
| ~length@ECX ← flag@ECX & 0x1F;~            | AND r/m32, imm8 | 83 /4 ib       |      | ~83~ {{{modrm(E1,11,100,001)}}} ~1F~    | ecx &= 1F     |
| ~copy      length@ECX bytes~               |                 |                |      |                                         |               |
| {{{c(5)}}}​~from INPUT@RSI~                 |                 |                |      |                                         |               |
| {{{c(5)}}}​~to OUTPUT@RDI;~                 | REP MOVS m8, m8 | F3 A4          |      | ~F3 A4~                                 | copy Name     |
|                                            |                 |                |      |                                         |               |
| /# 4. Point _code field_ to the machine/   |                 |                |      |                                         |               |
| /#{{{c(3)}}}code that follows at ~INPUT~./ |                 |                |      |                                         |               |
| ~code@RCX ← [LATEST@RDX];~                 | MOV r64, r/m64  | REX.W 8B /r    |      | ~48 8B~ {{{modrm(0A,00,001,010)}}}      | rcx = [rdx]   |
| ~[code@RCX] ← INPUT@RDI;~                  | MOV r/m64, r64  | REX.W 89 /r    |      | ~48 89~ {{{modrm(39,00,111,001)}}}      | [rcx] = rdi   |
| ~return;~  /# From binary interpreter./    | RET             | C3             |      | ~C3~                                    | return        |
|                                            |                 |                | ~EF~ |                                         |               |


*** Subroutine BYE                                                 :noexport:

#+CAPTION: Subroutine ~BYE~ terminates the program by performing an ~exit~ syscall.
#+LABEL: tbl:forth:bye
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                       | *Instruction*  | *Opcode* | *&*  | *Machine code*                  | *Intention*            |
|------------------------------------+----------------+----------+------+---------------------------------+------------------------|
| /# Define:/ _~BYE~_                | /N/A/          | /N/A/    | ~EF~ | {{{define(03,42 59 45)}}}       | define BYE             |
| /# In/Out: ~( -​- )~/               |                |          |      |                                 |                        |
|                                    |                |          |      |                                 |                        |
| /# Goodbye, world (exit syscall)./ |                |          |      |                                 |                        |
| ~nr@RAX ← 0x3C;~  /# ~__NR_exit~./ | PUSH imm8      | 6A ib    |      | ~6A~ /~3C~/                     | rax = exit (no return) |
|                                    | POP            | 58+rd    |      | ~58~                            |                        |
| ~status@RDI ← 0;~                  | XOR r/m32, r32 | 31 /r    |      | ~31~ {{{modrm(FF,11,111,111)}}} | rdi = stat             |
| ~syscall exit(status@RDI).~        | SYSCALL        | 0F 05    |      | ~0F 05~                         | syscall                |
|                                    |                |          | ~FB~ |                                 |                        |


*** Subroutine TYPE                                                :noexport:
:LOGBOOK:
- Note taken on [2024-07-29 Mon 13:19] \\
  Why not save ~RSI~ and ~RDI~ inside ~TYPE~ rather than at call sites?
:END:

#+CAPTION: Subroutine ~TYPE~ dumps a memory range to ~STDOUT~.
#+LABEL: tbl:forth:type
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                     | *Instruction*   | *Opcode*    | *&*        | *Machine code*                     | *Intention*           |
|--------------------------------------------------+-----------------+-------------+------------+------------------------------------+-----------------------|
| /# Define:/ _~TYPE~_                             | /N/A/           | /N/A/       |            | {{{define(04,54 59 50 45)}}}       | define TYPE           |
| /# In/Out: ~( addr@RSI u@RDX~/                   |                 |             |            |                                    |                       |
| /#{{{c(6)}}} ~-​- ?@RSI ?@RDI )~/                 |                 |             |            |                                    |                       |
| /#/                                              |                 |             |            |                                    |                       |
| /# Dump memory range ~[addr, addr+u)~./          |                 |             |            |                                    |                       |
|                                                  |                 |             |            |                                    |                       |
| {{{i(1)}}} ~fd@RDI ← 1;~ /# ~STDOUT_FILENO~./    | PUSH imm8       | 6A ib       |            | ~6A~ /~01~/                        | rdi(fd) = stdout = 1  |
|                                                  | POP             | 58+rd       |            | ~5F~                               |                       |
| ~_beg:~                                          |                 |             | ~00~[fn:2] |                                    |                       |
| {{{i(1)}}} /# ~__NR_write~ is also 1./           |                 |             |            |                                    |                       |
| {{{i(1)}}} ~nr@RAX ← fd@RDI;~                    | MOV r32, r/m32  | 8B /r       |            | ~8B~ {{{modrm(C7,11,000,111)}}}    | rax = write = 1 = rdi |
| {{{i(1)}}} ~syscall write(fd@RDI,~               |                 |             |            |                                    |                       |
| {{{i(1)}}}{{{c(14)}}}    ~addr@RSI,~             |                 |             |            |                                    |                       |
| {{{i(1)}}}{{{c(14)}}}    ~u@RDX);~               | SYSCALL         | 0F 05       |            | ~0F 05~                            | syscall               |
| {{{i(1)}}} ~if ret@RAX < 0:~                     | TEST r/m64, r64 | REX.W 85 /r |            | ~48 85~ {{{modrm(C0,11,000,000)}}} | cmp rax, 0            |
| {{{i(2)}}} /# An error occured./                 |                 |             |            |                                    |                       |
| {{{i(2)}}}     ~goto _end;~                      | JL rel8         | 7C cb       |            | ~7C~ {{{offset(08,11-09)}}}        | +jump _end if <       |
| {{{i(1)}}} /# Advance by ~ret~ (printed) bytes./ |                 |             | ~09~       |                                    |                       |
| {{{i(1)}}} ~addr@RSI += ret@RAX;~                | ADD r/m64, r64  | REX.W 01 /r |            | ~48 01~ {{{modrm(C6,11,000,110)}}} | rsi(buf) += rax       |
| {{{i(1)}}} /# Fewer bytes left to print./        |                 |             |            |                                    |                       |
| {{{i(1)}}} ~u@RDX -= ret@RAX;~                   | SUB r/m64, r64  | REX.W 29 /r |            | ~48 29~ {{{modrm(C2,11,000,010)}}} | rdx(count) -= rax     |
| {{{i(1)}}} ~if count > 0:~                       |                 |             |            |                                    |                       |
| {{{i(2)}}}     /# We still have bytes to print./ |                 |             |            |                                    |                       |
| {{{i(2)}}}     ~goto _beg;~                      | JG rel8         | 7F cb       |            | ~7F~ {{{offset(EF,00-11)}}}        | -jump _beg if >       |
| ~_end:~                                          |                 |             | ~11~       |                                    |                       |
| {{{i(1)}}} ~return.~                             | RET             | C3          |            | ~C3~                               | return                |
|                                                  |                 |             | ~12~       |                                    |                       |


*** Debugging utilities                                            :noexport:

#+CAPTION: Subroutine ~dbg~ dumps the working memory to ~STDOUT~.
#+LABEL: tbl:forth:dbg
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                           | *Instruction*  | *Opcode* | *&*  | *Machine code*            | *Intention* |
|----------------------------------------+----------------+----------+------+---------------------------+-------------|
| /# Define:/ _~dbg~_                    | /N/A/          | /N/A/    | ~12~ | {{{define(03,64 52 67)}}}​ | define dbg  |
| /# In/Out: ~( -​- )~/                   |                |          |      |                           |             |
| /#/                                    |                |          |      |                           |             |
| /# Dump the working memory./           |                |          |      |                           |             |
|                                        |                |          |      |                           |             |
| ~save INPUT@RSI on the stack;~         | PUSH r64       | 50+rd    |      | ~56~                      | push rsi    |
| ~save OUTPUT@RDI on the stack;~        | PUSH r64       | 50+rd    |      | ~57~                      | push rdi    |
| /# Dump memory contents using/         |                |          |      |                           |             |
| /# subroutine ~TYPE~./                 |                |          |      |                           |             |
| ~addr@RSI ← 0x0FFFFFE0;~               | MOV r32, imm32 | B8+rd id |      | ~BE~ /~E0 FF FF 0F~/      | rsi = addr  |
| ~u@RDX ← 0x0A00;~                      | MOV r32, imm32 | B8+rd id |      | ~BA~ /~00 0A 00 00~/      | rdx = u     |
| /# Compile a CALL to ~TYPE(addr, u)~./ |                |          |      |                           |             |
| ~TYPE();~  /# Compiled call./          | /N/A/          | /N/A/    |      | {{{compile(54,T)}}}       | Call TYPE   |
| /# Restore registers and return./      |                |          |      |                           |             |
| ~restore OUTPUT@RDI;~                  | POP r64        | 58+rd    |      | ~5F~                      | pop rdi     |
| ~restore INPUT@RSI;~                   | POP r64        | 58+rd    |      | ~5E~                      | pop rsi     |
| ~return.~                              | RET            | C3       |      | ~C3~                      | return      |
|                                        |                |          | ~28~ |                           |             |

#+CAPTION: Subroutine ~reg~ dumps the registers to ~STDOUT~.
#+LABEL: tbl:forth:reg
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                             | *Instruction*   | *Opcode*       | *&*  | *Machine code*                        | *Intention*             |
|------------------------------------------+-----------------+----------------+------+---------------------------------------+-------------------------|
| /# Define:/ _~reg~_                      | /N/A/           | /N/A/          | ~12~ | {{{define(03,72 65 67)}}}             | define reg              |
| /# In/Out: ~( -​- )~/                     |                 |                |      |                                       |                         |
| /#/                                      |                 |                |      |                                       |                         |
| /# Dump the registers./                  |                 |                |      |                                       |                         |
|                                          |                 |                |      |                                       |                         |
| ~save INPUT@RSI;~                        | PUSH r64        | 50+rd          |      | ~56~                                  | push rsi                |
| ~save OUTPUT@RDI;~                       | PUSH r64        | 50+rd          |      | ~57~                                  | push rdi                |
|                                          |                 |                |      |                                       |                         |
| /# Push the 16 registers on the/         | PUSH r64        | REX 50+rd      |      | ~41 57~                               | push r15, rdi, r14, rsi |
| /# stack so that when printed/           | PUSH r64        | 50+rd          |      | ~57~                                  | push r13, rbp, r12, rsp |
| /# they're displayed like this:/         | PUSH r64        | REX 50+rd      |      | ~41 56~                               | push r11, rbx, r10, rdx |
| /#/                                      | PUSH r64        | 50+rd          |      | ~56~                                  | push r9 , rcx, r8 , rax |
| /#/{{{c(4)}}} ~·-----------·~            | PUSH r64        | REX 50+rd      |      | ~41 55~                               |                         |
| /#/{{{c(4)}}} ~¦~​{{{c(1)}}}​~R15 ¦ RDI ¦~ | PUSH r64        | 50+rd          |      | ~55~                                  |                         |
| /#/{{{c(4)}}} ~¦~​{{{c(1)}}}​~R14 ¦ RSI ¦~ | PUSH r64        | REX 50+rd      |      | ~41 54~                               |                         |
| /#/{{{c(4)}}} ~¦~​{{{c(1)}}}​~··· ¦ ··· ¦~ | PUSH r64        | 50+rd          |      | ~54~                                  |                         |
| /#/{{{c(4)}}} ~¦~​{{{c(2)}}}​~R8  ¦ RAX ¦~ | PUSH r64        | REX 50+rd      |      | ~41 53~                               |                         |
| /#/{{{c(4)}}} ~·-----------·~            | PUSH r64        | 50+rd          |      | ~53~                                  |                         |
|                                          | PUSH r64        | REX 50+rd      |      | ~41 52~                               |                         |
|                                          | PUSH r64        | 50+rd          |      | ~52~                                  |                         |
|                                          | PUSH r64        | REX 50+rd      |      | ~41 51~                               |                         |
|                                          | PUSH r64        | 50+rd          |      | ~51~                                  |                         |
|                                          | PUSH r64        | REX 50+rd      |      | ~41 50~                               |                         |
|                                          | PUSH r64        | 50+rd          |      | ~50~                                  |                         |
| /# Print top 128 stack bytes using/      |                 |                |      |                                       |                         |
| /# subroutine ~TYPE(addr, u)~./          |                 |                |      |                                       |                         |
| ~addr@RSI ← RSP;~                        | MOV r64, r/m64  | REX.W 8B /r    |      | ~48 8B~ {{{modrm(F4,11,110,100)}}}    | rsi = rsp               |
| ~u@RDX <- 0x80;~                         | MOV r32, imm32  | B8+rd id       |      | ~BA~ /~80 00 00 00~/                  | rdx = u                 |
| ~TYPE();~  /# Compiled call./            | /N/A/           | /N/A/          |      | {{{compile(54,T)}}}                   | Call TYPE               |
| /# Clean the stack./                     |                 |                |      |                                       |                         |
| ~pop 16 quads;~                          | SUB r/m64, imm8 | REX.W 83 /5 ib |      | ~48 83~ {{{modrm(EC,11,101,100)}}} 80 | rsp -= -80              |
| ~restore OUTPUT@RDI;~                    | POP r64         | 58+rd          |      | ~5F~                                  | pop rdi                 |
| ~restore INPUT@RSI;~                     | POP r64         | 58+rd          |      | ~5E~                                  | pop rsi                 |
| ~return.~                                | RET             | C3             |      | ~C3~                                  | return                  |
|                                          |                 |                | ~42~ |                                       |                         |


*** Text interpreter

# ============= TEXT INTERPRETER
#
# Standard Forth handles input one line at a time.
# SmithForth's text interpreter is a simple interpreter in the standard Forth style.
# SVAL (see standard Forth's EVALUATE) interprets each line.
# REFILL fetches a line of input, including its trailing LF, and sets the input source state.
#     10000000 #IN      cell contains #characters in the current line.
#     10000008 TIB      cell contains the address where the current line begins.
#     10000010 >IN      cell contains #characters in the current line that have been parsed.
#     10000020 STATE    cell contains 0(Interpreting) or 1(Compiling).
#     10000028 Latest   cell contains the execution token (xt) of the latest defined Forth word.
# In Forth, to parse is to remove from the input stream. As a line is parsed, [>IN] increases from 0 to [#IN].
# Forth's "parse area" is the part of the line not yet parsed.

**** REFILL                                                        :noexport:

#+CAPTION: Subroutine ~REFILL~ TODO.
#+LABEL: tbl:forth:refill
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                     | *Instruction*      | *Opcode*         | *&*  | *Machine code*                                            | *Intention*      |
|--------------------------------------------------+--------------------+------------------+------+-----------------------------------------------------------+------------------|
| /# Define:/ _~REFILL~_                           | /N/A/              | /N/A/            |      | {{{define(06,52 45 46 49 4C 4C)}}}                        | define REFILL    |
| /# In/Out: ~( -​- )~/                             |                    |                  |      |                                                           |                  |
| /#/                                              |                    |                  |      |                                                           |                  |
| /# Advance ~TIB~ and ~#IN~ so/                   |                    |                  |      |                                                           |                  |
| /# that ~[TIB, #IN)~ contains/                   |                    |                  |      |                                                           |                  |
| /# a new line to be parsed./                     |                    |                  |      |                                                           |                  |
|                                                  |                    |                  |      |                                                           |                  |
| {{{i(1)}}} /# Base address of globals./          |                    |                  |      |                                                           |                  |
| {{{i(1)}}} ~VARS@R9 ← 0x10000000;~               | MOV r/m64, /imm32/ | REX.W C7 /​0 /id/ |      | ~49 C7~ {{{modrm(C1,11,000,001)}}} /~00 00 00 10~/        | r9 = VAR         |
|                                                  |                    |                  |      |                                                           |                  |
| {{{i(1)}}} /# Advance ~TIB~​ by ~#IN~./           |                    |                  |      |                                                           |                  |
| {{{i(1)}}} /#/                                   |                    |                  |      |                                                           |                  |
| {{{i(1)}}} /# Note:         ~#IN~ is ~VARS+0~,/  |                    |                  |      |                                                           |                  |
| {{{i(1)}}} /# {{{i(2.35)}}} ~TIB~ is ~VARS+8~,/  |                    |                  |      |                                                           |                  |
| {{{i(1)}}} /# {{{i(2.35)}}} ~>IN~ is ~VARS+16~./ |                    |                  |      |                                                           |                  |
| {{{i(1)}}} ~nIN@RAX ← [#IN];~                    | MOV r64, r/m64     | REX.W 8B /r      |      | ~49 8B~ {{{modrm(01,00,000,001)}}}                        | rax = [#IN]      |
| {{{i(1)}}} ~[TIB] += nIN@RAX;~                   | ADD r/m64, r64     | REX.W 01 /r      |      | ~49 01~ {{{modrm(41,01,000,001)}}} {{{displ(08)}}}        | [TIB] += rax     |
| {{{i(1)}}} /# Reset ~#IN~ and ~>IN~ to 0./       |                    |                  |      |                                                           |                  |
| {{{i(1)}}} ~[#IN] &= 0;~                         | AND r/m64, /imm8/  | REX.W 83 /​4 /ib/ |      | ~49 83~ {{{modrm(21,00,100,001)}}} /~00~/                 | [#IN] = 0        |
| {{{i(1)}}} ~[>IN] &= 0;~                         | AND r/m64, /imm8/  | REX.W 83 /​4 /ib/ |      | ~49 83~ {{{modrm(61,01,100,001)}}} {{{displ(10)}}} /~00~/ | [>IN] = 0        |
|                                                  |                    |                  |      |                                                           |                  |
| {{{i(1)}}} /# Advance ~#IN~ until just/          |                    |                  |      |                                                           |                  |
| {{{i(1)}}} /# after first ~LF~ character./       |                    |                  |      |                                                           |                  |
| ~_beg:~                                          |                    |                  | ~00~ |                                                           | _beg:            |
| {{{i(1)}}} ~[#IN]++;~                            | INC r/m64          | REX.W FF /0      |      | ~49 FF~ {{{modrm(01,00,000,001)}}}                        | [#IN]++          |
| {{{i(1)}}} ~RAX ← [TIB];~                        | MOV r64, r/m64     | REX.W 8B /r      |      | ~49 8B~ {{{modrm(41,01,000,001)}}} {{{displ(08)}}}        | rax = [TIB]      |
| {{{i(1)}}} ~RAX += [#IN];~                       | ADD r64, r/m64     | REX.W 03 /r      |      | ~49 03~ {{{modrm(01,00,000,001)}}}                        | rax += [#IN]     |
| {{{i(1)}}} /# Newline character?/                |                    |                  |      |                                                           |                  |
| {{{i(1)}}} ~if [RAX-1] != 0x0A:~                 | CMP r/m8, /imm8/   | 80 /​7 /ib/       |      | ~80~ {{{modrm(78,01,111,000)}}} {{{displ(FF)}}} /~0A~/    | cmp [rax-1], LF  |
| {{{i(2)}}}   ~goto _beg.~                        | JNE _rel8_         | 75 _cb_          |      | ~75~ {{{offset(F0,00-10)}}}                               | -jump _beg if != |
| {{{i(1)}}} ~return.~                             | RET                | C3               | ~10~ | ~C3~                                                      | return           |

**** seek                                                          :noexport:

#+CAPTION: Subroutine ~seek~ parses characters until it finds one in a given range.
#+LABEL: tbl:forth:seek
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                    | *Instruction*      | *Opcode*         | *&*  | *Machine code*                                     | *Intention*                                 |
|-------------------------------------------------+--------------------+------------------+------+----------------------------------------------------+---------------------------------------------|
| /# Define:/ _~seek~_                            | /N/A/              | /N/A/            |      | {{{define(04,73 65 65 6B)}}}                       | define seek                                 |
| /# In/Out:    ~( low@CL high@DL~/               |                    |                  |      |                                                    |                                             |
| /# {{{c(8)}}} ​~"ccc"~/                          |                    |                  |      |                                                    |                                             |
| /# {{{c(5)}}}​ ~-​- FLAGS )~/               |                    |                  |      |                                                    |                                             |
| /#/                                             |                    |                  |      |                                                    |                                             |
| /# Advance ~>IN~ until next/                    |                    |                  |      |                                                    |                                             |
| /# char is within ~[low, high)~/                |                    |                  |      |                                                    |                                             |
| /# or parse area is empty./                     |                    |                  |      |                                                    |                                             |
|                                                 |                    |                  |      |                                                    |                                             |
| {{{c(2)}}} ~VARS@R9 ← 0x10000000;~              | MOV r/m64, /imm32/ | REX.W C7 /​0 /id/ |      | ~49 C7~ {{{modrm(C1,11,000,001)}}} /~00 00 00 10~/ | r9 = VAR                                    |
| {{{c(2)}}} ~high@DL -= low@CL;~                 | SUB r8, r/m8       | 2A /r            |      | ~2A~ {{{modrm(D1,11,010,001)}}}                    | dl -= cl                                    |
| ~_beg:~                                         |                    |                  | ~00~ |                                                    | # _beg:  like WITHIN ( al cl dl -- eflags ) |
| {{{c(2)}}} /# Is parse area empty?/             |                    |                  |      |                                                    |                                             |
| {{{c(2)}}} ~RAX ← [>IN];~                       | MOV r64, r/m64     | REX.W 8B /r      |      | ~49 8B~ {{{modrm(41,01,000,001)}}} {{{displ(10)}}} | rax = [>IN]                                 |
| {{{c(2)}}} ~if RAX~ \ge{{{unsigned}}} ~[#IN]:~  | CMP r64, r/m64     | REX.W 3B /r      |      | ~49 3B~ {{{modrm(01,00,000,001)}}}                 | cmp rax, [#IN]                              |
| {{{c(4)}}}   ~goto _end.~                       | JAE _rel8_         | 73 _cb_          |      | ~73~ {{{offset(16,1F-09)}}}                        | +jump _end if U>=                           |
| {{{c(2)}}} /# Get current character./           |                    |                  | ~09~ |                                                    |                                             |
| {{{c(2)}}} ~RAX ← [TIB];~                       | MOV r64, r/m64     | REX.W 8B /r      |      | ~49 8B~ {{{modrm(41,01,000,001)}}} {{{displ(08)}}} | rax = [TIB]                                 |
| {{{c(2)}}} ~RAX += [>IN];~                      | ADD r64, r/m64     | REX.W 03 /r      |      | ~49 03~ {{{modrm(41,01,000,001)}}} {{{displ(10)}}} | rax += [>IN]                                |
| {{{c(2)}}} ~chr@AL ← [RAX];~                    | MOV r8, r/m8       | 8A /r            |      | ~8A~ {{{modrm(00,00,000,000)}}}                    | al = [rax]                                  |
| {{{c(2)}}} /# Is ~chr~ in ~[low, high)~?/       |                    |                  |      |                                                    |                                             |
| {{{c(2)}}} ~AL -= low@CL;~                      | SUB r8, r/m8       | 2A /r            |      | ~2A~ {{{modrm(C1,11,000,001)}}}                    | al -= cl                                    |
| {{{c(2)}}} ~if AL~ \lt{{{unsigned}}} ~high@DL:~ | CMP r8, r/m8       | 3A /r            |      | ~3A~ {{{modrm(C2,11,000,010)}}}                    | cmp al, dl                                  |
| {{{c(4)}}}   ~goto _end.~                       | JB _rel8_          | 72 _cb_          |      | ~72~ {{{offset(06,1F-19)}}}                        | +jump _end if U<                            |
| {{{c(2)}}} /# Go to next character./            |                    |                  | ~19~ |                                                    |                                             |
| {{{c(2)}}} ~[>IN]++;~                           | INC r/m64          | REX.W FF /0      |      | ~49 FF~ {{{modrm(41,01,000,001)}}} {{{displ(10)}}} | [>IN]++                                     |
| {{{c(2)}}} ~goto _beg.~                         | JMP _rel8_         | EB _cb_          |      | ~EB~ {{{offset(E1,00-1F)}}}                        | -jump _beg                                  |
| ~_end:~                                         |                    |                  | ~1F~ |                                                    | # _end:                                     |
| {{{c(2)}}} ~return.~                            | RET                | C3               |      | ~C3~                                               | return                                      |

**** PARSE                                                         :noexport:

#+CAPTION: Subroutine ~PARSE~ returns the address and size of a newly parsed string.
#+LABEL: tbl:forth:parse
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                               | *Instruction*      | *Opcode*         | *&*  | *Machine code*                                     | *Intention*                                                                         |
|--------------------------------------------+--------------------+------------------+------+----------------------------------------------------+-------------------------------------------------------------------------------------|
| /# Define:/ _~PARSE~_                      | /N/A/              | /N/A/            |      | {{{define(04,50 41 52 53 45)}}}                    | define PARSE                                                                        |
| /# In/Out:    ~( low@CL high@DL~/          |                    |                  |      |                                                    |                                                                                     |
| /# {{{c(8)}}} ​~"ccc<char>"~/               |                    |                  |      |                                                    |                                                                                     |
| /# {{{c(5)}}}​ ~-​- addr@RBP u@RAX )~/       |                    |                  |      |                                                    |                                                                                     |
| /#/                                        |                    |                  |      |                                                    |                                                                                     |
| /# *TODO*:/                                |                    |                  |      |                                                    |                                                                                     |
| /# -- addr: where ccc begins/              |                    |                  |      |                                                    |                                                                                     |
| /# -- u: length of ccc/                    |                    |                  |      |                                                    |                                                                                     |
|                                            |                    |                  |      |                                                    |                                                                                     |
| {{{c( 2)}}} ~VARS@R9 ← 0x10000000;~        | MOV r/m64, /imm32/ | REX.W C7 /​​0 /id/ |      | ~49 C7~ {{{modrm(C1,11,000,001)}}} /~00 00 00 10~/ | r9 = VAR                                                                            |
| {{{c( 2)}}} ~start@RBP ← [>IN];~           | MOV r64, r/m64     | REX.W 8B /r      |      | ~49 8B~ {{{modrm(69,01,101,001)}}} {{{displ(10)}}} | rbp = [>IN]                                                                         |
| {{{c( 2)}}} /# Compile a call to ~seek()~/ |                    |                  |      |                                                    |                                                                                     |
| {{{c( 2)}}} /# that advances ~>IN~./       |                    |                  |      |                                                    |                                                                                     |
| {{{c( 2)}}} ~seek();~  /# Compiled call./  | /N/A/              | /N/A/            |      | {{{compile(73,s)}}}                                | Call seek  (parse until 1st instance within [cl, dl) is parsed or parse area empty) |
| {{{c( 2)}}} ~end@RAX ← [>IN];~             | MOV r64, r/m64     | REX.W 8B /r      |      | ~49 8B~ {{{modrm(41,01,000,001)}}} {{{displ(10)}}} | rax = [>IN]                                                                         |
| {{{c( 2)}}} /# Did ~seek()~ encounter the/ |                    |                  |      |                                                    |                                                                                     |
| {{{c( 2)}}} /# end of the parse area?/     |                    |                  |      |                                                    |                                                                                     |
| {{{c( 2)}}} ~if parse area empty:~         |                    |                  |      |                                                    |                                                                                     |
| {{{c( 4)}}}   ~goto _end.~                 | JAE _rel8_         | 73 _cb_          |      | ~73~ {{{offset(04,04-00)}}}                        | +jump _end if U>=                                                                   |
| {{{c( 2)}}} ~[>IN]++;~  /# ???/            | INC r/m64          | REX.W FF /0      | ~00~ | ~49 FF~ {{{modrm(41,01,000,001)}}} {{{displ(10)}}} | [>IN]++                                                                             |
| ~_end:~                                    |                    |                  | ~04~ |                                                    | # _end:                                                                             |
| {{{c( 2)}}} /# Compute address and/        |                    |                  |      |                                                    |                                                                                     |
| {{{c( 2)}}} /# size of parsed input./      |                    |                  |      |                                                    |                                                                                     |
| {{{c( 2)}}} ~u@RAX = end@RAX~              |                    |                  |      |                                                    |                                                                                     |
| {{{c( 8)}}}       ~- start@RBP;~           | SUB r/m64, r64     | REX.W 29 /r      |      | ~48 29~ {{{modrm(E8,11,101,000)}}}                 | rax -= rbp                                                                          |
| {{{c( 2)}}} ~addr@RBP = bgn@RBP~           | ADD r64, r/m64     | REX.W 03 /r      |      | ~49 03~ {{{modrm(69,01,101,001)}}} {{{displ(08)}}} | rbp += [TIB]                                                                        |
| {{{c(11)}}}          ~+ [TIB];~            |                    |                  |      |                                                    |                                                                                     |
| {{{c( 2)}}} ~return.~                      | RET                | C3               |      | ~C3~                                               | return                                                                              |

**** pname                                                         :noexport:

#+CAPTION: Subroutine ~pname~ TODO.
#+LABEL: tbl:forth:pname
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                            | *Instruction*  | *Opcode*   | *Machine code*                  | *Intention*            |
|-----------------------------------------+----------------+------------+---------------------------------+------------------------|
| /# Define:/ _~pname~_                   | /N/A/          | /N/A/      | {{{define(05,70 6E 61 6D 65)}}} | define pname           |
| /# In/Out:    ~( "<spaces>ccc<space>"~/ |                |            |                                 |                        |
| /# {{{c(6)}}}​ ~-​- addr@RBP u@RAX )~/    |                |            |                                 |                        |
| /#/                                     |                |            |                                 |                        |
| /# *TODO*: PARSE-NAME???/               |                |            |                                 |                        |
| /# -- addr: where ccc begins/           |                |            |                                 |                        |
| /# -- u: length of ccc/                 |                |            |                                 |                        |
|                                         |                |            |                                 |                        |
| ~low@CL ← 0x21;~   /# ??/               | MOV r8, /imm8/ | B0+rb /ib/ | ~B1~ /~21~/                     |                        |
| ~high@DL ← 0x7F;~  /# ??/               | MOV r8, /imm8/ | B0+rb /ib/ | ~B2~ /~7F~/                     | (cl, dl) = (BL+1, ...) |
| ~seek();~  /# Compiled call./           | /N/A/          | /N/A/      | {{{compile(73,s)}}}             | Call seek              |
| ~low@CL ← 0x7F;~                        | MOV r8, /imm8/ | B0+rb /ib/ | ~B1~ /~7F~/                     |                        |
| ~high@DL ← 0x21;~                       | MOV r8, /imm8/ | B0+rb /ib/ | ~B2~ /~21~/                     | (cl, dl) = (..., BL+1) |
| ~PARSE();~  /# Compiled call./          |                |            | {{{compile(50,P)}}}             | Call PARSE             |
| ~return.~                               | RET            | C3         | ~C3~                            | return                 |

**** [                                                             :noexport:

#+CAPTION: Subroutine ~'['~ changes Forth's ~STATE~ to interpreting.
#+LABEL: tbl:forth:lbracket
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                      | *Instruction* | *Opcode* | *Machine code*                                                                    | *Intention*          |
|-----------------------------------+---------------+----------+-----------------------------------------------------------------------------------+----------------------|
| /# Define immediate:/ _~[~_       | /N/A/         | /N/A/    | {{{define(81,5B)}}}                                                               | define [             |
| /# In/Out:    ~( -​- )~/           |               |          |                                                                                   |                      |
| /#/                               |               |          |                                                                                   |                      |
| /# Switch to interpreting state./ |               |          |                                                                                   |                      |
|                                   |               |          |                                                                                   |                      |
| /# Set STATE to 0./               |               |          |                                                                                   |                      |
| ~push 0;~                         | PUSH /imm8/   | 6A /ib/  | ~6A~ /~00~/                                                                       | push 0(Interpreting) |
| ~[STATE] ← pop;~                  | POP r/m64     | 8F /0    | ~8F~ {{{modrm(04,00,000,100)}}} {{{sib(25,00,100,101)}}} {{{displ(20 00 00 10)}}} | pop [STATE]          |
| ~return.~                         | RET           | C3       | ~C3~                                                                              | return               |

**** ]                                                             :noexport:

#+CAPTION: Subroutine ~']'~ changes Forth's ~STATE~ to compiling.
#+LABEL: tbl:forth:rbracket
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                   | *Instruction* | *Opcode* | *Machine code*                                                                    | *Intention*       |
|--------------------------------+---------------+----------+-----------------------------------------------------------------------------------+-------------------|
| /# Define:/ _~]~_              | /N/A/         | /N/A/    | {{{define(01,5D)}}}                                                               | define ]          |
| /# In/Out: ~( -​- )~/           |               |          |                                                                                   |                   |
| /#/                            |               |          |                                                                                   |                   |
| /# Switch to compiling state./ |               |          |                                                                                   |                   |
|                                |               |          |                                                                                   |                   |
| /# Set STATE to 1./            |               |          |                                                                                   |                   |
| ~push 1;~                      | PUSH /imm8/   | 6A /ib/  | ~6A~ /~01~/                                                                       | push 1(Compiling) |
| ~[STATE] ← pop;~               | POP r/m64     | 8F /0    | ~8F~ {{{modrm(04,00,000,100)}}} {{{sib(25,00,100,101)}}} {{{displ(20 00 00 10)}}} | pop [STATE]       |
| ~return.~                      | RET           | C3       | ~C3~                                                                              | return            |

**** \                                                             :noexport:

#+CAPTION: Subroutine ~'\'~ implements line comments.
#+LABEL: tbl:forth:backslash
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                    | *Instruction*  | *Opcode*    | *Machine code*                                                                       | *Intention* |
|---------------------------------+----------------+-------------+--------------------------------------------------------------------------------------+-------------|
| /# Define immediate:/ _~\~_     | /N/A/          | /N/A/       | {{{define(81,5C)}}}                                                                  | define \    |
| /# In/Out: ~( "ccc<eol>" -​- )~/ |                |             |                                                                                      |             |
| /#/                             |                |             |                                                                                      |             |
| /# Consumes all characters/     |                |             |                                                                                      |             |
| /# left on the current line./   |                |             |                                                                                      |             |
|                                 |                |             |                                                                                      |             |
| ~RAX ← [#IN];~                  | MOV r64, r/m64 | REX.W 8B /r | ~48 8B~ {{{modrm(04,00,000,100)}}} {{{sib(25,00,100,101)}}} {{{displ(00 00 00 10)}}} | rax = [#IN] |
| ~[>IN] ← RAX;~                  | MOV r/m64, r64 | REX.W 89 /r | ~48 89~ {{{modrm(04,00,000,100)}}} {{{sib(25,00,100,101)}}} {{{displ(10 00 00 10)}}} | [>IN] = rax |
| ~return.~                       | RET            | C3          | ~C3~                                                                                 | return      |

**** (                                                             :noexport:

#+CAPTION: Subroutine ~'('~ implements inline comments (ending with a corresponding ~')'~).
#+LABEL: tbl:forth:lparen
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                               | *Instruction*  | *Opcode*   | *Machine code*      | *Intention*                                                                 |
|--------------------------------------------+----------------+------------+---------------------+-----------------------------------------------------------------------------|
| /# Define immediate:/ _~(~_                | /N/A/          | /N/A/      | {{{define(81,28)}}} | define (                                                                    |
| /# In/Out: ~( "ccc<rparen>" -​- )~/         |                |            |                     |                                                                             |
| /#/                                        |                |            |                     |                                                                             |
| /# Consume characters until a ')' occurs./ |                |            |                     |                                                                             |
|                                            |                |            |                     |                                                                             |
| ~low@CL ← ')';~                            | MOV r8, /imm8/ | B0+rb /ib/ | ~B1~ /~29~/         |                                                                             |
| ~high@DL ← ')' + 1;~                       | MOV r8, /imm8/ | B0+rb /ib/ | ~B2~ /~2A~/         | (cl, dl) = (RP, RP+1)                                                       |
| ~PARSE();~  /# Compiled call./             | /N/A/          | /N/A/      | {{{compile(50,P)}}} | Call PARSE            Forth 2012 implies comment ends at rparen or newline. |
| ~return.~                                  | RET            | C3         | ~C3~                | return                                                                      |

**** :                                                             :noexport:

#+CAPTION: Subroutine ~:~ (colon) begins compiling a word after setting up its dictionary entry.
#+LABEL: tbl:forth:colon
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                              | *Instruction*     | *Opcode*          | *Machine code*                            | *Intention*                            |
|-------------------------------------------+-------------------+-------------------+-------------------------------------------+----------------------------------------|
| /# Define:/ _~':'~_                       | ---               | ---               | {{{define(01,3A)}}}                       | define :                               |
| /# In/Out: ~( "<spaces>ccc<space>" -​- )~/ |                   |                   |                                           |                                        |
| /#/                                       |                   |                   |                                           |                                        |
| /# *TODO*​/                                |                   |                   |                                           |                                        |
|                                           |                   |                   |                                           |                                        |
| /# TODO./                                 |                   |                   |                                           |                                        |
| ~pname();~  /# Compiled call./            | ---               | ---               | {{{compile(70,p)}}}                       | Call pname  (See Forth 2012 Table 2.1) |
| ~RSI ← RBP;~                              | MOV r/m64, r64    | REX.W 89 /r       | ~48 89~ {{{modrm(EE,11,101,110)}}}        | rsi = rbp                              |
| ~RDX ← LATEST;~                           | MOV r32, /imm32/  | B8+rd /id/        | ~BA~ /~28 00 00 10~/                      | rdx = Latest                           |
| ~Head();~  /# Compiled call./             | ---               | ---               | {{{compile(48,H)}}}                       | Call Head                              |
|                                           |                   |                   |                                           |                                        |
| /# Set the HIDDEN flag (~0x40~)/          |                   |                   |                                           |                                        |
| /# on the dictionary entry./              |                   |                   |                                           |                                        |
| ~RCX ← [RDX];~                            | MOV r64, r/m64    | REX.W 8B /r       | ~48 8B~ {{{modrm(0A,00,001,010)}}}        | rcx = [rdx]                            |
| ~RCX += 16;~                              | ADD r/m64, /imm8/ | 9REX.W 83 /​0 /ib/ | ~48 83~ {{{modrm(C1,11,000,001)}}} /~10~/ | rcx += 10                              |
| ~[RCX]~ \vert{}​~=~ ~0x40;~                      | OR r/m8, /imm8/   | 80 /1 /ib/        | ~80~ {{{modrm(09,00,001,001)}}} /~40~/    | [rcx] ¦= 40 HIDDEN                     |
|                                           |                   |                   |                                           |                                        |
| /# Switch to compiling state./            |                   |                   |                                           |                                        |
| ~rbracket();~  /# Compiled call./         | ---               | ---               | {{{compile(5D,])}}}                       | Call ]                                 |
| ~return.~                                 | RET               | C3                | ~C3~                                      | return                                 |

**** ;                                                             :noexport:

#+CAPTION: Subroutine ~';'~ (semicolon) wraps up a colon definition and goes back to interpreting.
#+LABEL: tbl:forth:semicolon
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                              | *Instruction*     | *Opcode*         | *Machine code*                                              | *Intention*          |
|-------------------------------------------+-------------------+------------------+-------------------------------------------------------------+----------------------|
| /# Define immediate:/ _~;~_               | ---               | ---              | {{{define(81,3B)}}}                                         | define ;             |
| /# In/Out: ~( C: -​- )~/                   |                   |                  |                                                             |                      |
| /#/                                       |                   |                  |                                                             |                      |
| /# Finalize a colon definition and/       |                   |                  |                                                             |                      |
| /# switch back to interpreting state./    |                   |                  |                                                             |                      |
|                                           |                   |                  |                                                             |                      |
| /# Write a RET instr. to ~OUTPUT~./       |                   |                  |                                                             |                      |
| ~op@AL ← 0xC3;~  /# RET opcode./          | MOV r8, /imm8/    | B0+rb /ib/       | ~B0~ /~C3~/                                                 | al = opcode ret      |
| ~[OUTPUT@RDI++] ← op@AL;~                 | STOS m8           | AA               | ~AA~                                                        | [rdi++] = al         |
|                                           |                   |                  |                                                             |                      |
| /# Clear the HIDDEN flag (~0x40~)/        |                   |                  |                                                             |                      |
| /# on the dictionary entry./              |                   |                  |                                                             |                      |
| ~RCX ← [LATEST];~                         | MOV r64, r/m64    | REX.W 8B /r      | ~48 8B~ {{{modrm(0C,00,001,100)}}} {{{sib(25,00,100,101)}}} | rcx = [Latest]       |
|                                           |                   |                  | \hookrightarrow {{{c(2)}}} {{{displ(28 00 00 10)}}}         |                      |
| ~RCX += 0x10;~                            | ADD r/m64, /imm8/ | REX.W 83 /​0 /ib/ | ~48 83~ {{{modrm(C1,11,000,001)}}} /10/                     | rcx += 10            |
| ~[flagRCX] &= 0b10111111;~                | AND r/m8, /imm8/  | 80 /4 /ib/       | ~80~ {{{modrm(21,00,100,001)}}} /BF/                        | [rcx] &= BF(~HIDDEN) |
|                                           |                   |                  |                                                             |                      |
| /# Switch to interpreting state./         |                   |                  |                                                             |                      |
| ~lbracket();~  /# Compiled call./         |                   |                  | {{{compile(5B,[)}}}                                         | Call [               |
| ~return.~                                 | RET               | C3               | ~C3~                                                        | return               |

**** .                                                             :noexport:

#+CAPTION: Subroutine ~'.'~ TODO.
#+LABEL: tbl:forth:dot
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                     | *Instruction*     | *Opcode*         | *Machine code*                          | *Intention*  |
| /# Define:/ _~.~_                | ---               | ---              | {{{define(01,2E)}}}                     | define .     |
| /# In/Out: ~( chr -​- )~/         |                   |                  |                                         |              |
| /#/                              |                   |                  |                                         |              |
| /# Non-standard name for ~C,~./  |                   |                  |                                         |              |
| /#/                              |                   |                  |                                         |              |
| /# Pop a byte off the stack and/ |                   |                  |                                         |              |
| /# write it to ~OUTPUT~./        |                   |                  |                                         |              |
|                                  |                   |                  |                                         |              |
| ~AL ← [R15]~                     | MOV r8, r/m8      | REX 8A /r        | ~41 8A~ {{{modrm(07,00,000,111)}}}      | al = [r15]   |
| ~R15 += 8;~                      | ADD r/m64, /imm8/ | REX.W 83 /0 /ib/ | ~49 83~ {{{modrm(C7,11,000,111)}}} /08/ | r15 += 8     |
| ~[RDI++] ← AL;~                  | STOS m8           | AA               | ~AA~                                    | [rdi++] = al |
| ~return.~                        | RET               | C3               | ~C3~                                    | return       |

**** LIT                                                           :noexport:

#+CAPTION: Subroutine ~'LIT'~ compiles a literal byte into a word definition.
#+LABEL: tbl:forth:lit
#+ATTR_LATEX: :align l|ll|lH
| *Pseudocode*                                                | *Instruction*     | *Opcode*         | *Machine code*                          | *Intention*             |
|-------------------------------------------------------------+-------------------+------------------+-----------------------------------------+-------------------------|
| /# Define immediate:/ _~LIT~_                               | ---               | ---              | {{{define(83,4C 49 54)}}}               | define LIT              |
| /# In/Out: ~( C: x -​- ) ( -- x )~/                          |                   |                  |                                         |                         |
| /#/                                                         |                   |                  |                                         |                         |
| /# Pop a byte off the data stack at compile time/           |                   |                  |                                         |                         |
| /# Compile it as the immediate byte of a PUSH/              |                   |                  |                                         |                         |
| /# instruction that inserts it on the data stack/           |                   |                  |                                         |                         |
| /# when the word being defined is executed./                |                   |                  |                                         |                         |
|                                                             |                   |                  |                                         |                         |
| /# Let ~lit~ be the top byte on the data stack./            |                   |                  |                                         |                         |
| /# We will generate three instructions that will/           |                   |                  |                                         |                         |
| /# effectively push ~lit~ on the data stack at/             |                   |                  |                                         |                         |
| /# execution time:/                                         |                   |                  |                                         |                         |
| /# – a SUB instruction that allocates a slot on/            |                   |                  |                                         |                         |
| /# the data stack;                                          |                   |                  |                                         |                         |
| /# – a pair of PUSH & POP instructions that copy/           |                   |                  |                                         |                         |
| /# ~lit~ to the newly allocated slot./                      |                   |                  |                                         |                         |
|                                                             |                   |                  |                                         |                         |
| /# 1. SUB instruction:/                                     |                   |                  |                                         |                         |
| /# – effect: ~R15 -= 8;~/                                   |                   |                  |                                         |                         |
| /# – instruction: SUB r/m64, imm8/                          |                   |                  |                                         |                         |
| /# – opcode: REX.W 83 /5 ib/                                |                   |                  |                                         |                         |
| /# – machine code: ~49 83~ {{{modrm(EF,11,101,111)}}} ~08~/ |                   |                  |                                         |                         |
| ~EAX ← 0x08EF8349;~                                         | MOV r32, /imm32/  | B8+rd /id/       | ~B8~ /49 83 EF 08/                      | eax = "r15 -= 8"        |
| ~[OUTPUT@RDI++4] ← EAX;~                                    | STOS m32          | AB               | ~AB~                                    | [rdi(++4)] = eax        |
|                                                             |                   |                  |                                         |                         |
| /# 2. PUSH instruction:/                                    |                   |                  |                                         |                         |
| /# – effect: ~push lit;~/                                   |                   |                  |                                         |                         |
| /# – instruction: PUSH imm8/                                |                   |                  |                                         |                         |
| /# – opcode: 6A ib/                                         |                   |                  |                                         |                         |
| /# – machine code: ~6A ??~ (imm. ignored for now)/          |                   |                  |                                         |                         |
| /# Here we only write 0x6A to ~OUTPUT~. Note that/          |                   |                  |                                         |                         |
| /# the three bytes of the next instruction are also/        |                   |                  |                                         |                         |
| /# loaded in EAX at this step, but not yet written./        |                   |                  |                                         |                         |
| ~EAX ← 0x078F416A;~                                         | MOV r32, /imm32/  | B8+rd /id/       | ~B8~ /6A 41 8F 07/                      | eax = push x; pop [r15] |
| ~[OUTPUT@RDI++] ← AL;~  /# Writes only 0x6A./               | STOS m8           | AA               | ~AA~                                    | [rdi++] = al            |
|                                                             |                   |                  |                                         |                         |
| /# 3. POP instruction:/                                     |                   |                  |                                         |                         |
| /# – effect: ~[R15] ← pop;~/                                |                   |                  |                                         |                         |
| /# – instruction: POP r/m64/                                |                   |                  |                                         |                         |
| /# – opcode: REX 8F /0/                                     |                   |                  |                                         |                         |
| /# – machine code: ~41 8F~ {{{modrm(07,00,000,111)}}}/      |                   |                  |                                         |                         |
| /# Here we write the immediate byte of the PUSH/            |                   |                  |                                         |                         |
| /# instruction (in AL) and the POP instruction/             |                   |                  |                                         |                         |
| /# (in the rest of EAX)./                                   |                   |                  |                                         |                         |
| ~AL ← [stack@R15];~                                         | MOV r8, r/m8      | REX 8A /r        | ~41 8A~ {{{modrm(07,00,000,111)}}}      | al = [r15]              |
| ~[OUTPUT@RDI++4] ← EAX;~                                    |                   |                  | ~AB~                                    | [rdi(++4)] = eax        |
|                                                             |                   |                  |                                         |                         |
| /# Pop ~lit~ off the data stack./                           |                   |                  |                                         |                         |
| ~stack@R15 += 8;~                                           | ADD r/m64, /imm8/ | REX.W 83 /​0 /ib/ | ~49 83~ {{{modrm(C7,11,000,111)}}} /08/ | r15 += 8                |
| ~return.~                                                   | RET               | C3               | ~C3~                                    | return                  |

**** xt=

#+CAPTION: Subroutine ~'xt='~ compares an execution token's name with a given string.
#+LABEL: tbl:forth:xt=
#+ATTR_LATEX: :align l|ll|l|lH
| *Pseudocode*                                       | *Instruction*     | *Opcode*         | *&*  | *Machine code*                                     | *Intention*             |
|----------------------------------------------------+-------------------+------------------+------+----------------------------------------------------+-------------------------|
| /# Define:/ _~xt=~_                                | ---               | ---              |      | {{{define(03,78 74 3D)}}}                          | define xt=              |
| /# In/Out:    ~( addr@RBP u@RAX xt@RBX~/           |                   |                  |      |                                                    |                         |
| /# {{{c(6)}}}​~-​- xt@RBX ?@RAX ?@RDI~/              |                   |                  |      |                                                    |                         |
| /# {{{c(8)}}}   ~FLAGS )~/                         |                   |                  |      |                                                    |                         |
| /#/                                                |                   |                  |      |                                                    |                         |
| /# Checks if execution token ~xt~ is/              |                   |                  |      |                                                    |                         |
| /# either zero or is not hidden and/               |                   |                  |      |                                                    |                         |
| /# its name matches the string given/              |                   |                  |      |                                                    |                         |
| /# by address ~addr~ and length ~u~./              |                   |                  |      |                                                    |                         |
|                                                    |                   |                  |      |                                                    |                         |
| {{{c(2)}}} /# Return if ~xt~ is zero (~ZF~ set)./  |                   |                  |      |                                                    |                         |
| {{{c(2)}}} ~if xt@RBX & xt@RBX != 0:~              | TEST r/m64, r64   | REX.W 85 /r      |      | ~48 85~ {{{modrm(DB,11,011,011)}}}                 | rbx(xt) ?               |
| {{{c(4)}}}   ~goto _nonzero;~                      | JNZ _rel8_        | 75 _cb_          |      | ~75~ {{{offset(01,01-00)}}}                        | +jump _nonzero if != 0  |
| {{{c(2)}}} ~return.~                               | RET               | C3               | ~00~ | ~C3~                                               | return                  |
| ~_nonzero:~                                        |                   |                  | ~01~ |                                                    | _nonzero:               |
| {{{c(2)}}} /# Save ~u~ in RCX; to be used later./  |                   |                  |      |                                                    |                         |
| {{{c(2)}}} ~u@RCX ← u@RAX;~                        | MOV r64, r/m64    | REX.W 8B /r      |      | ~48 8B~ {{{modrm(C8,11,001,000)}}}                 | rcx = rax(u)            |
| {{{c(2)}}} /# Point RSI to the flag field./        |                   |                  |      |                                                    |                         |
| {{{c(2)}}} ~RSI ← xt@RBX + 0x10;~                  | LEA r64,m         | REX.W 8D /r      |      | ~48 8D~ {{{modrm(73,01,110,011)}}} {{{displ(10)}}} | rsi = rbx(xt) + 10      |
| {{{c(2)}}} /# Extract flag and advance RSI/        |                   |                  |      |                                                    |                         |
| {{{c(2)}}} /# to the name field (used later)./     |                   |                  |      |                                                    |                         |
| {{{c(2)}}} ~flag@AL ← [RSI++];~                    | LODS m8           | AC               |      | ~AC~                                               | al = [rsi++]            |
| {{{c(2)}}} /# Return if hidden word (~ZF~ unset)./ |                   |                  |      |                                                    |                         |
| {{{c(2)}}} ~if flag@AL & 0x40 = 0:~                | TEST AL, /imm8/   | A8 /ib/          |      | ~A8~ /~40~/                                        | al & 40(HIDDEN) ?       |
| {{{c(4)}}}   ~goto _unhidden;~                     | JZ _rel8_         | 74 _cb_          |      | ~74~ {{{offset(01,0E-0D)}}}                        | +jump _unhidden if == 0 |
| {{{c(2)}}} ~return.~                               | RET               | C3               | ~0D~ | ~C3~                                               | return                  |
| ~_unhidden:~                                       |                   |                  | ~0E~ |                                                    | _unhidden:              |
| {{{c(2)}}} /# Keep only name length in RAX./       |                   |                  |      |                                                    |                         |
| {{{c(2)}}} ~length@RAX ← flag@RAX & 0x1F;~         | AND r/m64, /imm8/ | REX.W 83 /​4 /ib/ |      | ~48 83~ {{{modrm(E0,11,100,000)}}} /~1F~/          | rax &= 1F(Length)       |
| {{{c(2)}}} /# Return if length doesn't match/      |                   |                  |      |                                                    |                         |
| {{{c(2)}}} /# (~ZF~ unset)./                       |                   |                  |      |                                                    |                         |
| {{{c(2)}}} ~if length@RAX = u@RCX:~                | CMP r/m64, r64    | REX.W 39 /r      |      | ~48 39~ {{{modrm(C8,11,001,000)}}}                 | cmp rax, rcx            |
| {{{c(4)}}}   ~goto _lengthEq;~                     | JE _rel8_         | 74 _cb_          |      | ~74~ {{{offset(01,18-17)}}}                        | +jump _lengthEq if ==   |
| {{{c(2)}}} ~return.~                               | RET               | C3               | ~17~ | ~C3~                                               | return                  |
| ~_lengthEq:~                                       |                   |                  | ~18~ |                                                    | _lengthEq:              |
| {{{c(2)}}} /# Compare ~addr~ and ~name@RSI~/       |                   |                  |      |                                                    |                         |
| {{{c(2)}}} /# upto length ~u~./                    |                   |                  |      |                                                    |                         |
| {{{c(2)}}} ~addr@RDI ← addr@RBP;~                  | MOV r64, r/m64    | REX.W 8B /r      |      | ~48 8B~ {{{modrm(FD,11,111,101)}}}                 | rdi = rbp               |
| {{{c(2)}}} ~strncmp(name@RSI,~                     |                   |                  |      |                                                    |                         |
| {{{c(10)}}}        ~addr@RDI,~                     |                   |                  |      |                                                    |                         |
| {{{c(10)}}}        ~u@RCX);~  /# (Un)sets ~ZF~./   | REPE CMPS m8, m8  | F3 A6            |      | ~F3 A6~                                            | strings equal ?         |
| {{{c(2)}}} ~return.~                               | RET               | C3               |      | ~C3~                                               | return                  |


* Notes                                                            :noexport:

*** Sections that I should include in the thesis
- Call graph of the subroutines to show how they are related.
- Comparison between SmithForth, sectorforth, milliForth, other (?).
  
*** Useful Sections in the Intel Manual

Volume 2:
- 2.1 INSTRUCTION FORMAT FOR PROTECTED MODE, REAL-ADDRESS MODE, AND
  VIRTUAL-8086 MODE
- 2.2 IA-32E MODE
  - 2.2.1 REX Prefixes
- 3.1.1.1 Opcode Column in the Instruction Summary Table (Instructions without VEX Prefix)
- 3.1.1.3 Instruction Column in the Opcode Summary Table
- B.1 MACHINE INSTRUCTION FORMAT
  - B.1.4.2 Reg Field (reg) for 64-Bit Mode
  - B.1.4.7 Condition Test (tttn) Field
  - B.2.1 General Purpose Instruction Formats and Encodings for 64-Bit
    Mode

*** Maybe consider porting to RISC-V?
The Wikipedia [[https://en.wikipedia.org/wiki/RISC-V][article]] states that "RISC-V encourages academic usage"
and that "the simplicity of the integer subset permits basic student
exercises". This is probably the ideal ISA to target after
=x86-64=. All work done for x86 could be relegated to an appendix so
that it's not wasted.


* Footnotes
[fn:2] We reset the address counter since no jumps occur from the code
below this point to the code above or vice versa. This has the
advantage of keeping the counter value contained to one byte.

[fn:1] SmithForth misses the opcode here.
