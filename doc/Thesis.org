#+TITLE: From Assembly Forth to Lisp (and Back)
#+SUBTITLE: A Journey through the Imperative, Concatenative and Functional Realms
#+DATE: September 2024
#+AUTHOR: Andrei Dorian Duma
#+EMAIL: andrei-dorian.duma@s.unibuc.ro
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 29.2 (Org mode 9.6.15)

#+BIBLIOGRAPHY: references.bib
#+CITE_EXPORT:

#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:{} arch:headline
#+OPTIONS: author:nil broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:nil todo:t |:t

#+STARTUP: logdrawer

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,8pt]
#+LATEX_HEADER: \usepackage[margin=1in]{geometry}
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:
#+LATEX_ENGRAVED_THEME:
#+LATEX_COMPILER: pdflatex
# --- Nice author line ---
#+LATEX_HEADER: \usepackage{authblk}
#+LATEX_HEADER: \author[1]{Andrei Dorian Duma\thanks{andrei-dorian.duma@s.unibuc.ro}}
#+LATEX_HEADER: \affil[1]{Master of Distributed Systems}

# Additional options are set in `.dir-locals.el`.


#+begin_abstract
In this thesis we explore the process of implementing a high-level
programming language, beginning with only a limited set of
foundational elements: the =x86_64= architecture, several simple Linux
system calls, the GNU Assembler and the shell. We are interested in
how the level of abstraction is progressively increased by defining
higher-level linguistic constructs in terms of more primitive
ones. The approach will be pedagogical, favoring implementation
choices that are clear and understandable.

Our final goal is implementing a usable high-level language in the
LISP family, which we will call /quectoLISP/ (following the tradition
of prefixing names of small languages with SI submultiples). We
accomplish this in three stages. First, we write (in assembly) a
threaded interpreter for /quectoFORTH/, a small language inheriting
from Chuck Moore's Forth. Then, using this interpreter, we implement a
simple /quectoLISP/ interpreter providing the most useful language
features. Finally, we write a /quectoLISP/ compiler in /quectoLISP/
itself, running it in the stage-two interpreter. This compiler emits
=x86_64= assembly and becomes self-hosted, being able to compile
itself.
#+end_abstract
\clearpage

#+TOC: headlines 2
\clearpage


* Introduction

#+CAPTION: A table with line wrapping inside a cell.
+------+-----------------+
| Bla. | This            |
|      | is a            |
|      | test.           |
+------+-----------------+

** Our Objectives

#+begin_comment
What are the objectives of this thesis?
- Learn low-level processor programming, interpreter & compiler
  design.
- Understand how high-level languages are translated all the way to
  machine code; understand all intermediate steps.
- Find a short(est) path to high-level programming from nothing but
  machine code and Linux system calls.
#+end_comment

** An Incremental Approach

#+begin_comment
Why this approach?
- Reference inspiration paper: "An incremental approach to compiler
  construction".
#+end_comment


* Stage 1: A Forth Interpreter in Machine Code


** TODO Useful stuff

*** Linux Syscalls
#+CAPTION: Calling convention in 64-bit Linux.
#+LABEL:   tbl:syscall-calling-convention
|------------+---------------------------------------------------------------------|
| *Register* | *Usage*                                                             |
|------------+---------------------------------------------------------------------|
| RAX        | Syscall number (the identifier of the system call being requested). |
|------------+---------------------------------------------------------------------|
| RDI        | First argument to the syscall.                                      |
| RSI        | Second argument to the syscall.                                     |
| RDX        | Third argument to the syscall.                                      |
| R10        | Fourth argument to the syscall.                                     |
| R8         | Fifth argument to the syscall.                                      |
| R9         | Sixth argument to the syscall.                                      |
|------------+---------------------------------------------------------------------|

#+CAPTION: Linux system calls used in the Forth implementation.
#+LABEL:   tbl:syscalls
| *syscall* | *name*       | *%rax* | *%rdi*              | *%rsi*            | *%rdx*         |
|-----------+--------------+--------+---------------------+-------------------+----------------|
|         0 | read         | =0x00= | =unsigned int fd=   | =char *buf=       | =size_t count= |
|         1 | write        | =0x01= | =unsigned int fd=   | =const char *buf= | =size_t count= |
|        12 | brk          | =0x0C= | =unsigned long brk= | –                 | –              |
|        60 | exit         | =0x3C= | =int error_code=    | –                 | –              |

#+CAPTION: ELF header for an =x86-64= Linux executable.
|---------------------------+----------------------------------------------------------------------------------|
| ~7F 45 4C 46 ·· ·· ·· ··~ | ~e_ident[EI_MAG]~: ELF magic number.                                             |
| ~·· ·· ·· ·· 02 ·· ·· ··~ | ~e_ident[EI_CLASS]~: =1= → 32-bit, _=2= → 64-bit_.                               |
| ~·· ·· ·· ·· ·· 01 ·· ··~ | ~e_ident[EI_DATA]~: _=1= → little-endian_, =2= → big-endian.                     |
| ~·· ·· ·· ·· ·· ·· 01 ··~ | ~e_ident[EI_VERSION]~: ELF header version; must be =1=.                          |
| ~·· ·· ·· ·· ·· ·· ·· 00~ | ~e_ident[EI_OSABI]~: Target OS ABI; =ELFOSABI_NONE= (=0=) is fine for Linux.     |
|---------------------------+----------------------------------------------------------------------------------|
| ~00 ·· ·· ·· ·· ·· ·· ··~ | ~e_ident[EI_ABIVERSION]~: ABI version; should be =0= for Linux.                  |
| ~·· 00 00 00 00 00 00 00~ | ~e_ident[EI_PAD]~: Padding; unused; should be =0=.                               |
|---------------------------+----------------------------------------------------------------------------------|
| ~02 00 ·· ·· ·· ·· ·· ··~ | ~e_type~: Object file type; =2= → executable.                                    |
| ~·· ·· 3E 00 ·· ·· ·· ··~ | ~e_machine~: Instruction set architecture; =0x03= → =x86=, _=0x3E= → =x86-64=_.  |
| ~·· ·· ·· ·· 01 00 00 00~ | ~e_version~: ELF identification version; must be =1=.                            |
|---------------------------+----------------------------------------------------------------------------------|
| ~78 00 40 00 00 00 00 00~ | ~e_entry~: Memory address of entry point (where process starts).                 |
| ~40 00 00 00 00 00 00 00~ | ~e_phoff~: File offset of program headers; =0x34= → =32-bit=, _=0x40= → 64-bit_. |
| ~00 00 00 00 00 00 00 00~ | ~e_shoff~: File offset section headers.                                          |
|---------------------------+----------------------------------------------------------------------------------|
| ~00 00 00 00 ·· ·· ·· ··~ | ~e_flags~: 0 for the =x86-64= architecture.                                      |
| ~·· ·· ·· ·· 40 00 ·· ··~ | ~e_ehsize~: Size of this header; =0x34= → 32-bit, _=0x40= → 64-bit_.             |
| ~·· ·· ·· ·· ·· ·· 38 00~ | ~e_phentsize~: Size of each program header; =0x20= → 32-bit, _=0x38= → 64-bit_.  |
|---------------------------+----------------------------------------------------------------------------------|
| ~01 00 ·· ·· ·· ·· ·· ··~ | ~e_phnum~: Number of program headers.                                            |
| ~·· ·· 40 00 ·· ·· ·· ··~ | ~e_shentsize~: Size of each section header; =0x28= → 32-bit, _=0x40= → 64-bit_.  |
| ~·· ·· ·· ·· 00 00 ·· ··~ | ~e_shnum~: Number of section headers.                                            |
| ~·· ·· ·· ·· ·· ·· 00 00~ | ~e_shstrndx~: Index of section header containing section names.                  |
|---------------------------+----------------------------------------------------------------------------------|

#+CAPTION: ELF Program Header.
| ~01 00 00 00 ·· ·· ·· ··~ | ~p_type~: Segment type; =1= → loadable.                                  |
| ~·· ·· ·· ·· 07 00 00 00~ | ~p_flags~: Segment-dependent flags (1: X, 2: W, 4: R)                    |
| ~00 00 00 00 00 00 00 00~ | ~p_offset~: File offset where segment begins                             |
| ~00 00 40 00 00 00 00 00~ | ~p_vaddr~: Virtual address of segment in memory (amd64: 00400000)        |
| ~00 00 00 00 00 00 00 00~ | ~p_paddr~: Physical address of segment, unspecified by 386 supplement    |
| ~02 1E 01 00 00 00 00 00~ | ~p_filesz~: Size in bytes of the segment in the file image (see make.sh) |
| ~00 00 C0 7F 00 00 00 00~ | ~p_memsz~: (>= filesz) Size in bytes of the segment in memory            |
| ~00 10 00 00 00 00 00 00~ | ~p_align~: 1000 for x86                                                  |

*** Useful Prefixes
| Prefix                | Hex |
|-----------------------+-----|
| REPNE/REPNZ           | F2  |
| REP, REPE/REPZ        | F3  |
| Operand-size override | 66  |
| Address-size override | 67  |

*** Useful x86-64 Instructions
| Mnemonic | Opcode (hex) |
|----------+--------------|
| CALL     | =E8=         |
|          | =FF=         |

*** Useful Sections in the Intel Manual
Volume 2:
- 2.1 INSTRUCTION FORMAT FOR PROTECTED MODE, REAL-ADDRESS MODE, AND
  VIRTUAL-8086 MODE
- 2.2 IA-32E MODE
  - 2.2.1 REX Prefixes
- 3.1.1.1 Opcode Column in the Instruction Summary Table (Instructions without VEX Prefix)
- 3.1.1.3 Instruction Column in the Opcode Summary Table
- B.1 MACHINE INSTRUCTION FORMAT
  - B.1.4.2 Reg Field (reg) for 64-Bit Mode
  - B.1.4.7 Condition Test (tttn) Field
  - B.2.1 General Purpose Instruction Formats and Encodings for 64-Bit
    Mode

* Stage 2: A LISP Interpreter in Forth


* Stage 3: A LISP Compiler in LISP


* Conclusion


* Notes

:LOGBOOK:
- Note taken on [2024-07-21 Sun 15:34] \\
  As per article [[https://fev.al/posts/work-journal/]["Use a work journal"]], I'll try to keep all
  thesis-related notes here, writing down my thoughts as often as
  possible. Hopefully this will act as a cache and as an organizational
  tool.
:END:
