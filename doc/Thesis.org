#+TITLE: From Assembly Forth to Lisp (and Back)
#+SUBTITLE: A Journey through the Imperative, Concatenative and Functional Realms
#+DATE: September 2024
#+AUTHOR: Andrei Dorian Duma
#+EMAIL: andrei-dorian.duma@s.unibuc.ro
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 29.2 (Org mode 9.6.15)

#+BIBLIOGRAPHY: references.bib
#+CITE_EXPORT:

#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:{} arch:headline
#+OPTIONS: author:nil broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:nil todo:t |:t

#+STARTUP: logdrawer

#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper]
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:
#+LATEX_ENGRAVED_THEME:
#+LATEX_COMPILER: pdflatex
# --- Nice author line ---
#+LATEX_HEADER: \usepackage{authblk}
#+LATEX_HEADER: \author[1]{Andrei Dorian Duma\thanks{andrei-dorian.duma@s.unibuc.ro}}
#+LATEX_HEADER: \affil[1]{Master of Distributed Systems}

# Additional options are set in `.dir-locals.el`.


#+BEGIN_ABSTRACT
In this thesis we explore the process of implementing a high-level
programming language, beginning with only a limited set of
foundational elements: the =x86_64= architecture, several simple Linux
system calls, the GNU Assembler and the shell. We are interested in
how the level of abstraction is progressively increased by defining
higher-level linguistic constructs in terms of more primitive
ones. The approach will be pedagogical, favoring implementation
choices that are clear and understandable.

Our final goal is implementing a usable high-level language in the
LISP family, which we will call /quectoLISP/ (following the tradition
of prefixing names of small languages with SI submultiples). We
accomplish this in three stages. First, we write (in assembly) a
threaded interpreter for /quectoFORTH/, a small language inheriting
from Chuck Moore's Forth. Then, using this interpreter, we implement a
simple /quectoLISP/ interpreter providing the most useful language
features. Finally, we write a /quectoLISP/ compiler in /quectoLISP/
itself, running it in the stage-two interpreter. This compiler emits
=x86_64= assembly and becomes self-hosted, being able to compile
itself.
#+END_ABSTRACT
\clearpage

#+TOC: headlines 2
\clearpage


* Introduction

** Our Objectives

** An Incremental Approach


* Stage 1: A Forth Interpreter in Assembly

** Inheriting from JonesFORTH and History

** High-level System Design

** The Inner Interpreter and Other Primitives

** The Outer Interpreter and Other Constructs

** TODO Useful stuff

#+CAPTION: Linux system calls used in the Forth implementation.
#+LABEL:   tbl:syscalls
| *syscall* | *name*       | *%rax* | *%rdi*              | *%rsi*            | *%rdx*         |
|-----------+--------------+--------+---------------------+-------------------+----------------|
|         0 | read         | =0x00= | =unsigned int fd=   | =char *buf=       | =size_t count= |
|         1 | write        | =0x01= | =unsigned int fd=   | =const char *buf= | =size_t count= |
|        12 | brk          | =0x0C= | =unsigned long brk= | –                 | –              |
|        60 | exit         | =0x3C= | =int error_code=    | –                 | –              |

| 7F | 45 | 4C | 46 |    |    |    |    | e_ident[EI_MAG]: ELF magic number                  |
|    |    |    |    | 02 |    |    |    | e_ident[EI_CLASS]: 1: 32-bit, 2: 64-bit            |
|    |    |    |    |    | 01 |    |    | e_ident[EI_DATA]: 1: little-endian, 2: big-endian  |
|    |    |    |    |    |    | 01 |    | e_ident[EI_VERSION]: ELF header version; must be 1 |
|    |    |    |    |    |    |    | 00 | e_ident[EI_OSABI]: Target OS ABI; should be 0      |

#+begin_src
  # Linux will run a computing job given the name of an executable
  # file. An executable file contains machine code for the processor and
  # information for the operating system about the layout of the file
  # and the dimensions of the job. Working without the usual development
  # tools, we write this information by hand.

  7F 45 4C 46               # e_ident[EI_MAG]: ELF magic number
	      02            # e_ident[EI_CLASS]: 1: 32-bit, 2: 64-bit
		 01         # e_ident[EI_DATA]: 1: little-endian, 2: big-endian
		    01      # e_ident[EI_VERSION]: ELF header version; must be 1
		       00   # e_ident[EI_OSABI]: Target OS ABI; should be 0
  00                        # e_ident[EI_ABIVERSION]: ABI version; 0 is ok for Linux
     00 00 00 00 00 00 00   # e_ident[EI_PAD]: unused, should be 0
  02 00                     # e_type: object file type; 2: executable
	3E 00               # e_machine: instruction set architecture; 3: x86, 3E: amd64
	      01 00 00 00   # e_version: ELF identification version; must be 1
  78 00 40 00 00 00 00 00   # e_entry: memory address of entry point (where process starts)
  40 00 00 00 00 00 00 00   # e_phoff: file offset where program headers begin (34: 32-bit, 40: 64)
  00 00 00 00 00 00 00 00   # e_shoff: file offset where section headers begin
  00 00 00 00               # e_flags: 0 for x86
	      40 00         # e_ehsize: size of this header (34: 32-bit, 40: 64-bit)
		    38 00   # e_phentsize: size of each program header (20: 32-bit, 38: 64-bit)
  01 00                     # e_phnum: number of program headers
	40 00               # e_shentsize: size of each section header (28: 32-bit, 40: 64-bit)
	      00 00         # e_shnum: number of section headers
		    00 00   # e_shstrndx: index of section header containing section names

  # ============= ELF PROGRAM HEADER

  01 00 00 00               # p_type: segment type; 1: loadable
	      07 00 00 00   # p_flags: segment-dependent flags (1: X, 2: W, 4: R)
  00 00 00 00 00 00 00 00   # p_offset: file offset where segment begins
  00 00 40 00 00 00 00 00   # p_vaddr: virtual address of segment in memory (amd64: 00400000)
  00 00 00 00 00 00 00 00   # p_paddr: physical address of segment, unspecified by 386 supplement
  02 1E 01 00 00 00 00 00   # p_filesz: size in bytes of the segment in the file image (see make.sh)
  00 00 C0 7F 00 00 00 00   # p_memsz: (>= filesz) size in bytes of the segment in memory
  00 10 00 00 00 00 00 00   # p_align: 1000 for x86
#+end_src


* Stage 2: A LISP Interpreter in Forth


* Stage 3: A LISP Compiler in LISP


* Conclusion


:LOGBOOK:
- Note taken on [2024-07-21 Sun 15:34] \\
  As per article [[https://fev.al/posts/work-journal/]["Use a work journal"]], I'll try to keep all
  thesis-related notes here, writing down my thoughts as often as
  possible. Hopefully this will act as a cache and as an organizational
  tool.
:END:
