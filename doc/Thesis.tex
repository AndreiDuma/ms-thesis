% Created 2024-09-10 Tue 20:05
% Intended LaTeX compiler: pdflatex
\documentclass[a4paper,12pt,final]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage{geometry}
\newgeometry{left=2.5cm, right=2.5cm, top=3.2cm, bottom=3.5cm}
\restoregeometry
\usepackage{setspace}
\onehalfspacing
\usepackage{changepage}
\usepackage{authblk}
\author{\vspace{1cm} \textbf{Author:} Andrei Dorian Duma \\\vspace{0.1cm} \textbf{Coordinator:} Lect.\hspace{0.18cm}dr.\hspace{0.18cm}Gianina Georgescu \vspace{5cm}}
\affil{Master of Distributed Systems \\\vspace{0.3cm} September 2024}
\usepackage{array}
\newcolumntype{H}{>{\setbox0=\hbox\bgroup}c<{\egroup}@{}}
\pagenumbering{gobble}
\date{}
\title{From x86-64 Forth to RISC-V\\\medskip
\large Towards an Accessible RISC-V Forth Implementation }
\hypersetup{
 pdfauthor={Andrei Dorian Duma},
 pdftitle={From x86-64 Forth to RISC-V},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 29.2 (Org mode 9.6.15)}, 
 pdflang={English}}
\makeatletter
\newcommand{\citeprocitem}[2]{\hyper@linkstart{cite}{citeproc_bib_item_#1}#2\hyper@linkend}
\makeatother

\usepackage[notquote]{hanging}
\begin{document}

\begin{figure}[!htb]
    \centering
    \vspace{3cm}
    \begin{minipage}{0.16\textwidth}
        \includegraphics[width=\linewidth]{img/logo-ub.png}
    \end{minipage}
    \begin{minipage}{0.6\textwidth}
        \large
        % \vspace{0.2cm}
        \begin{center}
            \textbf{
                \textsc{
                    \hspace{0.015cm} University of Bucharest}}
        \end{center}
        % \vspace{0.05cm}
        \begin{center}
            \textbf{
                \textsc{
                Faculty of Mathematics \\
                \hspace{0.45cm} and Informatics}}
        \end{center}
    \end{minipage}
    \begin{minipage}{0.175\textwidth}
        \includegraphics[width=\linewidth]{img/logo-fmi.png}
    \end{minipage}

    \vspace{4cm} % space between logo and title
    \maketitle
\end{figure}

\clearpage \ \clearpage


\vspace*{\fill}

\subsubsection*{Declaration of Authenticity}
I, Andrei Dorian Duma, candidate for the dissertation exam in the
September 2024 session at the Faculty of Mathematics and Computer
Science, in the “Distributed Systems” study program, hereby declare
that the present work is the result of my own effort, based on my
research and information obtained from sources that have been cited
and indicated, in accordance with ethical standards, in footnotes and
the bibliography. I declare that I have not tacitly or illegally used
the work of others, and that no part of this thesis infringes on the
intellectual property rights of any other individual or legal
entity. I declare that this work has not been previously submitted in
this form to any higher education institution for the purpose of
obtaining a scientific or academic degree.

\vspace{1cm}

\subsubsection*{Declarație de Autenticitate}
Subsemnatul Andrei Dorian Duma, candidat la examenul de disertație,
sesiunea Septembrie 2024, la Facultatea de Matematică și Informatică,
programul de studii „Sisteme Distribuite”, declar pe propria
răspundere că lucrarea de față este rezultatul muncii mele, pe baza
cercetărilor mele și pe baza informațiilor obținute din surse care au
fost citate și indicate, conform normelor etice, în note și în
bibliografie. Declar că nu am folosit în mod tacit sau ilegal munca
altora și că nicio parte din teză nu încalcă drepturile de
proprietate intelectuală ale altcuiva, persoană fizică sau
juridică. Declar că lucrarea nu a mai fost prezentată sub această
formă vreunei instituții de învățământ superior în vederea obținerii
unui grad sau titlu științific ori didactic.

\vspace{2cm}

\noindent
September 2024 \hfill{} Andrei Dorian Duma

\vspace{3cm}

\vspace*{\fill}
\clearpage \ \clearpage


\vspace*{\fill}

\renewcommand{\abstractname}{Abstract}
\begin{abstract}
In this thesis we present the implementation of a usable Forth system,
built using only RISC-V machine code and the Linux operating system as
foundations.  We begin by justifying the need for accessible
programming language implementations, discussing desirable features in
educational compilers.  Having selected Forth as our language of
choice for an educational language implementation, we review existing
Forth systems and we motivate why creating a RISC-V port is a
worthwhile task.  Next we thoroughly examine SmithForth, a
high-quality Forth system for the x86-64 architecture.  After
understanding its principles, we port it to RISC-V, adapting it to our
purposes.  Finally, we extend this Forth system in Forth itself: we
write a RISC-V assembler, we provide useful arithmetic and logic
operators plus conditional and looping constructs.  We complete our
demonstration with a Forth implementation of FizzBuzz, showing the
usability of the system.
\end{abstract}

\vspace{0.7cm}

\renewcommand{\abstractname}{Rezumat}
\begin{abstract}
În această lucrare prezentăm implementarea unui sistem Forth scris
direct în cod mașină pentru architectura RISC-V și sistemul de operare
Linux.  Începem prin a justifica necesitatea implementărilor
accesibile de limbaje de programare și discutăm caracteristicile de
dorit într-un compilator didactic.  Propunem realizarea unui nou
sistem Forth pentru architectura RISC-V, cu pornire de la nivelul cel
mai scăzut al codului mașină.  În continuare, examinăm în detaliu
SmithForth, un sistem Forth excelent dezvoltat pentru arhitectura
x86-64.  După înțelegerea principiilor sale, îl portăm la RISC-V,
adaptându-l scopurilor noastre.  În final, extindem sistemul Forth
rezultat chiar în Forth: scriem un asamblor pentru RISC-V, implementăm
operatori aritmetici și logici și structuri condiționale și de
ciclare.  Încheiem cu o rezolvare în Forth a problemei FizzBuzz,
demonstrând utilizabilitatea sistemului nostru.
\end{abstract}

\vspace{1cm}
\vspace*{\fill}
\clearpage \ \clearpage


\vspace*{\fill}

\subsubsection*{Acknowledgements}
I would like to thank my partner, Iulia, for her support and
encouragement throughout the development of this project.  Our
clarifying conversations and her insightful suggestions have greatly
improved the quality of this work.

I am also deeply grateful to my parents for instilling in me a sense
of curiosity that has guided me throughout both my academic and
personal journeys.

\vspace{4cm}
\vspace*{\fill}
\clearpage \ \clearpage


\setcounter{tocdepth}{3}
\tableofcontents
\clearpage

\pagenumbering{arabic}
\setcounter{page}{11}


\section{Introduction}
\label{sec:org57c56ea}

Modern computing relies on complex toolchains that translate
high-level programming languages to the machine code that is run by
computer processors.  Such a toolchain might include, for example, a
compiler, an assembler and a linker.  The compiler might in turn be
composed of a frontend that parses and converts the input source code
into an intermediate representation (IR) and a backend that further
translates this IR to assembly code.  The assembler and the linker
continue this process by encoding instructions, calculating relative
offsets for jumps and branches, producing object files and finally
resolving symbol addresses when combining these files into an
executable.

This machinery serves to bridge the wide abstraction gap between a
high-level programming language and the low-level machine code into
which it is translated.  Although convenient for developing useful
computer programs, these tools bring a complexity that can obscure the
understanding of the basic processes involved in programming a
computer.  A modern toolchain typically supports multiple target
architecures and operating systems, implements a plethora of
optimizations at different levels and has the source code of its own
components split across many codebases.  The Rust compiler \texttt{rustc},
for example, handles lexing, parsing into an abstract syntax tree, AST
lowering to a \emph{High-Level Intermediate Representation} (HIR) for type
inference and checking, lowering to a \emph{Mid-level Intermediate
Representation} (MIR) for various optimizations, finally converting
the MIR to LLVM IR to be further processed by the LLVM compiler
backend \citeprocitem{1}{[1]}.

It would be understandable for a student of computer science to be
left in awe in front of such systems.  In fact, Abdulaziz Ghuloum long
ago observed that ``compilers are perceived to be magical artifacts,
carefully crafted by the wizards, and unfathomable by the mere
mortals'' \citeprocitem{2}{[2]}.  In his 2006 paper \emph{``An Incremental
Approach to Compiler Construction''}, Ghuloum further notes that
``real-life compilers are too complex to serve as an educational
tool''.  We were inspired by his understandable-by-design Scheme
compiler to further pursue the topic of understandable programming
language implementation.

\subsection{Forth Towards an Understandable Compiler}
\label{sec:orgdea754d}

Most compilers designed for education (Ghuloum's included) generate
assembly code intended to be further processed by an external
assembler and linker.  Furthermore, many implementations use
functionality provided by the C standard library instead of directly
interfacing with the operating system (or with the hardware).  In
contrast, we believe that an educational language implementation
should cover and explain all transformation stages occurring between
high-level syntax and machine code bits.

Choosing the right language to implement is also essential if building
a compiler for it is to convey useful knowledge (or even wisdom) to
the student.  The language should be simple enough so that its
compiler does not grow beyond comprehension.  Still, it should be rich
enough to expose the student to the implementation of general
computing concepts such as conditional execution, looping, memory
allocation for variables and constants, program composability through
some subroutine calling mechanism and so on.  Preferably it should be
an established language with well-understood semantics, as this avoids
the often unforeseen subtleties of language design and allows mining
previous literature for implementation ideas and techniques.

Given these criteria, we have considered three languages known for
allowing relatively simple implementations: Forth, Lisp and Lua.  Each
is representative of a whole class of programming languages and makes
different and significant choices in their design.

\emph{Forth} was invented in 1968 by Charles Moore ``to increase programmer
productivity without sacrificing machine efficiency''
\citeprocitem{3}{[3]}, \citeprocitem{4}{[4]}.  The language
follows a stack-based approach, using a postfix notation.  Its
implicit stack manipulation and dictionary-based compilation allow for
both minimalist syntax and powerful extensibility.  Forth allows
unrestricted access to computer registers and memory.  The evolution
of the language is currently steered by the \emph{Forth 200x
Standardisation Committee} working on the \emph{Forth 2012 Standard}
\citeprocitem{3}{[3]}.  There are many Forth implementations of
varying size and complexity to draw inspiration from.

\emph{Lisp} denotes a family of related languages rather than a specific
language.  The original LISP was created by John McCarthy at MIT
starting in 1958 \citeprocitem{5}{[5]}.  Modern incarnations of
Lisp include Scheme (used by Ghuloum in his paper) and Common Lisp.
Lisp languages use a very regular syntax based on S-expressions
(parenthesized lists).  Lisp's meta-programming facilities (macros)
and highly dynamic nature make it ideal for expressing high-level
concepts as linguistic constructs, effectively adapting the language
to better suit the problem that requires solving
\citeprocitem{6}{[6]}.  Similarly to Forth, Lisp has given rise to
many and diverse open-source implementations.

\emph{Lua} is the most recent of the three languages, having been created
by Roberto Ierusalimschy, Luiz Henrique de Figueiredo and Waldemar
Celes in 1993 at PUC-Rio \citeprocitem{7}{[7]}.  Lua has a simple
procedural syntax and uses associative arrays for data description and
extensibility.  Typically it is compiled to bytecode at run-time which
is then interpreted by a virtual machine or, in the case of the LuaJIT
implementation, is just-in-time compiled \citeprocitem{8}{[8]}.

In the end Forth's small ``core'', extremely minimal syntax and
low-level philosophy made it the preferred choice for an educational
programming language implementation.  For readers not familiar with
Forth, we recommend Leo Brodie's classic books \emph{``Starting Forth''}
\citeprocitem{9}{[9]} and \emph{``Thinking Forth''}
\citeprocitem{10}{[10]}. The already mentioned \emph{Forth 2012
Standard} is also an excellent reference for words expected to be
present in a Forth system. We continue by reviewing several Forth
implementations.


\subsection{A Brief Survey of Forth Implementations}
\label{sec:orgee39aaf}

\emph{Gforth} \citeprocitem{11}{[11]} is a major open-source implementation of the
Forth programming language.  It conforms to the \emph{Forth 2012 Standard}
and supports multiple target architectures.  Being featureful and
performant, it is a rather complex compiler.  Its core is implemented
in C with many words and libraries being written in Forth itself.

There are also many implementations created by Forth enthusiasts for
educational or experimentation purposes.  \emph{JONESFORTH}
\citeprocitem{12}{[12]} is one popular such Forth, written by Richard
W.M. Jones as one file of x86 assembly targeting \texttt{as}, the GNU
Assembler, and one file of Forth code.  The former sets up a minimal
Forth, whereas the latter further defines many standard Forth words,
including control structures, I/O utilities etc.  JONESFORTH makes
extensive use of assembler macros for reducing boilerplate around word
definitions.  The code is thoroughly commented, proving to be an
excellent resource for learning the inner workings of a Forth system.
It is notable that it assumes a Linux host, but no C standard library
--- all interaction with the OS is done through system calls.
JONESFORTH does not attempt to bootstrap Forth as quickly as possible,
with the consequence that its assembly part is longer than it could
be.

\emph{Sectorforth} \citeprocitem{13}{[13]} by Cesar Blum is ``a 16-bit x86
Forth that fits entirely within a boot sector (512 bytes)''.  It is
written in assembly for the NASM assembler and assumes no operating
system.  It is extremely minimal, providing only several primitives on
top of which a more featureful Forth can be built.  \emph{MilliForth}
\citeprocitem{14}{[14]} takes sectorforth's minimalism even further,
reducing the machine code size to 340 bytes.

\emph{SmithForth} \citeprocitem{15}{[15]} is a recent Forth by David Smith,
running on x86-64 Linux systems.  It is special among other
implementations because it bootstraps Forth using only machine code.
In its author's own words, it uses ``none of the usual tools from the
world of C, not even an assembler''.  It consists of a \texttt{.dmp} file
containing machine code as commented hexadecimal bytes and a \texttt{.fs}
file containing Forth code to be run once a minimal system was
bootstrapped.  The hexadecimal bytes are converted into machine code
using the Linux \texttt{xxd} command.  Since SmithForth targets Linux, the
resulting executable has to be a valid ELF executable, so an ELF file
header and an ELF program header are included.  It is remarkable that
SmithForth conforms to the \emph{Forth 2012 Standard}, given how small an
implementation it is.

Several other sources about implementing Forth systems were consulted.
We mention Loeliger's \emph{``Threaded Interpretive Languages''} (1981), a
full implementation guide for the Zilog Z80 processor
\citeprocitem{16}{[16]}; Peter M. Kogge's \emph{``An Architectural Trail
to Threaded-Code Systems''} (1982), which explains the design of a
classical implementation of Forth \citeprocitem{17}{[17]}; Anton
Ertl's \emph{``Threaded Code Variations and Optimizations''} (2002), which
compares different code threading techniques, with a focus on
performance \citeprocitem{18}{[18]}.

Researching the Forth implementations and resources above led us to
the following impressions:
\begin{itemize}
\item We liked \emph{SmithForth}'s approach of starting with machine code,
because it makes explicit the steps that transform an instruction as
intended by the programmer into machine code bits executable by an
actual computer processor.
\item \emph{JONESFORTH}'s self-documenting nature through extensive source code
comments is something that we consider essential in an
understandable language implementation.
\item We admired \emph{sectorforth}'s and \emph{milliforth}'s quest for minimalism
in so far as it leads to elegant and othogonal primitives on which
to base a language. Beyond this purpose lie obscurity and
complexity, which we're trying to avoid.
\item More than basic adherence to the Forth Standard is not a
goal. Instead, we only aim for basic system usability, such as
general purpose arithmetic and control flow, definition of variables
and constants, printing and so on.
\item The x86 architecture chosen by all surveyed assembly implementations
is not ideal for conveying the fundamental computing principles at
the heart of implementing a programming language.  Its age is
showing in the accumulated historical cruft, which hinder a
beginner's understanding of the essential.  We observe that only the
\emph{``Volume 2: Instruction Set Reference''} of Intel's most recent
manuals amounts to over 2500 pages \citeprocitem{19}{[19]}.
As will be described later, the x86 architecture requires
complicated encoding schemes with many edge cases, making it
difficult for the novice to even select a collection of key
instructions to use in their implementation.
\end{itemize}

We think \emph{SmithForth} is an excellent starting point towards a Forth
implementation that focuses on understandability.  We propose a number
of modifications that aim towards this goal:
\begin{itemize}
\item More detailed pseudocode should accompany the source code.
\item The byte encoding of instructions should be made more explicit,
making clear how an instruction as chosen by the programmer from the
processor's manual is converted to its final binary representation.
\item The current Forth code, which currently sets up a standard-compliant
system, should be replaced with a simpler, shorter and more readable
alternative.
\item The implementation should target a processor architecture that was
designed with education in mind.  The instructions should be few,
simple and orthogonal.  As we will show later, be believe the modern
RISC-V architecture is ideally suited for this purpose.
\end{itemize}

We continue by describing the general organization of SmithForth.


\subsection{A Quick Overview of SmithForth}
\label{sec:org28d2a14}

\subsubsection{Source Code Layout}
\label{sec:org9da1528}

SmithForth is bootstrapped from machine code in several stages.  The
first two stages occur in file \texttt{.dmp}, which is written as hexadecimal
bytes interspersed with comments.  Here is a code sample from David
Smith's original \texttt{SForth.dmp}:

\fontsize{9ptpt}{10.800000pt}\selectfont

\begin{verbatim}
99 05 50 41 52 53 45 ##### PARSE ( cl dl "ccc<char>" -- rbp=addr rax=u )
49 C7 C1 00 00 00 10     # r9 = VAR              mov r/m64, imm32    REX.W C7 /0 id   11 000 001
49 8B 69 10              # rbp = [>IN]           mov r64, r/m64      REX.W 8B /r      01 101 001
99 73                    # Call seek				         		      
49 8B 41 10              # rax = [>IN]           mov r64, r/m64      REX.W 8B /r      01 000 001
73 04                    #+jump _end if U>=   00 jae rel8            73 cb	      
49 FF 41 10              # [>IN]++               inc r/m64           REX.W FF /0      01 000 001
# _end:                  #                    04		         		      
48 29 E8                 # rax -= rbp            sub r/m64, r64      REX.W 29 /r      11 101 000
49 03 69 08              # rbp += [TIB]          add r64, r/m64      REX.W 03 /r      01 101 001
C3                       # return                ret                 C3    
\end{verbatim}
\normalsize

The section above defines the Forth word \texttt{PARSE}.  Its \emph{stack effects}
are described in standard Forth notation \texttt{( cl dl "ccc<char>" -{}-{}
rbp=addr rax=u )}​, here extended for register operations.  The left
column contains hexadecimal bytes, while everything beyond the first
\texttt{\#} on each line represents a comment.  It is worth noting the three
byte sequences beginning with byte \texttt{99}; these are special and will be
explained shortly.  Five explanation columns follow the bytes: the
first describes the intention of the current line; the second tracks
instruction addresses to allow for calculating relative offsets; the
third references the x86-64 instruction as documented in the Intel
manual; the fourth shows the byte encoding of the instruction, again
using Intel conventions; the fifth optionally shows the ModR/M and/or
SIB bytes often required in x86 instruction encodings.

This \texttt{.dmp} file is turned into an executable file by first \texttt{cut}​ting
out the comments and then passing the remaining hexadecimal bytes to
Linux command \texttt{xxd} for conversion into binary form:

\fontsize{10ptpt}{12.000000pt}\selectfont

\begin{verbatim}
$ cut SForth.dmp -d'#' -f1 | xxd -p -r >SForth0
\end{verbatim}
\normalsize

The other source code file in SmithForth is \texttt{system.fs}.  Its first
two lines, included below, define standard Forth words \texttt{1+} and \texttt{1-}
by directly generating the corresponding machine code.  The comments
reflect this, highlighting the same encoding information as the \texttt{.dmp}
file:

\fontsize{9ptpt}{10.800000pt}\selectfont

\begin{verbatim}
: 1+ ( n|u -- n'|u' )  [ 49 . FF . 07 . ] ;   \ [r15]++   inc r/m64   REX.W FF /0    00 000 111
: 1- ( n|u -- n'|u' )  [ 49 . FF . 0F . ] ;   \ [r15]--   dec r/m64   REX.W FF /1    00 001 111
\end{verbatim}
\normalsize

The \texttt{system.fs} file is appended as-is to the binary, cleverly
generating a half-machine-code, half-Forth-text executable.  The
machine code bootstraps a basic system which is then directed to
interpret the Forth code, thus completing the implementation.  David
Smith provides a simple \texttt{make.sh} shell script \citeprocitem{15}{[15]} that
performs these build steps, additionally taking care to fill in the
executable size in the ELF file header (described below).

\subsubsection{The x86-64 Instruction Set Architecture}
\label{sec:org24d6fef}

David Smith implemented SmithForth for the x86-64 architecture.  While
ubiquitous on personal computers, we believe this architecture is not
well-suited for building an educational language implementation ``from
scratch''.

The x86-64 instruction set architecture (ISA) is the 64-bit extension
of the x86 ISA, which in turn traces its origins to the 8086
microprocessor released by Intel in 1978.  Its 45 years of history
have witnessed the evolution from 16-bit to 32-bit processors, the
introduction of pipelining, the addition of caches, the transition to
superscalar designs and \(\mu\)-op translation, the expansion to multi-core
CPUs and the extension from 32-bit to 64-bit addressing
\citeprocitem{20}{[20]}.

The changes in hardware design and the shifts in priorities coming
from software implementors have led to the addition and subsequent
deprecation of many ISA instructions.  One direct consequence is the
wasting of ``opcode space'' by old instructions that the passage of
time has rendered useless.  This means useful instructions often need
(sometimes multiple) prefix bytes, complicating handwritten machine
code.  Another consequence is the growth of processor documentation
beyond the possibility of easy navigation and consultation (Intel's
most recent 4-volume manual totals over 5000 pages)
\citeprocitem{21}{[21]}.

The repeated expansion of register width and number, in addition to
the complicated addressing modes allowed by the x86-64 architecture,
has led to complex encoding schemes requiring multiple prefix bytes, a
REX register extension byte, a ModR/M byte, a SIB byte, immediate \&
offset bytes etc.  Fully understanding these schemes is an arduous
task which, while mandatory for the writers of assemblers, only
hinders students' understanding of the fundamentals.

The complexity of the x86-64 ISA has led us to look for
alternatives. After looking at the RISC-V and ARM instruction set
architectures, we decided the better option for our purposes is the
modern and elegant RISC-V.

\subsubsection{The RISC-V Instruction Set Architecture}
\label{sec:orge666507}

RISC-V is an ``open standard'' reduced instruction set computer (RISC)
architecture initiated at the University of California, Berkeley.
RISC-V is available under royalty-free open-source licences for all
interested hardware implementors.

RISC-V is designed with simplicity in mind, inheriting many ideas from
Berkeley RISC and MIPS \citeprocitem{22}{[22]}.  It is a load-store
architecture with all ALU operations occuring between registers (this
greatly simplifies addressing modes and thus fits our purposes).  It
provides 32 general purpose registers, offering enough temporary
registers to avoid using the stack in many situations.  An interesting
design choice is the inclusion of an always-zero \texttt{x0}​/​\texttt{zero} register
that simplifies many operations (for example, copying register \texttt{t0} to
register \texttt{t1} can be expressed as an add-to-zero instruction: \texttt{add t1,
t0, zero}).

The ISA offers only a few simple and orthogonal instructions, aiding
both hardware designers and low-level programmers.  Each instruction
is encoded according to one of six instruction formats, yielding a
highly regular encoding scheme.  The ISA specification defines 32-bit
and 64-bit variants (and even a description of a 128-bit variant
reserved for future use).  It is extendable through \emph{extensions}; in
fact, much functionality considered essential in other ISAs is
provided by extensions in RISC-V: multiplication \& division, atomics,
floating point operations in 32-bit, 64-bit and 128-bit varieties,
compressed 16-bit instructions for reducing code size, and even ISA
support for interpreted or JIT-compiled languages.  The number of
available ISA extensions is growing over time
\citeprocitem{23}{[23]}.

For a historical perspective on the motivations behind RISC-V, refer
to \emph{``The RISC-V Reader: An Open Architecture Atlas''} by RISC-V
co-authors David Patterson and Andrew Waterman \citeprocitem{24}{[24]}.
For detailed technical aspects and further design rationale, consult
the \emph{``RISC-V Instruction Set Manual: Volume I''}
\citeprocitem{25}{[25]} and \emph{``Volume II''}
\citeprocitem{26}{[26]}.

For our purposes it will suffice to use the base instruction set of
the 64-bit RISC-V variant, dubbed RV64I.  This consists of RV32I (the
base 32-bit instruction set) plus a few instructions that extend it to
64-bits.  The total number of instructions available in RV64I is only
57 (out of which 42 instructions are shared with RV32I).  Notably, our
implementation will not require multiplication or division, which are
provided by the RV32M and RV64M extensions, respectively).

We have concluded that we will port the SmithForth machine code from
the x86-64 to the RISC-V architecture.  Besides the ISA, there is
another foundational interface on which the system relies and that is
the Linux operating system it assumes when doing system calls.  Even
more, the machine code is embedded in an executable file conforming to
what Linux expects from loadable files, which is the ELF file format.
In the next sections we will provide a brief overview of Linux system
calls and the ELF file format.

\subsubsection{The Linux Environment: System Calls}
\label{sec:org742711c}

System calls are ``the fundamental interface between an application
and the Linux kernel'' \citeprocitem{27}{[27]}.  Processes request
and receive resources such as memory or I/O access from the operating
system by invoking system calls (also called \emph{syscalls}).  When doing
so, they need to respect a \emph{calling convention}, which allows
user-level programs and the kernel to interoperate.  For programs
written in assembly or machine code, before performing a system call
one needs to know its \emph{system call number}.  This syscall number plus
the syscall arguments then need to be placed in specific registers.
Once the system call is performed, a result and an error might be
returned by the kernel in one or more registers, depending on the
architecture.  Consult the Linux \emph{``syscalls(2)''}
\citeprocitem{27}{[27]} and \emph{``syscall(2)''}
\citeprocitem{28}{[28]} \texttt{man-pages} for more details.

The calling convention for Linux system calls is summarized in Table
\ref{tab:orgb20857f} for both x86-64 and RISC-V.  The second
column lists the instruction used by each architecture to perform a
system call, while the third column shows the register where the
system call number should be placed.  The remaining columns list the
registers used for the return value and arguments.

\small
\begin{center}
\begin{tabular}{c|c|c|c|cccc}
\textbf{Arch.} & \textbf{Instr.} & \textbf{Syscall \#} & \textbf{Return} & \textbf{Arg. 1} & \textbf{Arg. 2} & \textbf{Arg. 3} & \textbf{Args. 4, 5, 6}\\[0pt]
\hline
x86-64 & \texttt{syscall} & \texttt{rax} & \texttt{rax} & \texttt{rdi} & \texttt{rsi} & \texttt{rdx} & \texttt{r10}, \texttt{r8}, \texttt{r9}\\[0pt]
RISC-V & \texttt{ecall} & \texttt{a7} & \texttt{a0} & \texttt{a0} & \texttt{a1} & \texttt{a2} & \texttt{a3}, \texttt{a4}, \texttt{a5}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgb20857f}Calling convention for Linux system calls under x86-64 and RISC-V.}

\end{center}
\normalsize

SmithForth only performs two system calls in its machine code: \texttt{exit}
in the definition of \texttt{BYE} and \texttt{write} in the definition of \texttt{TYPE}.
The syscall numbers and the type signatures are listed in Table
\ref{tab:org7d2b8a3}.  Since we expect to use the same syscalls in the RISC-V
translation, we also include the RISC-V system call numbers as a
column.

\small
\begin{center}
\begin{tabular}{l|c|c|lll}
 & \textbf{Syscall \#} & \textbf{Syscall \#} &  &  & \\[0pt]
\textbf{Name} & (x86-64) & (RISC-V) & \textbf{Arg. 1} & \textbf{Arg. 2} & \textbf{Arg. 3}\\[0pt]
\hline
\texttt{write} & 1 (\texttt{0x01}) & 64 (\texttt{0x40}) & \texttt{unsigned int fd} & \texttt{const char *buf} & \texttt{size\_t count}\\[0pt]
\texttt{exit} & 60 (\texttt{0x3C}) & 93 (\texttt{0x5D}) & \texttt{int error\_code} & – & –\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org7d2b8a3}Syscalls used by SmithForth, together with their C type signatures.}

\end{center}
\normalsize

For a comprehensive list of available Linux system calls under several
architectures, refer to the \emph{``Linux System Call Table''} compiled by
the ChromiumOS community \citeprocitem{29}{[29]}.

\subsubsection{ELF: The \underline{E}​xecutable and \underline{L}​inkable \underline{F}​ormat}
\label{sec:org4db1191}

While system calls are the interface between the program and the Linux
kernel at runtime, the machine code first needs to be loaded into
memory for execution.  This procedure is called \emph{loading} and in Linux
it is subject to the System V Application Binary Interface (ABI)
specification.  In particular, this means that executables have to
respect the \emph{Executable and Linkable Format} (ELF) so that they can be
loaded correctly by the Linux kernel.

The ELF format is defined in Chapter 4 of the \emph{``System V: Application
Binary Interface''} (``generic ABI'' or ``gABI'') document
\citeprocitem{30}{[30]}, with architectural particularities given in
separate ``platform-specific ABI'' (``psABI'') documents.  For x86-64,
this is the \emph{``AMD64 Architecture Processor Supplement''}
\citeprocitem{31}{[31]}, whereas for RISC-V it is the \emph{``RISC-V
ABIs Specification''} \citeprocitem{32}{[32]}.  We will need the
``gABI'' and the x86-64 ``psaABI'' specifications for understanding
the ELF header created by SmithForth and the RISC-V ``psABI'' for
adapting it to the new architecture.

\subsubsection{Development environment}
\label{sec:org819690d}

All analysis and porting work done on SmithForth have been done inside
QEMU virtual machines running under MacOS.  Here we would like to
express our gratefulness for the amazing QEMU project
\citeprocitem{33}{[33]}, \citeprocitem{34}{[34]}, which makes it remarkably easy to work
on multi-architecture projects from one machine.  We used QEMU for
setting up identical Debian VMs under x86-64 and RISC-V, both equipped
with GDB, \texttt{xxd}, \texttt{hexdump}, \texttt{objdump} and other useful development
utilities.  The GNU debugger has proved indispensable for debugging
both erroneus logic and badly (hand-)encoded instructions.

In the next chapter we will examine SmithForth's machine code
implementation, annotating it extensively with commented pseudocode.
This inline code documentation will be used in Chapter \ref{sec:org9c46462} for porting SmithForth to RISC-V.


\section{Understanding and Annotating SmithForth}
\label{sec:orgf813ea4}

In this chapter we will delve into the machine code implementation of
SmithForth.  We will record our understanding as commented pseudocode,
which we will use to annotate David Smith's original x86-64 code.
This documentation will aid the RISC-V implementation in the next
chapter by providing a higher-level picture of the system's
operations.

As proposed in the introduction, we will also make explicit the
encoding scheme used in the x86-64 architecture by highlighting ModR/M
and SIB bytes, immediate and offset bytes etc.  This will help the
interested reader explore the low-level details of instruction
encoding for x86-64 processors.

We explained how the Linux kernel loads an executable into memory if
it respects the ELF file format.  In this chapter's first section,
SmithForth's minimal ELF header is explored and explained.


\subsection{The ELF Header}
\label{sec:org19641eb}

A valid ELF executable respects a certain file layout, allowing the
Linux kernel and other tools to understand its structure.  It begins
with an ELF file header, followed by:
\begin{itemize}
\item a program header table, which describes one or more memory segments;
\item a section header table, which describes zero or more sections;
\item the data itself, referenced by entries in the program table or in
the section header table.
\end{itemize}

SmithForth uses the simplest possible layout, specifying only one
loadable memory segment in its program header table.  Therefore the
executable preamble only has to contain the ELF file header (always
mandatory) and one ELF program header entry.  We will look at them in
turn.

\subsubsection{ELF File Header}
\label{sec:org5a9cf99}

Table \ref{tab:org489a1af} depicts the ELF file header.  The first
column tracks the address of the header's various fields, the second
column shows the bytes in hexadecimal format, while the last column
explains the meaning of each field.  Field names, such as
\texttt{e\_ident[EI\_MAG]}, originate in the System V ``gABI'' specification
\citeprocitem{30}{[30]}.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{9}{10.800000}\selectfont
\begin{center}
\begin{tabular}{l|l|l}
\textbf{\&} & \textbf{File Header Bytes} & \textbf{Explanation}\\[0pt]
\hline
\(\overline{\texttt{00}}\) & \hspace{0.000000em}​\texttt{7F 45 4C 46} & \texttt{e\_ident[EI\_MAG]}: ELF magic number.\\[0pt]
 & \hspace{6.318000em}​\texttt{02} & \texttt{e\_ident[EI\_CLASS]}: \texttt{1} → 32-bit, \uline{\texttt{2} → 64-bit}.\\[0pt]
 & \hspace{7.897500em}​\texttt{01} & \texttt{e\_ident[EI\_DATA]}: \uline{\texttt{1} → little-endian}, \texttt{2} → big-endian.\\[0pt]
 & \hspace{9.477000em}​\texttt{01} & \texttt{e\_ident[EI\_VERSION]}: ELF header version; must be \texttt{1}.\\[0pt]
 & \hspace{11.056500em}​\texttt{00} & \texttt{e\_ident[EI\_OSABI]}: Target OS ABI; \texttt{ELFOSABI\_NONE} (\texttt{0}) is fine for Linux.\\[0pt]
 & \hspace{0.000000em}​\texttt{00} & \texttt{e\_ident[EI\_ABIVERSION]}: ABI version; should be \texttt{0} for Linux.\\[0pt]
 & \hspace{1.579500em}​\texttt{00 00 00 00 00 00 00} & \texttt{e\_ident[EI\_PAD]}: Padding; unused; should be \texttt{0}.\\[0pt]
\hline
 & \hspace{0.000000em}​\texttt{02 00} & \texttt{e\_type}: Object file type; \texttt{2} → executable.\\[0pt]
 & \hspace{3.159000em}​\texttt{3E 00} & \texttt{e\_machine}: Instruction set architecture; \uline{\texttt{0x3E} → \texttt{x86-64}}, \texttt{0xF3} → \texttt{RISC-V}.\\[0pt]
 & \hspace{6.318000em}​\texttt{01 00 00 00} & \texttt{e\_version}: ELF identification version; must be \texttt{1}.\\[0pt]
 & \hspace{0.000000em}​\texttt{78 00 40 00 00 00 00 00} & \texttt{e\_entry}: Memory address of entry point (where process starts).\\[0pt]
 & \hspace{0.000000em}​\texttt{40 00 00 00 00 00 00 00} & \texttt{e\_phoff}: File offset of program headers; \texttt{0x34} → \texttt{32-bit}, \uline{\texttt{0x40} → 64-bit}.\\[0pt]
 & \hspace{0.000000em}​\texttt{00 00 00 00 00 00 00 00} & \texttt{e\_shoff}: File offset section headers (we don't have any sections).\\[0pt]
\hline
 & \hspace{0.000000em}​\texttt{00 00 00 00} & \texttt{e\_flags}: 0 for the \texttt{x86-64} architecture.\\[0pt]
 & \hspace{6.318000em}​\texttt{40 00} & \texttt{e\_ehsize}: Size of this header; \texttt{0x34} → 32-bit, \uline{\texttt{0x40} → 64-bit}.\\[0pt]
 & \hspace{9.477000em}​\texttt{38 00} & \texttt{e\_phentsize}: Size of each program header; \texttt{0x20} → 32-bit, \uline{\texttt{0x38} → 64-bit}.\\[0pt]
 & \hspace{0.000000em}​\texttt{01 00} & \texttt{e\_phnum}: Number of program headers; here \texttt{1}.\\[0pt]
 & \hspace{3.159000em}​\texttt{40 00} & \texttt{e\_shentsize}: Size of each section header; \texttt{0x28} → 32-bit, \uline{\texttt{0x40} → 64-bit}.\\[0pt]
 & \hspace{6.318000em}​\texttt{00 00} & \texttt{e\_shnum}: Number of section headers; here \texttt{0}.\\[0pt]
 & \hspace{9.477000em}​\texttt{00 00} & \texttt{e\_shstrndx}: Index of section header containing section names; N/A.\\[0pt]
\hline
\texttt{40} &  & \\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org489a1af}ELF file header for the Linux executable (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

We underlined some of the more interesting fields.  Note field
\texttt{e\_machine}, which will need to be modified in the RISC-V port.  Field
\texttt{e\_entry} specifies the address of the first instruction that will be
run once the executable is loaded in memory by the kernel.  As
mentioned above, SmithForth requires only one program header entry and
no section entries; therefore \texttt{e\_phnum} is \texttt{1} and \texttt{e\_shnum} is \texttt{0}.

\subsubsection{ELF Program Header}
\label{sec:orgaa28a96}

The ELF program header entry, shown in Table \ref{tab:org24f9ecc},
instructs the kernel to load (field \texttt{p\_type}) the whole (field
\texttt{p\_filesz}) contents of the executable starting at offset \texttt{0} (field
\texttt{p\_offset}) and place it at virtual memory address \texttt{0x400000} (field
\texttt{p\_vaddr}) with all execute-write-read flags enabled (field
\texttt{p\_flags}).  Segment alignment, mandatory or desirable on many
systems, is also specified by field \texttt{p\_align}.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{9}{10.800000}\selectfont
\begin{center}
\begin{tabular}{l|l|l}
\textbf{\&} & \textbf{File Header Bytes} & \textbf{Explanation}\\[0pt]
\hline
\texttt{40} & \hspace{0.000000em}​\texttt{01 00 00 00} & \texttt{p\_type}: Segment type; \texttt{1} → loadable.\\[0pt]
 & \hspace{6.318000em}​\texttt{07 00 00 00} & \texttt{p\_flags}: Segment-wise permissions; \uline{1 → execute}, \uline{2 → write}, \uline{4 → read}.\\[0pt]
 & \hspace{0.000000em}​\texttt{00 00 00 00 00 00 00 00} & \texttt{p\_offset}: Offset of segment in file; we load the whole file, so \texttt{0}.\\[0pt]
 & \hspace{0.000000em}​\texttt{00 00 40 00 00 00 00 00} & \texttt{p\_vaddr}: Virtual address of loaded segment; \texttt{0x400000} on \texttt{x86-64} \citeprocitem{31}{[31]}.\\[0pt]
 & \hspace{0.000000em}​\texttt{00 00 00 00 00 00 00 00} & \texttt{p\_paddr}: Only used on systems where physical address is relevant.\\[0pt]
 & \hspace{0.000000em}​\texttt{02 1E 01 00 00 00 00 00} & \texttt{p\_filesz}: Size of the segment in the file image.\\[0pt]
 & \hspace{0.000000em}​\texttt{00 00 C0 7F 00 00 00 00} & \texttt{p\_memsz}: Size of the segment in memory (\(\ge\) \texttt{p\_filesz}).\\[0pt]
 & \hspace{0.000000em}​\texttt{00 10 00 00 00 00 00 00} & \texttt{p\_align}: Align segment to \texttt{x86-64} page size (4096 or \texttt{0x1000}) \citeprocitem{31}{[31]}.\\[0pt]
\hline
\texttt{78} &  & \\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org24f9ecc}ELF program header (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

We are now ready to examine the first x86-64 instructions that
SmithForth runs once it is loaded.
\clearpage


\subsection{Global Variables}
\label{sec:orga026473}

SmithForth could have been implemented purely in machine code, word by
word.  That would have led, however, to much code repetition, since no
built-in programming facilities exist at this level to help avoid it.
Forth implementations written in assembly, like JONESFORTH, make
extensive use of assembler macros to reduce boilerplate
\citeprocitem{12}{[12]}.  Since SmithForth is written in machine code, it
doesn't have that luxury.

Instead of operating entirely at one level of abstraction, SmithForth
is built in stages, with each stage using the facilities provided by
the stage below.  The implementation begins with setting up a ``binary
interpreter'', a minimal meta-programming mechanism using a simple
binary convention to allow for the easy definition, compilation and
execution of Forth words.  This mechanism will be detailed in the \hyperref[sec:org1a2f8d5]{next
section}.

This first stage is used by the next, which builds primitives for
\hyperref[sec:org4ce6d13]{exiting and printing}, \hyperref[sec:org93c7bb6]{debugging} and \hyperref[sec:org779e83c]{executing} Forth code. Together,
these two stages construct a basic Forth system able to compile and
execute the Forth code at the next stage, defined in \texttt{system.fs}.

The different components of the system described above communicate
mainly through three mechanisms:
\begin{itemize}
\item passing and returning data through the machine registers or stack;
\item reading and writing of several global variables;
\item using the Forth data stack, once it is bootstrapped at the end of
the second stage.
\end{itemize}

In this section we review the global variables used by the machine
code foundation of SmithForth.  Table \ref{tab:orgf3f861c} describes each
variable and indicates the register or memory address where each
variable is stored.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|l|l}
\textbf{Variable} & \textbf{Register}​/​\textbf{Address} & \textbf{Contents}\\[0pt]
\hline
\texttt{INPUT} & \texttt{RSI} & Source address of binary interpreter data and commands.\\[0pt]
\texttt{OUTPUT} & \texttt{RDI} & Destination address of binary interpreter operations.\\[0pt]
\texttt{VARS} & \texttt{R9} & Base address of globals stored in memory (\texttt{\#IN}, \texttt{TIB} etc).\\[0pt]
\texttt{STACK} & \texttt{R15} & Address of top value on the data stack.\\[0pt]
\hline
\texttt{\#IN} & \texttt{0x10000000 (VARS)} & The number of characters in the current line.\\[0pt]
\texttt{TIB} & \texttt{0x10000008 (VARS+8)} & The address where the current line begins.\\[0pt]
\texttt{>IN} & \texttt{0x10000010 (VARS+16)} & The number of \emph{parsed} characters in the current line.\\[0pt]
\texttt{STATE} & \texttt{0x10000020 (VARS+32)} & Either \texttt{0} (\emph{interpreting} state) or \texttt{1} (\emph{compiling} state).\\[0pt]
\texttt{LATEST} & \texttt{0x10000028 (VARS+40)} & The execution token (\emph{xt}) of the latest defined Forth word.\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgf3f861c}Global variables in SmithForth (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

Variables \texttt{INPUT} and \texttt{OUTPUT} are used by the binary interpreter as
its binary source and destination, respectively.  Intepreter
\emph{commands} and data are issued by the programmer, sequentially, at
\texttt{INPUT}; the interpreter acts based on these commands and produces
sometimes complicated data structures at \texttt{OUTPUT}, relieving the
programmer from the effort of creating these repetitive structures
manually.

Variable \texttt{VARS}, held in a register, is used to indirectly address the
five variables stored in memory, listed in the second half of the
table. These variables, in turn, are used by the text interpreter for
reading Forth code from input (\texttt{\#IN}, \texttt{TIB} and \texttt{>IN}), for
distinguishing between compilation mode and interpretation mode
(\texttt{STATE}) and for referring to the Forth dictionary (\texttt{LATEST}).

Finally, the last variable kept in a register, \texttt{STACK}, points to the
top of the Forth data stack, once it is set up.

The first two SmithForth machine instructions, shown in Table
\ref{tab:org5e82ba6}, initialize variables \texttt{INPUT} and \texttt{OUTPUT}, used
further by the binary interpreter.  Note the typographic conventions
used in this table, as they will be used all along our analysis of the
SmithForth x86-64 codebase.  In the first column we wrote our
annotations, in the form of pseudocode interspersed with comments;
this documentation will be the most important resource during the
RISC-V port in the next chapter.  The following two columns show the
x86-64 instructions in assembly and ``opcode'' format; the mnemonic of
the former can be used to search the Intel manuals for generic
instructions, while the latter specifies the concrete hardware
instruction that was chosen for encoding.  The last column contains
the encoded binary instructions as annotated hexadecimal bytes.  The
\textbf{\&} column, when present, is used to track addresses for calculating
relative offsets for calls, jumps and branches.  Note the address of
the first instruction, \texttt{0x78}, the same that we saw used as the entry
point in the ELF header.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Global variable \texttt{INPUT}.} &  &  &  & \\[0pt]
\texttt{INPUT@RSI ← 0x004000B2;} & mov esi, 0x4000B2 & B8+rd \emph{id} & \texttt{78} & \texttt{BE} \emph{\texttt{B2 00 40 00}}\\[0pt]
\emph{\# Global variable \texttt{OUTPUT}.} &  &  &  & \\[0pt]
\texttt{OUTPUT@RDI ← 0x10000030;} & mov edi, 0x10000030 & B8+rd \emph{id} &  & \texttt{BF} \emph{\texttt{30 00 00 10}}\\[0pt]
 &  &  & \texttt{82} & \\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org5e82ba6}Initialize global variables \texttt{INPUT} and \texttt{OUTPUT} (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

Variable \texttt{INPUT} is initialized to the memory address directly
following the definition of the binary interpreter loop described in
the next section.  This enables the binary interpreter to ``consume''
commands and binary data, all the while constructing the Forth
dictionary at \texttt{OUTPUT}.

Note that beyond \texttt{0x10000030} (just after the memory location of
variable \texttt{LATEST}) lies unused memory. This is where the binary
interpreter is going to start writing, so this is the initial value
that global variable \texttt{OUTPUT} receives.
\clearpage


\subsection{Binary Interpreter}
\label{sec:org1a2f8d5}

The binary interpreter implements a simple meta-programming device for
easily defining, compiling and executing Forth words in machine code.
It consists of a loop, shown in Table \ref{tab:org52dda3c}, that repeatedly:
\begin{itemize}
\item Consumes a byte from \texttt{INPUT}.
\item If this byte has the special value \texttt{0x99}, it is understood as
signaling the beginning of a binary interpreter \emph{command}.  Another
\emph{command argument} byte is consumed from \texttt{INPUT} and is used to
dispatch to one of three possible code paths:
\begin{itemize}
\item \uline{Define} a new Forth word using subroutine \hyperref[tab:org001d2e8]{\texttt{Head}}, OR
\item \uline{Compile} a call to an existing Forth word to \texttt{OUTPUT} using
subroutine \hyperref[tab:org55cc663]{\texttt{COMPL}}, OR
\item \uline{Execute} an existing Forth word immediately.
\end{itemize}
\item Otherwise, the byte is simply copied to \texttt{OUTPUT}.
\end{itemize}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\texttt{\_bi:} &  &  & \texttt{82} &  & \\[0pt]
\hspace{1em} \emph{\# Loop the binary interpreter.} &  &  &  &  & \\[0pt]
\hspace{1em} \texttt{call bi();} & call \uline{bi()} & E8 \uline{cb}\footnotemark &  & \texttt{E8} \uline{\texttt{02 00 00 00}}​\(_{\text{\tiny 89-87}}\) & call bi()\\[0pt]
\hspace{1em} \texttt{goto \_bi.} & jmp \uline{\_bi} & EB \uline{cb} & \texttt{87} & \texttt{EB} \uline{\texttt{F9}}​\(_{\text{\tiny 82-89}}\) & jump \_bi\\[0pt]
\texttt{bi():} &  &  & \texttt{89} &  & \\[0pt]
\hspace{1em} \emph{\# Read next byte from \texttt{INPUT}.} &  &  &  &  & \\[0pt]
\hspace{1em} \texttt{byte@AL ← [INPUT@RSI++];} & lods al, [rsi] & AC &  & \texttt{AC} & al = [rsi++]\\[0pt]
\hspace{1em} \emph{\# Does it start a command?} &  &  &  &  & \\[0pt]
\hspace{1em} \texttt{if byte@AL = 0x99:} & cmp al, \emph{0x99} & 3C \emph{ib} &  & \texttt{3C} \emph{\texttt{99}} & cmp al, 99(command)\\[0pt]
\hspace{2em}     \texttt{goto \_command.} & je \uline{\_command} & 74 \uline{cb} &  & \texttt{74} \uline{\texttt{02}}​\(_{\text{\tiny 90-8E}}\) & jump \_command if ==\\[0pt]
\hspace{1em} \emph{\# If not, just copy the byte} &  &  &  &  & \\[0pt]
\hspace{1em} \emph{\# to \texttt{OUTPUT} and return.} &  &  &  &  & \\[0pt]
\hspace{1em} \texttt{[OUTPUT@RDI++] ← byte@AL;} & stos [rdi], al & AA & \texttt{8E} & \texttt{AA} & [rdi++] = al (xmit)\\[0pt]
\hspace{1em} \texttt{return.} & ret & C3 &  & \texttt{C3} & return\\[0pt]
\texttt{\_command:} &  &  & \texttt{90} &  & \\[0pt]
\hspace{1em} \emph{\# Address of global \texttt{LATEST}.} &  &  &  &  & \\[0pt]
\hspace{1em} \texttt{LATEST@RDX ← 0x10000028;} & mov edx, \emph{0x10000028} & B8+rd \emph{id} &  & \texttt{BA} \emph{\texttt{28 00 00 10}} & rdx = Latest\\[0pt]
\hspace{1em} \emph{\# Read command argument.} &  &  &  &  & \\[0pt]
\hspace{1em} \texttt{arg@AL ← [INPUT@RSI++];} & lods al, [rsi] & AC &  & \texttt{AC} & al = [rsi++] (argument)\\[0pt]
\hspace{1em} \emph{\# Command type by argument:} &  &  &  &  & \\[0pt]
\hspace{1em} \emph{\# – \texttt{0bi00ccccc}: define;} &  &  &  &  & \\[0pt]
\hspace{1em} \emph{\# – \texttt{0b011ccccc}: compile;} &  &  &  &  & \\[0pt]
\hspace{1em} \emph{\# – \texttt{0b111ccccc}: execute.} &  &  &  &  & \\[0pt]
\hspace{1em} \texttt{if arg@AL \& 0b01100000 = 0:} & test al, \emph{0x60} & A8 \emph{ib} &  & \texttt{A8} \emph{\texttt{60}} & al \& 60(graphic)?\\[0pt]
\hspace{2em}     \emph{\# \uline{Define} a new word.} &  &  &  &  & \\[0pt]
\hspace{2em}     \texttt{goto Head.} & jz \uline{Head} & 74 \uline{cb} &  & \texttt{74} \uline{\texttt{31}}​\(_{\text{\tiny CB-9A}}\) & jump Head if zero\\[0pt]
\hspace{1em} \emph{\# Get latest dictionary word.} &  &  & \texttt{9A} &  & \\[0pt]
\hspace{1em} \texttt{xt@RBX ← [LATEST];} & mov rbx, [rdx] & REX.W 8B /r &  & \texttt{48 8B} \texttt{1A}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·011·010}}\) & rbx = [rdx]\\[0pt]
\texttt{\_find1:} &  &  & \texttt{9D} &  & \\[0pt]
\hspace{1em} \texttt{save arg@AL on the stack;} & push rax & 50+rd &  & \texttt{50} & push al\\[0pt]
\hspace{1em} \texttt{chr@AL \&= 0b0111111;} & and al, \emph{0x7f} & 24 \emph{ib} &  & \texttt{24 7F} & al \&= 7F\\[0pt]
\hspace{1em} \texttt{if chr@AL = [xt + 17]:} & cmp al, [rbx+0x11] & REX 3A /r &  & \texttt{3A 43} \texttt{11}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·010·001}}\) & cmp al, [rbx+11]\\[0pt]
\hspace{2em}     \emph{\# We found an entry whose} &  &  &  &  & \\[0pt]
\hspace{2em}     \emph{\# name begins with \texttt{chr}.} &  &  &  &  & \\[0pt]
\hspace{2em}     \texttt{restore arg@AL;} & pop rax & 58+rd &  & \texttt{58} & pop al\\[0pt]
\hspace{2em}     \texttt{goto \_match.} & je \uline{\_match} & 74 \uline{cb} &  & \texttt{74} \uline{\texttt{06}}​\(_{\text{\tiny AC-A6}}\) & jump \_match if ==\\[0pt]
\hspace{1em} \emph{\# Follow word's link pointer} &  &  & \texttt{A6} &  & \\[0pt]
\hspace{1em} \emph{\# to previous entry and repeat.} &  &  &  &  & \\[0pt]
\hspace{1em} \texttt{xt@RBX ← [xt@RBX + 8];} & mov rbx, [rbx+0x8] & REX.W 8B /r &  & \texttt{48 8B} \texttt{5B}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·011·011}}\) \texttt{08} & rbx = [rbx+8]\\[0pt]
\hspace{1em} \texttt{goto \_find1.} & jmp \uline{\_find1} & EB \uline{cb} &  & \texttt{EB} \uline{\texttt{F1}}​\(_{\text{\tiny 9D-AC}}\) & jump \_find1\\[0pt]
\texttt{\_match:} &  &  & \texttt{AC} &  & \\[0pt]
\hspace{1em} \texttt{if arg \& 0b1000000 = 0:} & test al, \emph{0x80} & A8 \emph{ib} &  & \texttt{A8} \emph{\texttt{80}} & al \& 80(exec) ?\\[0pt]
\hspace{2em}     \emph{\# \uline{Compile}.} &  &  &  &  & \\[0pt]
\hspace{2em}     \texttt{goto COMPL.} & jz \uline{COMPL} & 74 \uline{cb} &  & \texttt{74} \uline{\texttt{09}}​\(_{\text{\tiny B9-B0}}\) & jump COMPL if zero\\[0pt]
\hspace{1em} \emph{\# \uline{Execute} word's code.} &  &  & \texttt{B0} &  & \\[0pt]
\hspace{1em} \texttt{goto [xt@RBX].} & jmp [rbx] & REX FF /4 &  & \texttt{FF} \texttt{23}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·100·011}}\) & jump [rbx] (exec)\\[0pt]
 &  &  & \texttt{B2} &  & \\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org52dda3c}The binary interpreter routine and loop (x86-64).}

\end{center}\footnotetext[1]{\label{orgde03361}SmithForth misses the opcode here.}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

Command dispatching is done based on specific bit patterns in the
argument byte.  \emph{Defining} a Forth word means creating a \emph{dictionary
entry} in the Forth \emph{dictionary} (explained shortly).  \emph{Compiling} or
\emph{executing} an existing Forth word requires first searching the
dictionary for a corresponding entry.  This matching is done in the
binary interpreter loop by the word name's first character only, a
limitation that has to be taken into account when defining new words:
they must not begin with the same ASCII character.  This limitation is
lifted in the next stage, once \texttt{FIND} is implemented.
\pagebreak

\subsubsection{Subroutine \texttt{COMPL}}
\label{sec:org99c01e8}

In the case of a \emph{compile} binary interpreter command, control is
given to \texttt{COMPL}, shown in Table \ref{tab:org41a9f1a}.  This subroutine
dynamically constructs an x86-64 \texttt{CALL} to the code of the given Forth
word, embedding this code address as four immediate bytes.  It is one
of the more subtle parts of SmithForth.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{COMPL}} & --- & --- & \texttt{B2} & \texttt{[99} \(^{d}\)​\texttt{05} \uline{\texttt{43 4F 4D 50 4C}}​\texttt{]} & define COMPL\\[0pt]
\emph{\# In/Out:} \texttt{( xt@RBX -{}-{} xt@RBX )} &  &  &  &  & \\[0pt]
 &  &  &  &  & \\[0pt]
\emph{\# Generate a CALL instr. to \texttt{OUTPUT}:} &  &  &  &  & \\[0pt]
\emph{\# – instruction: CALL r/m64} &  &  &  &  & \\[0pt]
\emph{\# – opcode: FF /2} &  &  &  &  & \\[0pt]
\emph{\#} &  &  &  &  & \\[0pt]
\emph{\# Thus we generate code as follows:} &  &  &  &  & \\[0pt]
\emph{\#}\hspace{1.053000em}​\texttt{FF} \texttt{14}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·010·100}}\) \texttt{25}​\(^{\text{\tiny    SIB}}_{\text{\tiny 25·00·100}}\) \uline{\texttt{??} \texttt{??} \texttt{??} \texttt{??}} &  &  &  &  & \\[0pt]
 &  &  &  &  & \\[0pt]
\emph{\# 1. Write opcode of CALL (0x99).} &  &  &  &  & \\[0pt]
\texttt{op@AL ← 0xFF;} & mov al, \emph{0xFF} & B0+rb \emph{ib} & \texttt{B9} & \texttt{B0} \emph{FF} & compile: call r/m64 (FF /2, 00 010 100, 00 100 101\\[0pt]
\texttt{[OUTPUT@RDI++] ← op@AL;} & stos [rdi], al & AA &  & \texttt{AA} & \\[0pt]
\emph{\# 2. Write ModR/M byte (0x14).} &  &  &  &  & \\[0pt]
\texttt{modrm@AL ← 0x14;} & mov al, \emph{0x14} & B0+rb \emph{ib} &  & \texttt{B0} \emph{14} & al = \_\\[0pt]
\texttt{[OUTPUT@RDI++] ← op@AL;} & stos [rdi], al & AA &  & \texttt{AA} & \\[0pt]
\emph{\# 3. Write SIB byte (0x25).} &  &  &  &  & \\[0pt]
\texttt{sib@AL ← 0x25;} & mov al, \emph{0x25} & B0+rb \emph{ib} &  & \texttt{B0} \emph{25} & [rdi++] = al\\[0pt]
\texttt{[OUTPUT@RDI++] ← op@AL;} & stos [rdi], al & AA &  & \texttt{AA} & \\[0pt]
\emph{\# 4. Write 4-byte code address.} &  &  &  &  & \\[0pt]
\texttt{xt@EAX ← xt@EBX;} & xchg ebx, eax & 90+rd &  & \texttt{93} & eax = ebx\\[0pt]
\texttt{[OUTPUT@RDI++4] ← xt@EAX;} & stos [rdi], eax & AB &  & \texttt{AB} & [rdi(++4)] = eax\\[0pt]
 &  &  &  &  & \\[0pt]
\texttt{return.}  \emph{\# To interpreter loop.} & ret & C3 &  & \texttt{C3} & return\\[0pt]
 &  &  & \texttt{C5} &  & \\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org41a9f1a}\texttt{COMPL} compiles a call to the given execution token (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\subsubsection{Subroutine \texttt{Head}}
\label{sec:org87a4500}

Central to Forth systems is the \emph{word dictionary}, a linked list of
\emph{dictionary entries} containing information about defined words.  In
SmithForth, a dictionary entry consists of four fields:
\begin{itemize}
\item the \uline{code} field (8 bytes), which contains the memory address where the word's
code begins;
\item the \uline{link} field (8 bytes), which points to the previously defined dictionary
entry; this establishes the linked-list structure of the dictionary;
\item the \uline{flag+length} field (1 byte), which stores the length of the
word's name (5 bits), whether it's an immediate word (1 bit, explained later) and
whether it's hidden (1 bit, also explained later);
\item the \uline{name} field (up to 31 bytes), a variable-length field
containing the word's name.
\end{itemize}

Subroutine \texttt{Head}, listed in Table \ref{tab:org001d2e8}, defines a new
Forth word by constructing a dictionary entry with the structure
described above.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{Head}} & --- & --- & \texttt{C5} & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{48 65 61 64}}​\texttt{]} & define Head\\[0pt]
\emph{\# In/Out:} \texttt{( latest@RDX} &  &  &  &  & \\[0pt]
\emph{\#}\hspace{4.9em}   \texttt{flag@AL -​- )} &  &  &  &  & \\[0pt]
 &  &  &  &  & \\[0pt]
\emph{\# 16-bit align \texttt{OUTPUT}.} &  &  &  &  & \\[0pt]
\texttt{OUTPUT@RDI += 0x0F;} & add rdi, \emph{0x0F} & REX.W 83 \emph{0 /ib} & \texttt{CB} & \texttt{48 83} \texttt{C7}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·111}}\) \texttt{0F} & rdi += 0F\\[0pt]
\texttt{OUTPUT@RDI \&= 0xF0;} & and rdi, \emph{0xF0} & REX.W 83 \emph{4 /ib} &  & \texttt{48 83} \texttt{E7}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·100·111}}\) \texttt{F0} & rdi \&= F0\\[0pt]
 &  &  &  &  & \\[0pt]
\emph{\# Fill the new dictionary entry:} &  &  &  &  & \\[0pt]
\emph{\#} &  &  &  &  & \\[0pt]
\emph{\# 1. Set the \uline{link} field, then set} &  &  &  &  & \\[0pt]
\emph{\# \texttt{LATEST} to the new entry.} &  &  &  &  & \\[0pt]
\texttt{latest@RCX ← [latest@RDX];} & mov rcx, [rdx] & REX.W 8B /r &  & \texttt{48 8B} \texttt{0A}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·001·010}}\) & rcx = [rdx]\\[0pt]
\texttt{[OUTPUT@RDI+8] ← latest@RCX;} & mov [rdi+0x8], rcx & REX.W 89 /r &  & \texttt{48 89} \texttt{4F}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·001·111}}\) \texttt{08} & [rdi+8] = rcx\\[0pt]
\texttt{[latest@RDX] ← OUTPUT@RDI;} & mov [rdx], rdi & REX.W 89 /r &  & \texttt{48 89} \texttt{3A}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·111·010}}\) & [rdx] = rdi\\[0pt]
 &  &  &  &  & \\[0pt]
\emph{\# 2. Set the \uline{flag+length} field.} &  &  &  &  & \\[0pt]
\texttt{OUTPUT@RDI += 0x10;} & add rdi, \emph{0x10} & REX.W 83 \emph{0 /ib} &  & \texttt{48 83} \texttt{C7}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·111}}\) \texttt{10} & rdi += 10\\[0pt]
\texttt{[OUTPUT@RDI++] ← flag@AL;} & stos [rdi], al & AA &  & \texttt{AA} & [rdi++] = al\\[0pt]
 &  &  &  &  & \\[0pt]
\emph{\# 3. Extract name length from} &  &  &  &  & \\[0pt]
\emph{\# \texttt{flag} and copy \uline{name} field.} &  &  &  &  & \\[0pt]
\texttt{flag@ECX ← flag@AL;} & xchg ecx, eax & 90+rd &  & \texttt{91} & ecx = eax\\[0pt]
\texttt{length@ECX ← flag@ECX \& 0x1F;} & and ecx, \emph{0x1F} & 83 /​4 \emph{ib} &  & \texttt{83} \texttt{E1}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·100·001}}\) \texttt{1F} & ecx \&= 1F\\[0pt]
\texttt{copy      length@ECX bytes} &  &  &  &  & \\[0pt]
\hspace{2.632500em}​\texttt{from INPUT@RSI} &  &  &  &  & \\[0pt]
\hspace{2.632500em}​\texttt{to OUTPUT@RDI;} & rep movs [rdi], [rsi] & F3 A4 &  & \texttt{F3 A4} & copy Name\\[0pt]
 &  &  &  &  & \\[0pt]
\emph{\# 4. Point \uline{code} field to the code} &  &  &  &  & \\[0pt]
\emph{\# about to be generated at \texttt{OUTPUT}.} &  &  &  &  & \\[0pt]
\texttt{code@RCX ← [latest@RDX];} & mov rcx, [rdx] & REX.W 8B /r &  & \texttt{48 8B} \texttt{0A}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·001·010}}\) & rcx = [rdx]\\[0pt]
\texttt{[code@RCX] ← OUTPUT@RDI;} & mov [rcx], rdi & REX.W 89 /r &  & \texttt{48 89} \texttt{39}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·111·001}}\) & [rcx] = rdi\\[0pt]
\texttt{return.}  \emph{\# To interpreter loop.} & ret & C3 &  & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org001d2e8}Subroutine \texttt{Head} defines new words in the dictionary (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}
\clearpage


\subsection{Interacting with the World}
\label{sec:org4ce6d13}

The first user-level, non-infrastructural word defined by SmithForth
is \texttt{BYE}, used for terminating the program.  Its definition is shown
in Table \ref{tab:org689507a}.  The syscall number for \texttt{exit} is loaded in
register \texttt{RAX} and the status code is loaded in \texttt{RDI}, as expected by
the Linux calling convention for system calls on x86-64 machines.
Note that the \texttt{exit} syscall does not return, so no \texttt{ret} instruction
is required at the end of this subroutine.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{BYE}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{03} \uline{\texttt{42 59 45}}​\texttt{]} & define BYE\\[0pt]
\emph{\# In/Out:} \texttt{( -​- )} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\emph{\# Goodbye, world (exit syscall).} &  &  &  & \\[0pt]
\texttt{nr@RAX ← 0x3C;}  \emph{\# \texttt{\_\_NR\_exit}.} & push \emph{0x3C} & 6A \emph{ib} & \texttt{6A} \emph{\texttt{3C}} & rax = exit (no return)\\[0pt]
 & pop rax & 58+rd & \texttt{58} & \\[0pt]
\texttt{status@RDI ← 0;} & xor edi, edi & 31 /r & \texttt{31} \texttt{FF}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·111·111}}\) & rdi = stat\\[0pt]
\texttt{syscall exit(status@RDI).} & syscall & 0F 05 & \texttt{0F 05} & syscall\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org689507a}\texttt{BYE} terminates the program by performing an \texttt{exit} syscall (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

Exiting is one of the two ways SmithForth interacts with the Linux
kernel in its machine code part.  The other is printing to \emph{standard
output}, implemented in \texttt{TYPE} and shown in Table \ref{tab:org693010c}.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{TYPE}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{54 59 50 45}}​\texttt{]} & define TYPE\\[0pt]
\emph{\# In/Out:}    \texttt{( addr@RSI u@RDX} &  &  &  &  & \\[0pt]
\emph{\#\hspace{3.35em}} \texttt{-​- ?@RSI ?@RDI )} &  &  &  &  & \\[0pt]
\emph{\#} &  &  &  &  & \\[0pt]
\emph{\# Dump memory range \texttt{[addr, addr+u)}.} &  &  &  &  & \\[0pt]
 &  &  &  &  & \\[0pt]
\hspace{1em} \texttt{fd@RDI ← 1;}  \emph{\# \texttt{STDOUT\_FILENO}.} & push \emph{0x1} & 6A \emph{ib} &  & \texttt{6A} \emph{\texttt{01}} & rdi(fd) = stdout = 1\\[0pt]
 & pop rdi & 58+rd &  & \texttt{5F} & \\[0pt]
\texttt{\_begin:} &  &  & \(\overline{\texttt{00}}\)\footnotemark &  & \\[0pt]
\hspace{1em} \emph{\# \texttt{\_\_NR\_write} is also 1.} &  &  &  &  & \\[0pt]
\hspace{1em} \texttt{nr@RAX ← fd@RDI;} & mov eax, edi & 8B /r &  & \texttt{8B} \texttt{C7}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·111}}\) & rax = write = 1 = rdi\\[0pt]
\hspace{1em} \texttt{syscall write(fd@RDI,} &  &  &  &  & \\[0pt]
\hspace{1em}\hspace{7.371000em}    \texttt{addr@RSI,} &  &  &  &  & \\[0pt]
\hspace{1em}\hspace{7.371000em}    \texttt{u@RDX);} & syscall & 0F 05 &  & \texttt{0F 05} & syscall\\[0pt]
\hspace{1em} \texttt{if ret@RAX < 0:} & test rax, rax & REX.W 85 /r &  & \texttt{48 85} \texttt{C0}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·000}}\) & cmp rax, 0\\[0pt]
\hspace{2em} \emph{\# An error occured.} &  &  &  &  & \\[0pt]
\hspace{2em}     \texttt{goto \_end.} & jl \uline{\_end} & 7C \uline{cb} &  & \texttt{7C} \uline{\texttt{08}}​\(_{\text{\tiny 11-09}}\) & +jump \_end if <\\[0pt]
\hspace{1em} \emph{\# Advance by \texttt{ret} (printed) bytes.} &  &  & \texttt{09} &  & \\[0pt]
\hspace{1em} \texttt{addr@RSI += ret@RAX;} & add rsi, rax & REX.W 01 /r &  & \texttt{48 01} \texttt{C6}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·110}}\) & rsi(buf) += rax\\[0pt]
\hspace{1em} \emph{\# Fewer bytes left to print.} &  &  &  &  & \\[0pt]
\hspace{1em} \texttt{u@RDX -= ret@RAX;} & sub rdx, rax & REX.W 29 /r &  & \texttt{48 29} \texttt{C2}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·010}}\) & rdx(count) -= rax\\[0pt]
\hspace{1em} \texttt{if u > 0:} &  &  &  &  & \\[0pt]
\hspace{2em}     \emph{\# We still have bytes to print.} &  &  &  &  & \\[0pt]
\hspace{2em}     \texttt{goto \_begin.} & jg \uline{\_begin} & 7F \uline{cb} &  & \texttt{7F} \uline{\texttt{EF}}​\(_{\text{\tiny 00-11}}\) & -jump \_beg if >\\[0pt]
\texttt{\_end:} &  &  & \texttt{11} &  & \\[0pt]
\hspace{1em} \texttt{return.} & ret & C3 &  & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org693010c}Subroutine \texttt{TYPE} dumps a memory range to \texttt{STDOUT} (x86-64).}

\end{center}\footnotetext[2]{\label{org6c31c71}We reset the address counter since no jumps occur from the code
below this point to the code above or vice versa. This has the
advantage of keeping the counter value contained to one byte. We will
use an overlined \(\overline{\texttt{00}}\) when we do this again.}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

System call \texttt{write} is used to print \texttt{u} bytes to the \texttt{STDOUT} \emph{file
descriptor}, starting at address \texttt{addr}.  Since the syscall is not
guaranteed to write all data, multiple calls might be required.  A
loop that maintains the remaining byte count and current source
address is implemented to this effect.
\clearpage


\subsection{Debugging Utilities}
\label{sec:org93c7bb6}

Low-level programming often requires debugging utilities for
inspecting the registers and the memory at particular source
locations.  SmithForth defines two Forth words for exactly this
purpose.

Subroutine \texttt{dbg}, shown in Table \ref{tab:org69b867c}, prints enough memory
to cover the first four slots on Forth's data stack, the global
variables, and all Forth words defined in machine code.  It becomes
clear that David Smith purposely chose the locations of the data
stack, of the global variables and the initial \texttt{OUTPUT} address to
make everything inspectable with one memory dump.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{dbg}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{03} \uline{\texttt{64 52 67}}​\texttt{]}​ & define dbg\\[0pt]
\emph{\# In/Out:} \texttt{( -​- )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Dump working memory.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\texttt{save INPUT@RSI on the stack;} & push rsi & 50+rd & \texttt{56} & push rsi\\[0pt]
\texttt{save OUTPUT@RDI on the stack;} & push rdi & 50+rd & \texttt{57} & push rdi\\[0pt]
\emph{\# Dump memory contents using} &  &  &  & \\[0pt]
\emph{\# subroutine \texttt{TYPE}.} &  &  &  & \\[0pt]
\texttt{addr@RSI ← 0x0FFFFFE0;} & mov esi, \emph{0xFFFFFE0} & B8+rd \emph{id} & \texttt{BE} \emph{\texttt{E0 FF FF 0F}} & rsi = addr\\[0pt]
\texttt{u@RDX ← 0x0A00;} & mov edx, \emph{0xA00} & B8+rd \emph{id} & \texttt{BA} \emph{\texttt{00 0A 00 00}} & rdx = u\\[0pt]
\emph{\# Compile a CALL to \texttt{TYPE}.} &  &  &  & \\[0pt]
\texttt{call TYPE;}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{54}​\(_{T}\)​\texttt{]} & Call TYPE\\[0pt]
\emph{\# Restore registers and return.} &  &  &  & \\[0pt]
\texttt{restore OUTPUT@RDI;} & pop rdi & 58+rd & \texttt{5F} & pop rdi\\[0pt]
\texttt{restore INPUT@RSI;} & pop rsi & 58+rd & \texttt{5E} & pop rsi\\[0pt]
\texttt{return.} & ret & C3 & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org69b867c}Subroutine \texttt{dbg} dumps the working memory to \texttt{STDOUT} (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

The memory printed at \texttt{STDOUT} will surely contain mainly unprintable
characters.  Directly reading \texttt{dbg}'s output at the Linux terminal is
therefore not recommended.  We suggest a modified version of the
command recommended by David Smith:

\begin{verbatim}
$ ./SForth | xxd -u -g8 -e -R always
\end{verbatim}

Debugging utility \texttt{reg}, displayed in Table \ref{tab:org71fe63a}, prints
all 16 general-purpose registers of an x86-64 processor.  It first
pushes the registers, carefully ordered, on the stack and then it
calls \texttt{TYPE} for printing that stack section.  Similarly to \texttt{dbg},
reading the output at the Linux terminal requires a conversion to
printable characters.  We have successfully used \texttt{xxd -u -g8 -o
0x0fffffe0 -R always}.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{reg}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{03} \uline{\texttt{72 65 67}}​\texttt{]} & define reg\\[0pt]
\emph{\# In/Out:} \texttt{( -​- )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Dump the registers.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\texttt{save INPUT@RSI;} & push rsi & 50+rd & \texttt{56} & push rsi\\[0pt]
\texttt{save OUTPUT@RDI;} & push rdi & 50+rd & \texttt{57} & push rdi\\[0pt]
 &  &  &  & \\[0pt]
\emph{\# Push the 16 registers on the} & push r15 & REX 50+rd & \texttt{41 57} & push r15, rdi, r14, rsi\\[0pt]
\emph{\# stack so that when printed} & push rdi & 50+rd & \texttt{57} & push r13, rbp, r12, rsp\\[0pt]
\emph{\# they're displayed like this:} & push r14 & REX 50+rd & \texttt{41 56} & push r11, rbx, r10, rdx\\[0pt]
\emph{\#} & push rsi & 50+rd & \texttt{56} & push r9 , rcx, r8 , rax\\[0pt]
\emph{\#}\hspace{2.106000em} \texttt{·-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-·} & push r13 & REX 50+rd & \texttt{41 55} & \\[0pt]
\emph{\#}\hspace{2.106000em} \texttt{¦}​\hspace{0.526500em}​\texttt{R15 ¦ RDI ¦} & push rbp & 50+rd & \texttt{55} & \\[0pt]
\emph{\#}\hspace{2.106000em} \texttt{¦}​\hspace{0.526500em}​\texttt{R14 ¦ RSI ¦} & push r12 & REX 50+rd & \texttt{41 54} & \\[0pt]
\emph{\#}\hspace{2.106000em} \texttt{¦}​\hspace{0.526500em}​\texttt{··· ¦ ··· ¦} & push rsp & 50+rd & \texttt{54} & \\[0pt]
\emph{\#}\hspace{2.106000em} \texttt{¦}​\hspace{1.053000em}​\texttt{R8  ¦ RAX ¦} & push r11 & REX 50+rd & \texttt{41 53} & \\[0pt]
\emph{\#}\hspace{2.106000em} \texttt{·-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-·} & push rbx & 50+rd & \texttt{53} & \\[0pt]
 & push r10 & REX 50+rd & \texttt{41 52} & \\[0pt]
 & push rdx & 50+rd & \texttt{52} & \\[0pt]
 & push r9 & REX 50+rd & \texttt{41 51} & \\[0pt]
 & push rcx & 50+rd & \texttt{51} & \\[0pt]
 & push r8 & REX 50+rd & \texttt{41 50} & \\[0pt]
 & push rax & 50+rd & \texttt{50} & \\[0pt]
\emph{\# Print top 128 stack bytes using} &  &  &  & \\[0pt]
\emph{\# subroutine \texttt{TYPE(addr, u)}.} &  &  &  & \\[0pt]
\texttt{addr@RSI ← RSP;} & mov rsi, rsp & REX.W 8B /r & \texttt{48 8B} \texttt{F4}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·110·100}}\) & rsi = rsp\\[0pt]
\texttt{u@RDX ← 0x80;} & mov edx, \emph{0x80} & B8+rd \emph{id} & \texttt{BA} \emph{\texttt{80 00 00 00}} & rdx = u\\[0pt]
\texttt{call TYPE;}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{54}​\(_{T}\)​\texttt{]} & Call TYPE\\[0pt]
\emph{\# Clean the stack.} &  &  &  & \\[0pt]
\texttt{pop 16 quads;} & sub rsp, \emph{0x80} & REX.W 83 \emph{5 /ib} & \texttt{48 83} \texttt{EC}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·101·100}}\) \emph{80} & rsp -= -80\\[0pt]
\texttt{restore OUTPUT@RDI;} & pop rdi & 58+rd & \texttt{5F} & pop rdi\\[0pt]
\texttt{restore INPUT@RSI;} & pop rsi & 58+rd & \texttt{5E} & pop rsi\\[0pt]
\texttt{return.} & ret & C3 & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org71fe63a}Subroutine \texttt{reg} dumps the registers to \texttt{STDOUT} (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}
\clearpage


\subsection{Text Interpreter}
\label{sec:org779e83c}

SmithForth has now sufficient basic tools to build its second stage,
the text interpreter.  This consists of about 20 words that we grouped
under six functionality categories:
\begin{itemize}
\item \emph{Parsing} consumes text from \texttt{INPUT} and return tokens as string. It
also handles inline and line comments.
\item \emph{Defining new Forth words} allows extending the language by
combining existing words into ``secondary'' words.  The core words
are \texttt{':'} (colon) and \texttt{';'} (semicolon), which begin and finalize
definitions.
\item \emph{Searching the dictionary} involves identifying a Forth word in the
dictionary by its textual name and returning an \emph{execution token},
or \emph{xt}.
\item \emph{Handling numbers} allows Forth definitions to contain literal
numbers.  It also permits ``executing'' numbers, which means pushing
them on the Forth data stack.
\item \emph{Compiling and executing} turns execution tokens into latent or
active effects, by either compiling calls to their code or executing
them right away.
\item Finally, \emph{bringing everything together} means being able to
repeatedly parse a new token, identify it as an existing Forth word
or as a number, executing or compiling it according to its nature.
The text interpreter is bootstrapped here, allowing for further
extension of the system in Forth itself.
\end{itemize}

We will look at the six word categories in turn.
\clearpage

\subsubsection{Parsing Forth: \texttt{REFILL}, \texttt{seek}, \texttt{PARSE}, \texttt{pname}, \texttt{(}, \texttt{\textbackslash{}}}
\label{sec:org973a49c}

The next six words defined by SmithForth work together to parse Forth
code from \texttt{INPUT}.  \texttt{REFILL} brings a new line from input to the
\emph{parse area}, which is then traversed character by character by
\texttt{seek}. \texttt{PARSE} knows how to detect the end of words or the end of the
parse area.  Finally, \texttt{pname} puts everything together, traversing the
parse area word by word, returning them as strings.

Words \texttt{'('} and \texttt{'\textbackslash{}'} handle Forth inline and line comments,
respectively.  It is worthwhile noting that many syntactical
``structures'' emerge naturally in Forth from its basic principles,
whereas in other languages they require complex parsing mechanisms.

Parsing words are built around \hyperref[tab:orgf3f861c]{global variables} \texttt{TIB}, \texttt{\#IN} and
\texttt{>IN}.  \texttt{TIB} stores the address of the current line to be parsed,
while \texttt{\#N} stores the line's length.  \texttt{>IN} counts the number of
characters already parsed.  The \emph{parse area} is defined as the range
\texttt{[TIB + >IN, TIB + \#IN)}, that is, the part of the line not yet
parsed.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{9}{10.800000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{REFILL}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{06} \uline{\texttt{52 45 46 49 4C 4C}}​\texttt{]} & define REFILL\\[0pt]
\emph{\# In/Out:} \texttt{( -​- )} &  &  &  &  & \\[0pt]
\emph{\#} &  &  &  &  & \\[0pt]
\emph{\# Advance \texttt{TIB} and set \texttt{\#IN}} &  &  &  &  & \\[0pt]
\emph{\# so that \texttt{[TIB, TIB + \#IN)}} &  &  &  &  & \\[0pt]
\emph{\# contains a new line to be} &  &  &  &  & \\[0pt]
\emph{\# parsed.} &  &  &  &  & \\[0pt]
 &  &  &  &  & \\[0pt]
\hspace{1em} \emph{\# Base address of globals.} &  &  &  &  & \\[0pt]
\hspace{1em} \texttt{VARS@R9 ← 0x10000000;} & mov r9, \emph{0x10000000} & REX.W C7 /​0 \emph{id} &  & \texttt{49 C7} \texttt{C1}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·001}}\) & r9 = VAR\\[0pt]
 &  &  &  & \hookrightarrow \emph{\texttt{00 00 00 10}} & \\[0pt]
\hspace{1em} &  &  &  &  & \\[0pt]
\hspace{1em} \emph{\# Advance \texttt{TIB}​ by \texttt{\#IN}.} &  &  &  &  & \\[0pt]
\hspace{1em} \emph{\#} &  &  &  &  & \\[0pt]
\hspace{1em} \emph{\# Note:         \texttt{\#IN} is \texttt{VARS+0},} &  &  &  &  & \\[0pt]
\hspace{1em} \emph{\# \hspace{2.35em} \texttt{TIB} is \texttt{VARS+8},} &  &  &  &  & \\[0pt]
\hspace{1em} \emph{\# \hspace{2.35em} \texttt{>IN} is \texttt{VARS+16}.} &  &  &  &  & \\[0pt]
\hspace{1em} \texttt{\#in@RAX ← [\#IN];} & mov rax, [r9] & REX.W 8B /r &  & \texttt{49 8B} \texttt{01}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·000·001}}\) & rax = [\#IN]\\[0pt]
\hspace{1em} \texttt{[TIB] += \#in@RAX;} & add [r9+0x8], rax & REX.W 01 /r &  & \texttt{49 01} \texttt{41}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·000·001}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{08}} & [TIB] += rax\\[0pt]
\hspace{1em} \emph{\# Reset \texttt{\#IN} and \texttt{>IN} to 0.} &  &  &  &  & \\[0pt]
\hspace{1em} \texttt{[\#IN] \&= 0;} & and [r9], \emph{0x0} & REX.W 83 /​4 \emph{ib} &  & \texttt{49 83} \texttt{21}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·100·001}}\) \emph{\texttt{00}} & [\#IN] = 0\\[0pt]
\hspace{1em} \texttt{[>IN] \&= 0;} & and [r9+0x10], \emph{0x0} & REX.W 83 /​4 \emph{ib} &  & \texttt{49 83} \texttt{61}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·100·001}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{10}} \emph{\texttt{00}} & [>IN] = 0\\[0pt]
\hspace{1em} &  &  &  &  & \\[0pt]
\hspace{1em} \emph{\# Advance \texttt{\#IN} until just} &  &  &  &  & \\[0pt]
\hspace{1em} \emph{\# after first \texttt{LF} character.} &  &  &  &  & \\[0pt]
\texttt{\_begin:} &  &  & \(\overline{\texttt{00}}\) &  & \_beg:\\[0pt]
\hspace{1em} \texttt{[\#IN]++;} & inc [r9] & REX.W FF /0 &  & \texttt{49 FF} \texttt{01}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·000·001}}\) & [\#IN]++\\[0pt]
\hspace{1em} \texttt{RAX ← [TIB];} & mov rax, [r9+0x8] & REX.W 8B /r &  & \texttt{49 8B} \texttt{41}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·000·001}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{08}} & rax = [TIB]\\[0pt]
\hspace{1em} \texttt{RAX += [\#IN];} & add rax, [r9] & REX.W 03 /r &  & \texttt{49 03} \texttt{01}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·000·001}}\) & rax += [\#IN]\\[0pt]
\hspace{1em} \emph{\# Newline character?} &  &  &  &  & \\[0pt]
\hspace{1em} \texttt{if [RAX - 1] != 0x0A:} & cmp [rax-0x1], \emph{0xA} & 80 /​7 \emph{ib} &  & \texttt{80} \texttt{78}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·111·000}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{FF}} \emph{\texttt{0A}} & cmp [rax-1], LF\\[0pt]
\hspace{2em}   \texttt{goto \_begin.} & jne \uline{\texttt{\_begin}} & 75 \uline{cb} &  & \texttt{75} \uline{\texttt{F0}}​\(_{\text{\tiny 00-10}}\) & -jump \_beg if !=\\[0pt]
\hspace{1em} \texttt{return.} & ret & C3 & \texttt{10} & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org8cf598d}\texttt{REFILL} replenishes the \emph{parse area} by advancing \texttt{TIB} and \texttt{\#IN} (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{seek}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{73 65 65 6B}}​\texttt{]} & define seek\\[0pt]
\emph{\# In/Out:}    \texttt{( low@CL high@DL} &  &  &  &  & \\[0pt]
\emph{\#}\hspace{4.9em}      \texttt{"ccc"} &  &  &  &  & \\[0pt]
\emph{\#}\hspace{3.35em} \texttt{-​- FLAGS )} &  &  &  &  & \\[0pt]
\emph{\#} &  &  &  &  & \\[0pt]
\emph{\# Advance \texttt{>IN} until next} &  &  &  &  & \\[0pt]
\emph{\# char is within \texttt{[low, high)}} &  &  &  &  & \\[0pt]
\emph{\# or parse area is empty.} &  &  &  &  & \\[0pt]
 &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{VARS@R9 ← 0x10000000;} & mov r9, \emph{0x10000000} & REX.W C7 /​0 \emph{id} &  & \texttt{49 C7} \texttt{C1}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·001}}\) & r9 = VAR\\[0pt]
 &  &  &  & \hookrightarrow \emph{\texttt{00 00 00 10}} & \\[0pt]
\hspace{1.053000em} \texttt{high@DL -= low@CL;} & sub dl, cl & 2A /r &  & \texttt{2A} \texttt{D1}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·010·001}}\) & dl -= cl\\[0pt]
\texttt{\_begin:} &  &  & \(\overline{\texttt{00}}\) &  & \# \_beg:  like WITHIN ( al cl dl -- eflags )\\[0pt]
\hspace{1.053000em} \emph{\# Is parse area empty?} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{>in@RAX ← [>IN];} & mov rax, [r9+0x10] & REX.W 8B /r &  & \texttt{49 8B} \texttt{41}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·000·001}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{10}} & rax = [>IN]\\[0pt]
\hspace{1.053000em} \texttt{if >in@RAX} \(\ge ^{u}\) \texttt{[\#IN]:} & cmp rax, [r9] & REX.W 3B /r &  & \texttt{49 3B} \texttt{01}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·000·001}}\) & cmp rax, [\#IN]\\[0pt]
\hspace{2.106000em}   \texttt{goto \_end.} & jae \uline{\texttt{\_end}} & 73 \uline{cb} &  & \texttt{73} \uline{\texttt{16}}​\(_{\text{\tiny 1F-09}}\) & +jump \_end if U>=\\[0pt]
\hspace{1.053000em} \emph{\# Get current character.} &  &  & \texttt{09} &  & \\[0pt]
\hspace{1.053000em} \texttt{RAX ← [TIB];} & mov rax, [r9+0x8] & REX.W 8B /r &  & \texttt{49 8B} \texttt{41}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·000·001}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{08}} & rax = [TIB]\\[0pt]
\hspace{1.053000em} \texttt{RAX += [>IN];} & add rax, [r9+0x10] & REX.W 03 /r &  & \texttt{49 03} \texttt{41}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·000·001}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{10}} & rax += [>IN]\\[0pt]
\hspace{1.053000em} \texttt{chr@AL ← [RAX];} & mov al, [rax] & 8A /r &  & \texttt{8A} \texttt{00}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·000·000}}\) & al = [rax]\\[0pt]
\hspace{1.053000em} \emph{\# Is \texttt{chr} in \texttt{[low, high)}?} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{chr'@AL -= low@CL;} & sub al, cl & 2A /r &  & \texttt{2A} \texttt{C1}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·001}}\) & al -= cl\\[0pt]
\hspace{1.053000em} \texttt{if chr'@AL} \textless{}\(^{u}\) \texttt{high@DL:} & cmp al, dl & 3A /r &  & \texttt{3A} \texttt{C2}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·010}}\) & cmp al, dl\\[0pt]
\hspace{2.106000em}   \texttt{goto \_end.} & jb \uline{\texttt{\_end}} & 72 \uline{cb} &  & \texttt{72} \uline{\texttt{06}}​\(_{\text{\tiny 1F-19}}\) & +jump \_end if U<\\[0pt]
\hspace{1.053000em} \emph{\# Go to next character.} &  &  & \texttt{19} &  & \\[0pt]
\hspace{1.053000em} \texttt{[>IN]++;} & inc [r9+0x10] & REX.W FF /0 &  & \texttt{49 FF} \texttt{41}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·000·001}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{10}} & [>IN]++\\[0pt]
\hspace{1.053000em} \texttt{goto \_begin.} & jmp \uline{\texttt{\_begin}} & EB \uline{cb} &  & \texttt{EB} \uline{\texttt{E1}}​\(_{\text{\tiny 00-1F}}\) & -jump \_beg\\[0pt]
\texttt{\_end:} &  &  & \texttt{1F} &  & \# \_end:\\[0pt]
\hspace{1.053000em} \texttt{return.} & ret & C3 &  & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orge428318}Subroutine \texttt{seek} parses characters until it finds one in a given range (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{PARSE}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{50 41 52 53 45}}​\texttt{]} & define PARSE\\[0pt]
\emph{\# In/Out:}    \texttt{( low@CL high@DL} &  &  &  &  & \\[0pt]
\emph{\#}\hspace{4.9em}     ​\texttt{"ccc<char>"} &  &  &  &  & \\[0pt]
\emph{\#}\hspace{3.35em}​ \texttt{-​- addr@RBP u@RAX )} &  &  &  &  & \\[0pt]
\emph{\#} &  &  &  &  & \\[0pt]
\emph{\# Parse until end of parse area} &  &  &  &  & \\[0pt]
\emph{\# or until a character in range} &  &  &  &  & \\[0pt]
\emph{\# \texttt{[low, high)} is encountered.} &  &  &  &  & \\[0pt]
\emph{\# Return parsed string as its} &  &  &  &  & \\[0pt]
\emph{\# address and length.} &  &  &  &  & \\[0pt]
 &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{VARS@R9 ← 0x10000000;} & mov r9, \emph{0x10000000} & REX.W C7 /​​0 \emph{id} &  & \texttt{49 C7} \texttt{C1}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·001}}\) & r9 = VAR\\[0pt]
 &  &  &  & \hookrightarrow \emph{\texttt{00 00 00 10}} & \\[0pt]
\hspace{1.053000em} \texttt{start@RBP ← [>IN];} & mov rbp, [r9+0x10] & REX.W 8B /r &  & \texttt{49 8B} \texttt{69}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·101·001}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{10}} & rbp = [>IN]\\[0pt]
\hspace{1.053000em} \emph{\# Compile a call to \texttt{seek}} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# that advances \texttt{>IN}.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{call seek;}  \emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{73}​\(_{s}\)​\texttt{]} & Call seek  (parse until 1st instance within [cl, dl) is parsed or parse area empty)\\[0pt]
\hspace{1.053000em} \texttt{end@RAX ← [>IN];} & mov rax, [r9+0x10] & REX.W 8B /r &  & \texttt{49 8B} \texttt{41}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·000·001}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{10}} & rax = [>IN]\\[0pt]
\hspace{1.053000em} \emph{\# Did \texttt{seek()} encounter the} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# end of the parse area? In} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# this case the first CMP in} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# \texttt{seek} will have left the} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# carry flag unset \citeprocitem{19}{[19]}.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if CF = 0:} &  &  &  &  & \\[0pt]
\hspace{2.106000em}   \texttt{goto \_end.} & jae \uline{\texttt{\_end}} & 73 \uline{cb} &  & \texttt{73} \uline{\texttt{04}}​\(_{\text{\tiny 04-00}}\) & +jump \_end if U>=\\[0pt]
\hspace{1.053000em} \emph{\# A character in range} &  &  & \(\overline{\texttt{00}}\) &  & \\[0pt]
\hspace{1.053000em} \emph{\# \texttt{[low, high)} was found.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{[>IN]++;}  \emph{\# Skip it.} & inc [r9+0x10] & REX.W FF /0 &  & \texttt{49 FF} \texttt{41}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·000·001}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{10}} & [>IN]++\\[0pt]
\texttt{\_end:} &  &  & \texttt{04} &  & \# \_end:\\[0pt]
\hspace{1.053000em} \emph{\# Compute address and} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# length of parsed input.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{u@RAX ← end@RAX} & sub rax, rbp &  &  &  & \\[0pt]
\hspace{4.212000em}       \texttt{- start@RBP;} &  & REX.W 29 /r &  & \texttt{48 29} \texttt{E8}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·101·000}}\) & rax -= rbp\\[0pt]
\hspace{1.053000em} \texttt{addr@RBP ← start@RBP} & add rbp, [r9+0x8] & REX.W 03 /r &  & \texttt{49 03} \texttt{69}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·101·001}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{08}} & rbp += [TIB]\\[0pt]
\hspace{5.791500em}          \texttt{+ [TIB];} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{return.} & ret & C3 &  & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgdbb40ce}\texttt{PARSE} returns the address and size of a newly parsed string (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{pname}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{05} \uline{\texttt{70 6E 61 6D 65}}​\texttt{]} & define pname\\[0pt]
\emph{\# In/Out:}   \texttt{( "<SPCs>ccc<SPC>"} &  &  &  & \\[0pt]
\emph{\#}\hspace{3.35em} \texttt{-​- addr@RBP u@RAX )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Parse a token: first skip over} &  &  &  & \\[0pt]
\emph{\# non-printable characters, then} &  &  &  & \\[0pt]
\emph{\# parse the word itself.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\emph{\# Skip non-printables.} &  &  &  & \\[0pt]
\texttt{low@CL ← 0x21;}   \emph{\# Char \texttt{'!'}.} & mov cl, \emph{0x21} & B0+rb \emph{ib} & \texttt{B1} \emph{\texttt{21}} & \\[0pt]
\texttt{high@DL ← 0x7F;}  \emph{\# Char \texttt{DEL}.} & mov dl, \emph{0x7F} & B0+rb \emph{ib} & \texttt{B2} \emph{\texttt{7F}} & (cl, dl) = (BL+1, \ldots{})\\[0pt]
\texttt{call seek;}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{73}​\(_{s}\)​\texttt{]} & Call seek\\[0pt]
\emph{\# Parse token, stopping at first} &  &  &  & \\[0pt]
\emph{\# non-printable character.} &  &  &  & \\[0pt]
\texttt{low@CL ← 0x7F;} & mov cl, \emph{0x7F} & B0+rb \emph{ib} & \texttt{B1} \emph{\texttt{7F}} & \\[0pt]
\texttt{high@DL ← 0x21;} & mov dl, \emph{0x21} & B0+rb \emph{ib} & \texttt{B2} \emph{\texttt{21}} & (cl, dl) = (\ldots{}, BL+1)\\[0pt]
\texttt{call PARSE;}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{50}​\(_{P}\)​\texttt{]} & Call PARSE\\[0pt]
\texttt{return.} & ret & C3 & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgef30589}Subroutine \texttt{pname} parses a token and returns it as a string (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define immediate:} \uline{\texttt{\textbackslash{}}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{81} \uline{\texttt{5C}}​\texttt{]} & define $\backslash$\\[0pt]
\emph{\# In/Out:} \texttt{( "ccc<eol>"} &  &  &  & \\[0pt]
\emph{\#}\hspace{3.35em} \texttt{-​- )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Consumes all characters} &  &  &  & \\[0pt]
\emph{\# left on the current line.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\texttt{RAX ← [\#IN];} & mov rax, \emph{0x10000000} & REX.W 8B /r & \texttt{48 8B} \texttt{04}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·000·100}}\) \texttt{25}​\(^{\text{\tiny    SIB}}_{\text{\tiny 25·00·100}}\) & rax = [\#IN]\\[0pt]
 &  &  & \hookrightarrow \hspace{1.053000em} \(^{\text{\tiny +}}\)​\uline{\texttt{00 00 00 10}} & \\[0pt]
\texttt{[>IN] ← RAX;} & mov \emph{0x10000010}, rax & REX.W 89 /r & \texttt{48 89} \texttt{04}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·000·100}}\) \texttt{25}​\(^{\text{\tiny    SIB}}_{\text{\tiny 25·00·100}}\) & [>IN] = rax\\[0pt]
 &  &  & \hookrightarrow \hspace{1.053000em} \(^{\text{\tiny +}}\)​\uline{\texttt{10 00 00 10}} & \\[0pt]
\texttt{return.} & ret & C3 & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org65ce2dd}Subroutine \texttt{'\textbackslash{}'} implements line comments (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define immediate:} \uline{\texttt{(}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{81} \uline{\texttt{28}}​\texttt{]} & define (\\[0pt]
\emph{\# In/Out:} \texttt{( "ccc<rparen>" -​- )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Consume characters until a ')' occurs.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\texttt{low@CL ← ')';} & mov cl, \emph{0x29} & B0+rb \emph{ib} & \texttt{B1} \emph{\texttt{29}} & \\[0pt]
\texttt{high@DL ← ')' + 1;} & mov dl, \emph{0x2A} & B0+rb \emph{ib} & \texttt{B2} \emph{\texttt{2A}} & (cl, dl) = (RP, RP+1)\\[0pt]
\texttt{call PARSE;}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{50}​\(_{P}\)​\texttt{]} & Call PARSE            Forth 2012 implies comment ends at rparen or newline.\\[0pt]
\texttt{return.} & ret & C3 & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org0627679}Subroutine \texttt{'('} implements inline comments (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

Note that comment-handling words \texttt{'\textbackslash{}'} and \texttt{'('} appear in the
original SmithForth source code after \texttt{'['} and \texttt{']'}.  We preferred
to present them here, directly after the other words related to
parsing.
\clearpage

\subsubsection{Defining New Forth Words: \texttt{:}, \texttt{;}, \texttt{[}, \texttt{]}, \texttt{.}, \texttt{LIT}}
\label{sec:org23d811c}

The next six Forth words are probably the most interesting in
SmithForth.  They enable defining new words with convenient syntax,
but unexpected power.  In particular, the ability to enter and exit
interpretation mode with \texttt{'['} and \texttt{']'} allows mixing compile-time
and run-time effects.  This will be used extensively in the last
chapter, where we extend the basic Forth system in Forth itself.

Subroutine \texttt{':'} (colon), shown in Table \ref{tab:org5eccf6a}, parses the
next word available at input and calls \texttt{Head} to create a new
dictionary entry.  It takes care to ``hide'' it for the duration of
the definition by enabling the \texttt{HIDDEN} flag on the entry.  Finally,
colon switches to compilation mode by calling \texttt{']'}.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{':'}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{01} \uline{\texttt{3A}}​\texttt{]} & define :\\[0pt]
\emph{\# In/Out:} \texttt{( "<SPCs>ccc<SPC>" -​- )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Start a word definition and enter} &  &  &  & \\[0pt]
\emph{\# compiling mode. Temporarily hide} &  &  &  & \\[0pt]
\emph{\# the word being defined until its} &  &  &  & \\[0pt]
\emph{\# definition is completed by \texttt{';'}.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\emph{\# Parse word name and create} &  &  &  & \\[0pt]
\emph{\# its dictionary entry.} &  &  &  & \\[0pt]
\texttt{call pname;}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{70}​\(_{p}\)​\texttt{]} & Call pname  (See Forth 2012 Table 2.1)\\[0pt]
\texttt{INPUT@RSI ← addr@RBP;} & MOV r/m64, r64 & REX.W 89 /r & \texttt{48 89} \texttt{EE}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·101·110}}\) & rsi = rbp\\[0pt]
\texttt{latest@RDX ← LATEST;} & MOV r32, \emph{imm32} & B8+rd \emph{id} & \texttt{BA} \emph{\texttt{28 00 00 10}} & rdx = Latest\\[0pt]
\emph{\# Word length \texttt{u@RAX} is forwarded} &  &  &  & \\[0pt]
\emph{\# as \texttt{flag@AL} to \texttt{Head}.} &  &  &  & \\[0pt]
\texttt{call Head;}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{48}​\(_{H}\)​\texttt{]} & Call Head\\[0pt]
 &  &  &  & \\[0pt]
\emph{\# Set the \texttt{HIDDEN} bit (\texttt{0x40}) on} &  &  &  & \\[0pt]
\emph{\# the dictionary entry's flag.} &  &  &  & \\[0pt]
\texttt{xt@RCX ← [latest@RDX];} & MOV r64, r/m64 & REX.W 8B /r & \texttt{48 8B} \texttt{0A}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·001·010}}\) & rcx = [rdx]\\[0pt]
\texttt{flag@RCX ← xt@RCX + 16;} & ADD r/m64, \emph{imm8} & 9REX.W 83 /​0 \emph{ib} & \texttt{48 83} \texttt{C1}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·001}}\) \emph{\texttt{10}} & rcx += 10\\[0pt]
\texttt{[flag@RCX]} \(\vert{}\)​\texttt{=} \texttt{0x40;} & OR r/m8, \emph{imm8} & 80 /​1 \emph{ib} & \texttt{80} \texttt{09}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·001·001}}\) \emph{\texttt{40}} & [rcx] ¦= 40 HIDDEN\\[0pt]
 &  &  &  & \\[0pt]
\emph{\# Switch to compiling state.} &  &  &  & \\[0pt]
\texttt{call ];}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{5D}​\(_{]}\)​\texttt{]} & Call ]\\[0pt]
\texttt{return.} & RET & C3 & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org5eccf6a}\texttt{':'} sets up a word's dictionary entry and begins compilation (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

Forth word \texttt{';'} (semicolon), displayed in Table
\ref{tab:orgfc9dcc0}, finalizes a word definiton by compiling a
return instruction.  It then ``unhides'' the word by flipping its
\texttt{HIDDEN} flag in the dictionary entry and switches back to
interpreting mode.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define immediate:} \uline{\texttt{;}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{81} \uline{\texttt{3B}}​\texttt{]} & define ;\\[0pt]
\emph{\# In/Out:} \texttt{( C: -​- )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Finalize a colon definition and} &  &  &  & \\[0pt]
\emph{\# switch back to interpreting state.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\emph{\# Write a RET instr. to \texttt{OUTPUT}.} &  &  &  & \\[0pt]
\texttt{op@AL ← 0xC3;}  \emph{\# RET opcode.} & MOV r8, \emph{imm8} & B0+rb \emph{ib} & \texttt{B0} \emph{\texttt{C3}} & al = opcode ret\\[0pt]
\texttt{[OUTPUT@RDI++] ← op@AL;} & STOS m8 & AA & \texttt{AA} & [rdi++] = al\\[0pt]
 &  &  &  & \\[0pt]
\emph{\# Clear the \texttt{HIDDEN} bit (\texttt{0x40}) on} &  &  &  & \\[0pt]
\emph{\# the dictionary entry's flag.} &  &  &  & \\[0pt]
\texttt{xt@RCX ← [LATEST];} & MOV r64, r/m64 & REX.W 8B /r & \texttt{48 8B} \texttt{0C}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·001·100}}\) \texttt{25}​\(^{\text{\tiny    SIB}}_{\text{\tiny 25·00·100}}\) & rcx = [Latest]\\[0pt]
 &  &  & \hookrightarrow \(^{\text{\tiny +}}\)​\uline{\texttt{28 00 00 10}} & \\[0pt]
\texttt{flag@RCX ← xt@RCX + 0x10;} & ADD r/m64, \emph{imm8} & REX.W 83 /​0 \emph{ib} & \texttt{48 83} \texttt{C1}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·001}}\) \emph{10} & rcx += 10\\[0pt]
\texttt{[flag@RCX] \&= 0b10111111;} & AND r/m8, \emph{imm8} & 80 \emph{4 /ib} & \texttt{80} \texttt{21}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·100·001}}\) \emph{BF} & [rcx] \&= BF(\textasciitilde{}HIDDEN)\\[0pt]
 &  &  &  & \\[0pt]
\emph{\# Switch to interpreting state.} &  &  &  & \\[0pt]
\texttt{call lbracket;}  \emph{\# Compiled.} &  &  & \texttt{[99} \(^{c}\)​\texttt{5B}​\(_{[}\)​\texttt{]} & Call [\\[0pt]
\texttt{return.} & RET & C3 & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgfc9dcc0}\texttt{';'} wraps up a colon definition and goes back to interpreting (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

As already mentioned in the explanations of \texttt{':'} and \texttt{';'}, two words
can be used in the middle of definitions (but not only) to switch in
and out of interpreting state.  This enables many tricks by allowing
mixed compilation-time and run-time code execution.  The two
subroutines, listed in tables \ref{tab:orgf59f753} and
\ref{tab:orgef7f625}, have surprisingly simple implementations.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define immediate:} \uline{\texttt{[}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{81} \uline{\texttt{5B}}​\texttt{]} & define [\\[0pt]
\emph{\# In/Out:} \texttt{( -​- )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Switch to interpreting state.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\emph{\# Set \texttt{STATE} to 0.} &  &  &  & \\[0pt]
\texttt{push 0;} & PUSH \emph{imm8} & 6A \emph{ib} & \texttt{6A} \emph{\texttt{00}} & push 0(Interpreting)\\[0pt]
\texttt{[STATE] ← pop;} & POP r/m64 & 8F /0 & \texttt{8F} \texttt{04}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·000·100}}\) \texttt{25}​\(^{\text{\tiny    SIB}}_{\text{\tiny 25·00·100}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{20 00 00 10}} & pop [STATE]\\[0pt]
\texttt{return.} & RET & C3 & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgf59f753}Subroutine \texttt{'['} changes Forth's \texttt{STATE} to interpreting (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\pagebreak
\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{]}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{01} \uline{\texttt{5D}}​\texttt{]} & define ]\\[0pt]
\emph{\# In/Out:} \texttt{( -​- )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Switch to compiling state.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\emph{\# Set \texttt{STATE} to 1.} &  &  &  & \\[0pt]
\texttt{push 1;} & PUSH \emph{imm8} & 6A \emph{ib} & \texttt{6A} \emph{\texttt{01}} & push 1(Compiling)\\[0pt]
\texttt{[STATE] ← pop;} & POP r/m64 & 8F /0 & \texttt{8F} \texttt{04}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·000·100}}\) \texttt{25}​\(^{\text{\tiny    SIB}}_{\text{\tiny 25·00·100}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{20 00 00 10}} & pop [STATE]\\[0pt]
\texttt{return.} & RET & C3 & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgef7f625}Subroutine \texttt{']'} changes Forth's \texttt{STATE} to compiling (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

Note that both \texttt{'['} and \texttt{']'} are \emph{immediate} words, which means, as
we will see later, that they are executed right away when encountered
in definitions instead of being compiled as a call sequence like
non-immediate words are.

The following word, shown in Table \ref{tab:orgf1bb22b}, is equivalent in
functionality to standard Forth word \texttt{'C,'}​. It pops a byte off the
data stack and writes it, literally, to \texttt{OUTPUT}.  This word is used
extensively by SmithForth in \texttt{system.fs} to (sometimes dynamically!)
generate machine code in Forth.  We will use it as well in our
Forth-in-Forth stage to write \ldots{} an assembler!

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{.}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{01} \uline{\texttt{2E}}​\texttt{]} & define .\\[0pt]
\emph{\# In/Out:} \texttt{( u -​- )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Non-standard name for \texttt{C,}.} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Pop a byte off the stack and} &  &  &  & \\[0pt]
\emph{\# write it to \texttt{OUTPUT}.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\texttt{byte@AL ← [STACK@R15]} & MOV r8, r/m8 & REX 8A /r & \texttt{41 8A} \texttt{07}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·000·111}}\) & al = [r15]\\[0pt]
\texttt{STACK@R15 += 8;} & ADD r/m64, \emph{imm8} & REX.W 83 /​0 \emph{ib} & \texttt{49 83} \texttt{C7}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·111}}\) \emph{08} & r15 += 8\\[0pt]
\texttt{[OUTPUT@RDI++] ← byte@AL;} & STOS m8 & AA & \texttt{AA} & [rdi++] = al\\[0pt]
\texttt{return.} & RET & C3 & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgf1bb22b}Subroutine \texttt{'.'} compiles a byte from the stack to \texttt{OUTPUT} (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

Displayed in Table \ref{tab:org8a5af1e} is Forth word \texttt{LIT}, which is used
to compile a number literally in a colon definition.  This allows
Forth to achieve the same interpretation semantics of numbers (they're
pushed on the stack) inside and outside colon definitions
\citeprocitem{3}{[3]}.  In SmithForth's x86-64 implementation
\texttt{LIT} compiles a number into the current definition as a sequence of
instructions that first allocates a slot on the data stack (a \texttt{SUB}
instruction) and then copies the number into the slot (a pair of
\texttt{PUSH} and \texttt{POP} instructions).

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define immediate:} \uline{\texttt{LIT}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{83} \uline{\texttt{4C 49 54}}​\texttt{]} & define LIT\\[0pt]
\emph{\# In/Out:} \texttt{( C: x -​- ) ( -{}-{} x )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Pop a byte off the data stack at compile time.} &  &  &  & \\[0pt]
\emph{\# Compile it as the immediate byte of a PUSH} &  &  &  & \\[0pt]
\emph{\# instruction that inserts it on the data stack} &  &  &  & \\[0pt]
\emph{\# when the word being defined is executed.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\emph{\# Let \texttt{lit} be the top byte on the data stack.} &  &  &  & \\[0pt]
\emph{\# We will generate three instructions that will} &  &  &  & \\[0pt]
\emph{\# effectively push \texttt{lit} on the data stack at} &  &  &  & \\[0pt]
\emph{\# execution time:} &  &  &  & \\[0pt]
\emph{\# – a SUB instruction that allocates a slot on} &  &  &  & \\[0pt]
\emph{\# the data stack;} &  &  &  & \\[0pt]
\emph{\# – a pair of PUSH \& POP instructions that} &  &  &  & \\[0pt]
\emph{\# copy \texttt{lit} to the newly allocated slot.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\emph{\# 1. SUB instruction:} &  &  &  & \\[0pt]
\emph{\# – effect: \texttt{R15 -= 8;}} &  &  &  & \\[0pt]
\emph{\# – instruction: SUB r/m64, imm8} &  &  &  & \\[0pt]
\emph{\# – opcode: REX.W 83 /5 ib} &  &  &  & \\[0pt]
\emph{\# – machine code: \texttt{49 83} \texttt{EF}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·101·111}}\) \texttt{08}} &  &  &  & \\[0pt]
\texttt{EAX ← 0x08EF8349;} & MOV r32, \emph{imm32} & B8+rd \emph{id} & \texttt{B8} \emph{49 83 EF 08} & eax = "r15 -= 8"\\[0pt]
\texttt{[OUTPUT@RDI++4] ← EAX;} & STOS m32 & AB & \texttt{AB} & [rdi(++4)] = eax\\[0pt]
 &  &  &  & \\[0pt]
\emph{\# 2. PUSH instruction:} &  &  &  & \\[0pt]
\emph{\# – effect: \texttt{push lit;}} &  &  &  & \\[0pt]
\emph{\# – instruction: PUSH imm8} &  &  &  & \\[0pt]
\emph{\# – opcode: 6A ib} &  &  &  & \\[0pt]
\emph{\# – machine code: \texttt{6A ??} (imm. ignored for now)} &  &  &  & \\[0pt]
\emph{\# Here we only write 0x6A to \texttt{OUTPUT}. Note that} &  &  &  & \\[0pt]
\emph{\# the three bytes of the next instruction are also} &  &  &  & \\[0pt]
\emph{\# loaded in EAX at this step, but not yet written.} &  &  &  & \\[0pt]
\texttt{EAX ← 0x078F416A;} & MOV r32, \emph{imm32} & B8+rd \emph{id} & \texttt{B8} \emph{6A 41 8F 07} & eax = push x; pop [r15]\\[0pt]
\texttt{[OUTPUT@RDI++] ← AL;}  \emph{\# Writes only \texttt{0x6A}.} & STOS m8 & AA & \texttt{AA} & [rdi++] = al\\[0pt]
 &  &  &  & \\[0pt]
\emph{\# 3. POP instruction:} &  &  &  & \\[0pt]
\emph{\# – effect: \texttt{[R15] ← pop;}} &  &  &  & \\[0pt]
\emph{\# – instruction: POP r/m64} &  &  &  & \\[0pt]
\emph{\# – opcode: REX 8F /0} &  &  &  & \\[0pt]
\emph{\# – machine code: \texttt{41 8F} \texttt{07}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·000·111}}\)} &  &  &  & \\[0pt]
\emph{\# Here we write the immediate byte of the PUSH} &  &  &  & \\[0pt]
\emph{\# instruction (in AL) and the POP instruction} &  &  &  & \\[0pt]
\emph{\# (in the rest of EAX).} &  &  &  & \\[0pt]
\texttt{AL ← [STACK@R15];} & MOV r8, r/m8 & REX 8A /r & \texttt{41 8A} \texttt{07}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·000·111}}\) & al = [r15]\\[0pt]
\texttt{[OUTPUT@RDI++4] ← EAX;} &  &  & \texttt{AB} & [rdi(++4)] = eax\\[0pt]
 &  &  &  & \\[0pt]
\emph{\# Pop \texttt{lit} off the data stack.} &  &  &  & \\[0pt]
\texttt{STACK@R15 += 8;} & ADD r/m64, \emph{imm8} & REX.W 83 /​0 \emph{ib} & \texttt{49 83} \texttt{C7}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·111}}\) \emph{08} & r15 += 8\\[0pt]
\texttt{return.} & RET & C3 & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org8a5af1e}Subroutine \texttt{LIT} compiles a literal byte into a word definition (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}
\clearpage

\subsubsection{Searching the Dictionary: \texttt{xt=}, \texttt{FIND}}
\label{sec:org542b38b}

The next problem SmithForth solves is that of finding words by name in
the dictionary.  This is achieved using two words, which we will
examine in turn.

Shown in Table \ref{tab:orgdc1f4b6} is \texttt{xt=}, which tests whether a word
given by its \emph{execution token} (argument \emph{xt}) has its name equal to a
given string (arguments \texttt{addr} and \texttt{u}).  A few observations are worth
making.  First, the test fails if the word is hidden: this is to
prevent colon definitions to reference themselves before they are
complete.  Secondly, being designed for the x86-64 architecture,
SmithForth uses a combined \texttt{REPE CMPS} instruction for the string
comparison.  This will need to be replaced with an explicit loop in
our RISC-V implementation.  Another feature specific to x86-64 is the
use of the implicit \texttt{RFLAGS} to pass information between instructions
(and even subroutines).  The \texttt{ZF} flag set here by SmithForth is only
read in \texttt{FIND}.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{xt=}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{03} \uline{\texttt{78 74 3D}}​\texttt{]} & define xt=\\[0pt]
\emph{\# In/Out:}    \texttt{( addr@RBP u@RAX xt@RBX} &  &  &  &  & \\[0pt]
\emph{\#}\hspace{3.35em} \texttt{-​- xt@RBX FLAGS} &  &  &  &  & \\[0pt]
\emph{\#}\hspace{4.9em}      \texttt{?@RAX ?@RDI )} &  &  &  &  & \\[0pt]
\emph{\#} &  &  &  &  & \\[0pt]
\emph{\# Return with \texttt{ZF} set if execution token} &  &  &  &  & \\[0pt]
\emph{\# \texttt{xt} is either zero or is not hidden and} &  &  &  &  & \\[0pt]
\emph{\# its name matches the string given by} &  &  &  &  & \\[0pt]
\emph{\# address \texttt{addr} and length \texttt{u}.} &  &  &  &  & \\[0pt]
 &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# Return (with \texttt{ZF} set) if \texttt{xt} is zero.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if xt@RBX \& xt@RBX != 0:} & TEST r/m64, r64 & REX.W 85 /r &  & \texttt{48 85} \texttt{DB}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·011·011}}\) & rbx(xt) ?\\[0pt]
\hspace{2.106000em}   \texttt{goto \_nonzero.} & JNZ \uline{rel8} & 75 \uline{cb} &  & \texttt{75} \uline{\texttt{01}}​\(_{\text{\tiny 01-00}}\) & +jump \_nonzero if != 0\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 & \(\overline{\texttt{00}}\) & \texttt{C3} & return\\[0pt]
\texttt{\_nonzero:} &  &  & \texttt{01} &  & \_nonzero:\\[0pt]
\hspace{1.053000em} \emph{\# Save \texttt{u} in RCX; to be used later.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{u@RCX ← u@RAX;} & MOV r64, r/m64 & REX.W 8B /r &  & \texttt{48 8B} \texttt{C8}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·001·000}}\) & rcx = rax(u)\\[0pt]
\hspace{1.053000em} \emph{\# Point RSI to the flag field.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{RSI ← xt@RBX + 0x10;} & LEA r64,m & REX.W 8D /r &  & \texttt{48 8D} \texttt{73}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·110·011}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{10}} & rsi = rbx(xt) + 10\\[0pt]
\hspace{1.053000em} \emph{\# Extract flag and advance RSI} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# to the name field (used later).} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{flag@AL ← [RSI++];} & LODS m8 & AC &  & \texttt{AC} & al = [rsi++]\\[0pt]
\hspace{1.053000em} \emph{\# Return (\texttt{ZF} unset) if hidden word.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if flag@AL \& 0x40 = 0:} & TEST AL, \emph{imm8} & A8 \emph{ib} &  & \texttt{A8} \emph{\texttt{40}} & al \& 40(HIDDEN) ?\\[0pt]
\hspace{2.106000em}   \texttt{goto \_unhidden.} & JZ \uline{rel8} & 74 \uline{cb} &  & \texttt{74} \uline{\texttt{01}}​\(_{\text{\tiny 01-00}}\) & +jump \_unhidden if == 0\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 & \(\overline{\texttt{00}}\) & \texttt{C3} & return\\[0pt]
\texttt{\_unhidden:} &  &  & \texttt{01} &  & \_unhidden:\\[0pt]
\hspace{1.053000em} \emph{\# Keep only name length in RAX.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{length@RAX ← flag@RAX \& 0x1F;} & AND r/m64, \emph{imm8} & REX.W 83 /​4 \emph{ib} &  & \texttt{48 83} \texttt{E0}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·100·000}}\) \emph{\texttt{1F}} & rax \&= 1F(Length)\\[0pt]
\hspace{1.053000em} \emph{\# Return (\texttt{ZF} unset) if wrong length.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if length@RAX = u@RCX:} & CMP r/m64, r64 & REX.W 39 /r &  & \texttt{48 39} \texttt{C8}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·001·000}}\) & cmp rax, rcx\\[0pt]
\hspace{2.106000em}   \texttt{goto \_length\_equal.} & JE \uline{rel8} & 74 \uline{cb} &  & \texttt{74} \uline{\texttt{01}}​\(_{\text{\tiny 01-00}}\) & +jump \_lengthEq if ==\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 & \(\overline{\texttt{00}}\) & \texttt{C3} & return\\[0pt]
\texttt{\_length\_equal:} &  &  & \texttt{01} &  & \_lengthEq:\\[0pt]
\hspace{1.053000em} \emph{\# Compare \texttt{addr@RBP} and \texttt{name@RSI}} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# upto length \texttt{u@RCX}.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{addr@RDI ← addr@RBP;} & MOV r64, r/m64 & REX.W 8B /r &  & \texttt{48 8B} \texttt{FD}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·111·101}}\) & rdi = rbp\\[0pt]
\hspace{1.053000em} \texttt{strncmp(name@RSI,} &  &  &  &  & \\[0pt]
\hspace{5.265000em}        \texttt{addr@RDI,} &  &  &  &  & \\[0pt]
\hspace{5.265000em}        \texttt{u@RCX);}  \emph{\# (Un)sets \texttt{ZF}.} & REPE CMPS m8, m8 & F3 A6 &  & \texttt{F3 A6} & strings equal ?\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 &  & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgdc1f4b6}\texttt{xt=} compares an execution token's name with a given string (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

Subroutine \texttt{FIND}, listed in Table \ref{tab:orge4b4d29}, performs a linear
search through the dictionary using \texttt{xt=} as a test method.  As
discussed above, \texttt{FIND} uses the \texttt{ZF} flag set by \texttt{xt=}.  We would
prefer to see explicit information passing here.  In fact, the RISC-V
designers entirely removed the flags register, so we will find an
alternative solution in our RISC-V implementation.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{FIND}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{46 49 4E 44}}​\texttt{]} & define FIND\\[0pt]
\emph{\# In/Out:}    \texttt{( addr@RBP u@RAX} &  &  &  &  & \\[0pt]
\emph{\#}\hspace{3.35em} \texttt{-{}-{} addr@RBP u@RAX} &  &  &  &  & \\[0pt]
\emph{\#}\hspace{4.9em}      \texttt{xt@RBX )} &  &  &  &  & \\[0pt]
\emph{\#} &  &  &  &  & \\[0pt]
\emph{\# Search the dictionary for a} &  &  &  &  & \\[0pt]
\emph{\# word with name matching} &  &  &  &  & \\[0pt]
\emph{\# \texttt{addr}​/​\texttt{u}. Return \texttt{xt = 0} if} &  &  &  &  & \\[0pt]
\emph{\# no matching word is found.} &  &  &  &  & \\[0pt]
 &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# Begin search at \texttt{LATEST}.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{xt@RBX ← [LATEST];} & MOV r64, r/m64 & REX.W 8B /r &  & \texttt{48 8B} \texttt{1C}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·011·100}}\) \texttt{25}​\(^{\text{\tiny    SIB}}_{\text{\tiny 25·00·100}}\) & rbx = [Latest]\\[0pt]
 &  &  &  & \hookrightarrow \(^{\text{\tiny +}}\)​\uline{\texttt{28 00 00 10}} & \\[0pt]
\texttt{\_begin:} &  &  & \(\overline{\texttt{00}}\) &  & \# \_beg:\\[0pt]
\hspace{1.053000em} \texttt{call FIND();} & CALL \uline{rel32} & E8 \uline{cd} &  & \texttt{E8} \uline{\texttt{03 00 00 00}}​\(_{\text{\tiny 05-02}}\) & +call (FIND)\\[0pt]
\hspace{1.053000em} \texttt{if !ZF:} &  &  & \texttt{05} &  & \\[0pt]
\hspace{2.106000em}   \texttt{goto \_begin.} & JNE \uline{rel8} & 75 \uline{cb} &  & \texttt{75} \uline{\texttt{F9}}​\(_{\text{\tiny 00-07}}\) & -jump \_beg if !=\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 & \texttt{07} & \texttt{C3} & return\\[0pt]
\texttt{FIND():} &  &  & \texttt{08} &  & (FIND):\\[0pt]
\hspace{1.053000em} \emph{\# Save registers.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{push RAX;} & PUSH r64 & 50+rd &  & \texttt{50} & push rax\\[0pt]
\hspace{1.053000em} \texttt{push RDI;} & PUSH r64 & 50+rd &  & \texttt{57} & push rdi\\[0pt]
\hspace{1.053000em} \emph{\# Does \texttt{xt} match \texttt{addr}​/​\texttt{u}?} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{call xt=;}  \emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{78}​\(_{x}\)​\texttt{]} & Call xt=\\[0pt]
\hspace{1.053000em} \texttt{pop RDI;} & POP r64 & 58+rd &  & \texttt{5F} & pop rdi\\[0pt]
\hspace{1.053000em} \texttt{pop RAX;} & POP r64 & 58+rd &  & \texttt{58} & pop rax\\[0pt]
\hspace{1.053000em} \emph{\# If matched, we're done!} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# Otherwise, follow \texttt{xt}'s} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# link pointer.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if ZF:}  \emph{\# Set by \texttt{xt=()}.} &  &  &  &  & +jump \_end if ==\\[0pt]
\hspace{2.106000em}   \texttt{goto \_end.} & JE \uline{rel8} & 74 \uline{cb} &  & \texttt{74} \uline{\texttt{04}}​\(_{\text{\tiny 04-00}}\) & \\[0pt]
\hspace{1.053000em} \texttt{xt@RBX ← [xt@RBX + 8];} & MOV r64, r/m64 & REX.W 8B /r & \(\overline{\texttt{00}}\) & \texttt{48 8B} \texttt{5B}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·011·011}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{08}} & rbx = [rbx+8]\\[0pt]
\texttt{\_end:} &  &  & \texttt{04} &  & \# \_end:\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 &  & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orge4b4d29}\texttt{FIND} searches the dictionary for a word matching a given name (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}
\clearpage

\subsubsection{Handling Numbers: \texttt{Num}, \texttt{miss}}
\label{sec:org34d8514}

When a token is not found in the Forth dictionary, it is assumed to be
a number which is either compiled or executed, depending on whether it
occurs in a colon definition or not.  To enable this behavior
SmithForth implements \texttt{Num}, which converts a string to a number and
places it on the data stack.  The implementation, shown in Table
\ref{tab:org9f2066b}, is straightforward.  Note that SmithForth expects
numbers to be given in uppercase hexadecimal notation.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{Num}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{03} \uline{\texttt{4E 75 6D}}​\texttt{]} & define Num\\[0pt]
\emph{\# In/Out:}    \texttt{( addr@RBP u@RAX} &  &  &  &  & \\[0pt]
\emph{\#}\hspace{3.35em} \texttt{-​- n )} &  &  &  &  & \\[0pt]
\emph{\#} &  &  &  &  & \\[0pt]
\emph{\# Parse string given by \texttt{addr}​/​\texttt{u}} &  &  &  &  & \\[0pt]
\emph{\# as a number and push it on} &  &  &  &  & \\[0pt]
\emph{\# the data stack.} &  &  &  &  & \\[0pt]
 &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# Allocate stack space for} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# the parsed number.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{STACK@R15 -= 8;} & SUB r/m64, \emph{imm8} & REX.W 83 /​5 \emph{ib} &  & \texttt{49 83} \texttt{EF}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·101·111}}\) \emph{\texttt{08}} & r15 -= 8\\[0pt]
\hspace{1.053000em} \texttt{[STACK@R15] ← 0;} & AND r/m64, \emph{imm8} & REX.W 83 /​4 \emph{ib} &  & \texttt{49 83} \texttt{27}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·100·111}}\) \emph{\texttt{00}} & [r15] = 0\\[0pt]
\hspace{1.053000em} \texttt{u@RCX ← u@RAX;} & MOV r/m64, r64 & REX.W 89 /r &  & \texttt{48 89} \texttt{C1}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·001}}\) & rcx = rax\\[0pt]
\hspace{1.053000em} \texttt{addr@RSI ← addr@RBP;} & MOV r64, r/m64 & REX.W 8B /r &  & \texttt{48 8B} \texttt{F5}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·110·101}}\) & rsi = rbp\\[0pt]
\texttt{\_begin:} &  &  & \(\overline{\texttt{00}}\) &  & \# \_beg:\\[0pt]
\hspace{1.053000em} \emph{\# Parse one character.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{call Num();} & CALL \uline{rel32} & E8 \uline{cd} &  & \texttt{E8} \uline{\texttt{03 00 00 00}}​\(_{\text{\tiny 08-05}}\) & +call (Num)\\[0pt]
\hspace{1.053000em} \emph{\# Repeat while there are} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# unparsed characters left.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if -{}-{}u@RCX != 0:} &  &  & \texttt{05} &  & \\[0pt]
\hspace{2.106000em}   \texttt{goto \_begin.} & LOOP \uline{rel8} & E2 \uline{cb} &  & \texttt{E2} \uline{\texttt{F9}}​\(_{\text{\tiny 00-07}}\) & -jump beg if --rcx\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 & \texttt{07} & \texttt{C3} & return\\[0pt]
\texttt{Num():} &  &  & \texttt{08} &  & (Num)\\[0pt]
\hspace{1.053000em} \texttt{chr@AL ← [addr@RSI++];} & LODS m8 & AC &  & \texttt{AC} & al = [rsi++]\\[0pt]
\hspace{1.053000em} \emph{\# Is it a \texttt{[0-9]} digit?} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if chr@AL < 'A':} & CMP AL, \emph{imm8} & 3C \emph{ib} &  & \texttt{3C} \emph{\texttt{41}} & cmp al, 'A'\\[0pt]
\hspace{2.106000em}   \texttt{goto \_digit.} & JL \uline{rel8} & 7C \uline{cb} &  & \texttt{7C} \uline{\texttt{02}}​\(_{\text{\tiny 02-00}}\) & +jump \_digit if <\\[0pt]
\hspace{1.053000em} \emph{\# It's an \texttt{[A-F]} digit.} &  &  & \(\overline{\texttt{00}}\) &  & \# \_letter:\\[0pt]
\hspace{1.053000em} \texttt{chr@AL -= 7;} & SUB AL, \emph{imm8} & 2C \emph{ib} &  & \texttt{2C} \emph{\texttt{07}} & al -= 7\\[0pt]
\texttt{\_digit:} &  &  & \texttt{02} &  & \# \_digit:\\[0pt]
\hspace{1.053000em} \texttt{digit@AL = chr@AL - '0';} & SUB AL, \emph{imm8} & 2C \emph{ib} &  & \texttt{2C} \emph{\texttt{30}} & al -= 30\\[0pt]
\hspace{1.053000em} \emph{\# Multiply by base and add} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# the new digit.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{[STACK@R15] <{}<{}= 4}; & SAL r/m64, \emph{imm8} & REX.W C1 /​4 \emph{ib} &  & \texttt{49 C1} \texttt{27}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·100·111}}\) \emph{\texttt{04}} & [r15] <<= 4\\[0pt]
\hspace{1.053000em} \texttt{[STACK@R15]} \(\vert{}\)​\texttt{= digit@RAX;} & OR r/m64, r64 & REX.W 09 /r &  & \texttt{49 09} \texttt{07}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·000·111}}\) & [r15] \(\vert{}\)= rax\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 &  & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org9f2066b}\texttt{Num} parses a token as a number and pushes it on the stack (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

The next word, \texttt{miss}, works in tandem with \texttt{hit}, defined later.
Together, they handle both the case when a token is found in the
dictionary and the case when it is not.  Shown in Table
\ref{tab:org0caf7f8}, \texttt{miss} handles the latter.  Note that in compilation
mode the number is passed to \texttt{LIT} to be compiled in the current
definition.  Otherwise it is left on the stack, which conforms to the
interpretation semantics for numbers.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{miss}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{6D 69 73 73}}​\texttt{]} & define miss\\[0pt]
\emph{\# In/Out:}     \texttt{( addr@RBP u@RAX} &  &  &  &  & \\[0pt]
\emph{\#}\hspace{4.9em}       \texttt{xt@RXB} &  &  &  &  & \\[0pt]
\emph{\#}\hspace{3.35em} \texttt{-​- [num] xt@RXB )} &  &  &  &  & \\[0pt]
\emph{\#} &  &  &  &  & \\[0pt]
\emph{\# If \texttt{xt} is zero, try parsing} &  &  &  &  & \\[0pt]
\emph{\# the string given by \texttt{addr}​/​\texttt{u}} &  &  &  &  & \\[0pt]
\emph{\# as a number. If successful} &  &  &  &  & \\[0pt]
\emph{\# and if we're in compiling} &  &  &  &  & \\[0pt]
\emph{\# state, compile the number} &  &  &  &  & \\[0pt]
\emph{\# as a literal.} &  &  &  &  & \\[0pt]
 &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if xt@RBX = 0:} & TEST r/m64, r64 & REX.W 85 /r &  & \texttt{48 85} \texttt{DB}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·011·011}}\) & rbx(xt) ?\\[0pt]
\hspace{2.106000em}   \texttt{goto miss().} & JZ \uline{rel8} & 74 \uline{cb} &  & \texttt{74} \uline{\texttt{01}}​\(_{\text{\tiny 01-00}}\) & +jump (miss) if == 0\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 & \(\overline{\texttt{00}}\) & \texttt{C3} & return\\[0pt]
\texttt{miss():} &  &  & \texttt{01} &  & (miss)\\[0pt]
\hspace{1.053000em} \emph{\# We shouldn't call \texttt{Num}} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# with an empty string.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if u@RAX != 0:} & TEST r/m64, r64 & REX.W 85 /r &  & \texttt{48 85} \texttt{C0}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·000}}\) & rax(u) ?\\[0pt]
\hspace{2.106000em}   \texttt{goto \_nonempty.} & JNE \uline{rel8} & 75 \uline{cb} &  & \texttt{75} \uline{\texttt{01}}​\(_{\text{\tiny 01-00}}\) & +jump \_nonempty if !=\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 & \(\overline{\texttt{00}}\) & \texttt{C3} & return\\[0pt]
\texttt{\_nonempty:} &  &  & \texttt{01} &  & \# \_nonempty:\\[0pt]
\hspace{1.053000em} \texttt{call Num;}  \emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{4E}​\(_{N}\)​\texttt{]} & Call Num\\[0pt]
\hspace{1.053000em} \emph{\# Are we compiling?} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if [STATE] \& 1 != 0:} & TEST r/m8, \emph{imm8} & F6 /​0 \emph{ib} &  & \texttt{F6} \texttt{04}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·000·100}}\) \texttt{25}​\(^{\text{\tiny    SIB}}_{\text{\tiny 25·00·000}}\) & [STATE] ?\\[0pt]
\hspace{2.106000em}   \emph{\# Compile top of stack} &  &  &  & \hookrightarrow \(^{\text{\tiny +}}\)​\uline{\texttt{20 00 00 10}} \emph{\texttt{01}} & \\[0pt]
\hspace{2.106000em}   \emph{\# number as literal.} &  &  &  &  & \\[0pt]
\hspace{2.106000em}   \texttt{goto \_lit.} & JNZ \uline{rel8} & 75 \uline{cb} &  & \texttt{75} \uline{\texttt{01}}​\(_{\text{\tiny 01-00}}\) & +jump \_lit if != 0\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 & \(\overline{\texttt{00}}\) & \texttt{C3} & return\\[0pt]
\texttt{\_lit:} &  &  & \texttt{01} &  & \# \_lit:\\[0pt]
\hspace{1.053000em} \texttt{call LIT;}  \emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{4C}​\(_{L}\)​\texttt{]} & Call LIT\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 &  & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org0caf7f8}\texttt{miss} treats a token as a number, possibly compiling it as a literal (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}
\clearpage

\subsubsection{Compile or Execute: \texttt{EXEC}, \texttt{exec}, \texttt{compl}, \texttt{hit}}
\label{sec:org2028f7c}

While \texttt{miss} and \texttt{Num} handle tokens not found in the dictionary, it
is the job of \texttt{hit} and several helper words to either compile or
execute an execution token retrieved from the dictionary.  We will
begin with the explanation of the helper words.

\texttt{EXEC}, listen in Table \ref{tab:orgc15d95d}, receives an execution token
and executes the code associated with it immediately.  It does this in
a complicated fashion whose purpose we didn't fully understand (it is
actually the only point of confusion we had in the excellent machine
code implementation of SmithForth): it uses \texttt{COMPL} to compile a
\texttt{CALL} instruction at a remote memory address; to that it appends a
\texttt{RET} instruction; finally it calls into that remote location, thus
performing two jumps for what could have been a simple indirect call.
In the our RISC-V implementation a simple \texttt{jalr} worked equally well.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{EXEC}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{45 58 45 43}}​\texttt{]} & define EXEC\\[0pt]
\emph{\# In/Out:} \texttt{( xt@RBX -{}-{} )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Execute word given by \texttt{xt}.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\emph{\# Pick an address in a galaxy} &  &  &  & \\[0pt]
\emph{\# far away\ldots{}} &  &  &  & \\[0pt]
\texttt{RCX ← 0x7FFFFFF8} & MOV r32, \emph{imm32} & B8+rd \emph{id} & \texttt{B9} \emph{\texttt{F8 FF FF 7F}} & rcx = \_\\[0pt]
\emph{\# Temporarily set \texttt{OUTPUT} to} &  &  &  & \\[0pt]
\emph{\# this address, first saving it.} &  &  &  & \\[0pt]
\texttt{push OUTPUT@RDI;} & PUSH r64 & 50+rd & \texttt{57} & push rdi\\[0pt]
\texttt{OUTPUT@RDI ← RCX;} & MOV r/m32, r32 & 89 /r & \texttt{89} \texttt{CF}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·001·111}}\) & rdi = rcx\\[0pt]
 &  &  &  & \\[0pt]
\emph{\# Compile a call to \texttt{xt}'s code.} &  &  &  & \\[0pt]
\texttt{call COMPL;}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{43}​\(_{C}\)​\texttt{]} & Call COMPL\\[0pt]
\emph{\# Compile a RET instruction.} &  &  &  & \\[0pt]
\texttt{op@AL ← 0xC3;} & MOV r8, \emph{imm8} & B0+rb \emph{ib} & \texttt{B0} \emph{\texttt{C3}} & al = C3\\[0pt]
\texttt{[OUTPUT@RDI++] ← op@AL;} & STOS m8 & AA & \texttt{AA} & [rdi++] = al\\[0pt]
 &  &  &  & \\[0pt]
\emph{\# Restore \texttt{OUTPUT} and transfer} &  &  &  & \\[0pt]
\emph{\# control to the newly created} &  &  &  & \\[0pt]
\emph{\# instruction sequence.} &  &  &  & \\[0pt]
\texttt{pop OUTPUT@RDI;} & POP r64 & 58+rd & \texttt{5F} & pop rdi\\[0pt]
\texttt{call [RCX];} & CALL r/m64 & FF /2 & \texttt{FF} \texttt{D1}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·010·001}}\) & call rcx\\[0pt]
\texttt{return.} & RET & C3 & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgc15d95d}Subroutine \texttt{EXEC} executes a Forth word (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

Subroutines \texttt{exec} and \texttt{compl} in Tables \ref{tab:org82c3792} and
\ref{tab:org55cc663} work similarly to \texttt{miss} and \texttt{exec}, but at a
different level.  Chain-called one after the other, they receive a
word's execution token and handle four different cases, depending
on 1) whether the word is immediate, and 2) which mode is currently
active (compilation or interpretation).  If interpreting or the word
is immediate, \texttt{exec} passes the word to \texttt{EXEC} for execution,
otherwise \texttt{compl} passes the word to \texttt{COMPL} to be compiled into the
current definition.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{exec}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{65 78 65 63}}​\texttt{]} & define exec\\[0pt]
\emph{\# In/Out:} \texttt{( xt@RBX} &  &  &  &  & \\[0pt]
\emph{\#}\hspace{4.9em}   \texttt{imm+state@AL -{}-{} )} &  &  &  &  & \\[0pt]
\emph{\#} &  &  &  &  & \\[0pt]
\emph{\# Execute \texttt{xt} if we're in interpreting} &  &  &  &  & \\[0pt]
\emph{\# mode or if it's an immediate word.} &  &  &  &  & \\[0pt]
\emph{\# In other words, don't execute if we} &  &  &  &  & \\[0pt]
\emph{\# are compiling and the word is not} &  &  &  &  & \\[0pt]
\emph{\# immediate (if \texttt{imm+state} is \texttt{1}).} &  &  &  &  & \\[0pt]
 &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if imm+state@AL != 1:} & CMP AL, \emph{imm8} & 3C \emph{ib} &  & \texttt{3C} \emph{\texttt{01}} & cmp al, 1\\[0pt]
\hspace{2.106000em}   \texttt{goto exec().} & JNE \uline{rel8} & 75 \uline{cb} &  & \texttt{75} \uline{\texttt{01}}​\(_{\text{\tiny 01-00}}\) & +jump (exec) if !=\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 & \(\overline{\texttt{00}}\) & \texttt{C3} & return\\[0pt]
\texttt{exec():} &  &  & \texttt{01} &  & (exec)\\[0pt]
\hspace{1.053000em} \texttt{call EXEC;}  \emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{45}​\(_{E}\)​\texttt{]} & Call EXEC\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 &  & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org82c3792}\texttt{exec} executes a word if it's immediate or if we're interpreting (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{compl}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{05} \uline{\texttt{63 6F 6D 70 6C}}​\texttt{]} & define compl\\[0pt]
\emph{\# In/Out:}    \texttt{( xt@RBX imm+state@AL} &  &  &  &  & \\[0pt]
\emph{\#}\hspace{3.35em} \texttt{-{}-{} xt@RBX imm+state@AL )} &  &  &  &  & \\[0pt]
\emph{\#} &  &  &  &  & \\[0pt]
\emph{\# Compile \texttt{xt} in the current definition} &  &  &  &  & \\[0pt]
\emph{\# if we're in compiling state and \texttt{xt} is} &  &  &  &  & \\[0pt]
\emph{\# not immediate (if \texttt{imm+state} is \texttt{1}).} &  &  &  &  & \\[0pt]
 &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if imm+state@AL = 1:} & CMP AL, \emph{imm8} & 3C \emph{ib} &  & \texttt{3C} \emph{\texttt{01}} & cmp al, 1\\[0pt]
\hspace{2.106000em}   \texttt{goto compl().} & JE \uline{rel8} & 74 \uline{cb} &  & \texttt{74} \uline{\texttt{01}}​\(_{\text{\tiny 01-00}}\) & +jump (compl) if ==\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 & \(\overline{\texttt{00}}\) & \texttt{C3} & return\\[0pt]
\texttt{compl():} &  &  & \texttt{01} &  & (compl)\\[0pt]
\hspace{1.053000em} \texttt{call COMPL;}  \emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{43}​\(_{}\)​\texttt{]} & Call COMPL\\[0pt]
\hspace{1.053000em} \emph{\# Restore AL after \texttt{COMPL}.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{imm+state@AL ← 1;} & MOV r8, \emph{imm8} & B0+rb \emph{ib} &  & \texttt{B0} \emph{\texttt{01}} & al = 1\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 &  & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org55cc663}\texttt{compl} compiles a word in compiling mode if it's not immediate (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

Finally, \texttt{hit} combines \texttt{compl} and \texttt{exec} by chaining them together.
It computes the \texttt{imm+state} flag that is used by the two words to
dispatch on the four cases discussed above.  The code is shown in
Table \ref{tab:org6784ec4}.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{hit}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{03} \uline{\texttt{68 69 74}}​\texttt{]} & define hit\\[0pt]
\emph{\# In/Out:} \texttt{( xt@RBX -{}-{} )} &  &  &  &  & \\[0pt]
\emph{\#} &  &  &  &  & \\[0pt]
\emph{\# Either compile or execute a} &  &  &  &  & \\[0pt]
\emph{\# word that has been found in} &  &  &  &  & \\[0pt]
\emph{\# the dictionary, depending on} &  &  &  &  & \\[0pt]
\emph{\# current state and whether it's} &  &  &  &  & \\[0pt]
\emph{\# an immediate word.} &  &  &  &  & \\[0pt]
 &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if xt@RBX != 0:} & TEST r/m64, r64 & REX.W 85 /r &  & \texttt{48 85} \texttt{DB}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·011·011}}\) & rbx(xt) ?\\[0pt]
\hspace{2.106000em}   \texttt{goto hit().} & JNZ \uline{rel8} & 75 \uline{cb} &  & \texttt{75} \uline{\texttt{01}}​\(_{\text{\tiny 01-00}}\) & +jump (hit) if != 0\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 & \(\overline{\texttt{00}}\) & \texttt{C3} & return\\[0pt]
\texttt{hit():} &  &  & \texttt{01} &  & (hit)\\[0pt]
\hspace{1.053000em} \emph{\# Combine word's immediate} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# flag with current state.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{flag@AL ← [xt@RBX + 16];} & MOV r8, r/m8 & REX 8A /r &  & \texttt{40 8A} \texttt{43}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·000·011}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{10}} & al = [rbx+10]\\[0pt]
\hspace{1.053000em} \texttt{imm@AL ← flag@AL \& 0x80;} & AND AL, \emph{imm8} & 24 \emph{ib} &  & \texttt{24} \emph{\texttt{80}} & al \&= 80(IMMEDIATE)\\[0pt]
\hspace{1.053000em} \texttt{imm+state@AL ← imm@AL} &  &  &  &  & \\[0pt]
\hspace{7.897500em}              \(\vert{}\) \texttt{[STATE];} & OR r8, r/m8 & 0A /r &  & \texttt{0A} \texttt{04}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·000·100}}\) \texttt{25}​\(^{\text{\tiny    SIB}}_{\text{\tiny 25·00·100}}\) & al \(\vert{}\)= [STATE]\\[0pt]
\hspace{1.053000em} \emph{\# Let \texttt{compl} and \texttt{exec} decide} &  &  &  & \hookrightarrow \hspace{0em} \(^{\text{\tiny +}}\)​\uline{\texttt{20 00 00 10}} & \\[0pt]
\hspace{1.053000em} \emph{\# what to do.} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{call compl;}  \hspace{0.000000em}​\emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{63}​\(_{c}\)​\texttt{]} & Call compl\\[0pt]
\hspace{1.053000em} \texttt{call exec;}   \hspace{0.526500em}​\emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{65}​\(_{e}\)​\texttt{]} & Call exec\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 &  & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org6784ec4}\texttt{hit} compiles or executes a word found in the dictionary (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}
\clearpage

\subsubsection{Bringing Everything Together: \texttt{SVAL}, \texttt{ti}}
\label{sec:orga6fd056}

We have arrived nearly at the end of our journey through SmithForth's
machine code.  Here two final words combine subroutines from the five
categories we have discussed to create an interpreting loop that
consumes tokens from \texttt{INPUT}, attempts to find them as words in the
dictionary and either compiles or executes them according to their
nature.

Subroutine \texttt{SVAL}, shown in Table \ref{tab:orgaca98b6}, chains \texttt{pname},
\texttt{FIND}, \texttt{miss} and \texttt{hit} to parse and act on a token.  It does so as
long as there are characters left in the current parse area.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{9}{10.800000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{SVAL}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{53 56 41 4C}}​\texttt{]} & define SVAL\\[0pt]
\emph{\# In/Out:} \texttt{( ··· -{}-{} ··· )} &  &  &  &  & \\[0pt]
\emph{\#} &  &  &  &  & \\[0pt]
\emph{\# Evaluate a Forth line: repeatedly} &  &  &  &  & \\[0pt]
\emph{\# parse a token, attempt finding it} &  &  &  &  & \\[0pt]
\emph{\# in the dictionary, then allow \texttt{miss}} &  &  &  &  & \\[0pt]
\emph{\# and \texttt{hit} to choose the appropriate} &  &  &  &  & \\[0pt]
\emph{\# action in context.} &  &  &  &  & \\[0pt]
 &  &  &  &  & \\[0pt]
\texttt{\_begin:} &  &  & \(\overline{\texttt{00}}\) &  & \\[0pt]
\hspace{1.053000em} \texttt{call SVAL();} & CALL \uline{rel32} & E8 \uline{cd} &  & \texttt{E8} \uline{\texttt{03 00 00 00}}​\(_{\text{\tiny 08-05}}\) & +call (SVAL)\\[0pt]
\hspace{1.053000em} \emph{\# Characters left in current line?} &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if [>in] < [\#IN]:} &  &  & \texttt{05} &  & \\[0pt]
\hspace{2.106000em}   \emph{\# See comparison in \texttt{SVAL()}!} &  &  &  &  & \\[0pt]
\hspace{2.106000em}   \texttt{goto \_begin.} & JL \uline{rel8} & 7C \uline{cb} &  & \texttt{7C} \uline{\texttt{F9}}​\(_{\text{\tiny 00-07}}\) & -jump SVAL if <\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 & \texttt{07} & \texttt{C3} & return\\[0pt]
\texttt{SVAL():} &  &  & \texttt{08} &  & (SVAL)\\[0pt]
\hspace{1.053000em} \texttt{call pname;}  \hspace{0.000000em}​\emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{70}​\(_{p}\)​\texttt{]} & Call pname\\[0pt]
\hspace{1.053000em} \texttt{call FIND;}   \hspace{0.526500em}​\emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{46}​\(_{F}\)​\texttt{]} & Call FIND\\[0pt]
\hspace{1.053000em} \texttt{call miss;}   \hspace{0.526500em}​\emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{6D}​\(_{m}\)​\texttt{]} & Call miss\\[0pt]
\hspace{1.053000em} \texttt{call hit;}    \hspace{1.053000em}​\emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{68}​\(_{h}\)​\texttt{]} & Call hit\\[0pt]
\hspace{1.053000em} \texttt{>in@RAX ← [>IN];} & MOV r64, r/m64 & REX.W 8B /r &  & \texttt{48 8B} \texttt{04}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·000·100}}\) \texttt{25}​\(^{\text{\tiny    SIB}}_{\text{\tiny 25·00·100}}\) & rax = [>IN]\\[0pt]
 &  &  &  & \hookrightarrow \hspace{0em} \(^{\text{\tiny +}}\)​\uline{\texttt{10 00 00 10}} & \\[0pt]
\hspace{1.053000em} \texttt{compare >in@RAX and [\#IN];} & CMP r64, r/m64 & REX.W 3B /r &  & \texttt{48 3B} \texttt{04}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 00·000·100}}\) \texttt{25}​\(^{\text{\tiny    SIB}}_{\text{\tiny 25·00·100}}\) & cmp rax, [\#IN]\\[0pt]
 &  &  &  & \hookrightarrow \hspace{0em} \(^{\text{\tiny +}}\)​\uline{\texttt{00 00 00 10}} & \\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 &  & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgaca98b6}\texttt{SVAL} evaluates a line of Forth code (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

Table \ref{tab:org997775c} showcases \texttt{ti}, the word which, in Forth fashion,
brings everything together.  It first sets up the data stack right
below the global variables.  This is interesting in practice, because
any accidental data stack underflow might corrupt the global
variables, which hold parsing and dictionary state.  Most underflow
errors result therefore in crashes or infinite loops.  SmithForth
makes no attempt to protect against stack underflow, which would be
mandatory in a Forth system intended for production use.

Next, \texttt{TBI} is set to point in memory just after the machine code
section of the executable.  In effect, any text following the last
\texttt{RET} instruction in \texttt{ti} will be interpreted as Forth code.  This
allows SmithForth to continue building on top of the current Forth
system in Forth instead of machine code.  A victory in bootstrapping!

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|lH}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code} & \textbf{Intention}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{ti}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{02} \uline{\texttt{74 69}}​\texttt{]} & define ti\\[0pt]
\emph{\# In/Out:} \texttt{( -{}-{} )} &  &  &  &  & \\[0pt]
\emph{\#} &  &  &  &  & \\[0pt]
\emph{\# Initialize data stack and text} &  &  &  &  & \\[0pt]
\emph{\# input, then repeatedly refill} &  &  &  &  & \\[0pt]
\emph{\# lines and evaluate them.} &  &  &  &  & \\[0pt]
 &  &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{STACK@R15 ← 0x10000000;} & MOV r/m64, \emph{imm32} & REX.W C7 /​0 \emph{id} &  & \texttt{49 C7} \texttt{C7}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 11·000·111}}\) & r15(stack) = 10000000\\[0pt]
 &  &  &  & \hookrightarrow \emph{\texttt{00 00 00 10}} & \\[0pt]
\hspace{1.053000em} \texttt{[TIB] ← INPUT@RSI;} & MOV r/m64, r64 & REX.W 89 /r &  & \texttt{49 89} \texttt{77}​\(^{\text{\tiny ModR/M}}_{\text{\tiny 01·110·111}}\) \(^{\text{\tiny +}}\)​\uline{\texttt{08}} & [TIB] = rsi\\[0pt]
\hspace{1.053000em} \texttt{call [;}  \emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{5B}​\(_{[}\)​\texttt{]} & Call [\\[0pt]
\texttt{\_begin:} &  &  & \(\overline{\texttt{00}}\) &  & \# \_beg:\\[0pt]
\hspace{1.053000em} \texttt{call ti();} & CALL \uline{rel32} & E8 \uline{cd} &  & \texttt{E8} \uline{\texttt{02 00 00 00}}​\(_{\text{\tiny 07-05}}\) & +call (ti)\\[0pt]
\hspace{1.053000em} \texttt{goto \_begin.} & JMP \uline{rel8} & EB \uline{cb} & \texttt{05} & \texttt{EB} \uline{\texttt{F9}}​\(_{\text{\tiny 00-07}}\) & -jump \_beg\\[0pt]
\texttt{ti():} &  &  & \texttt{07} &  & (ti)\\[0pt]
\hspace{1.053000em} \texttt{call REFILL;}  \hspace{0.000000em}​\emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{52}​\(_{R}\)​\texttt{]} & Call REFILL\\[0pt]
\hspace{1.053000em} \texttt{call SVAL;}    \hspace{1.053000em}​\emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{53}​\(_{S}\)​\texttt{]} & Call SVAL\\[0pt]
\hspace{1.053000em} \texttt{return.} & RET & C3 &  & \texttt{C3} & return\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org997775c}Finally, subroutine \texttt{ti} reads and evaluates Forth in a loop (x86-64).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

In the next chapter we will present our port of SmithForth to the
RISC-V architecture.

\clearpage


\section{Porting SmithForth to RISC-V}
\label{sec:org9c46462}

This chapter will closely follow the structure of Chapter
\ref{sec:orgf813ea4}.  We will keep the same
sections headings, with ``(RISC-V)'' appended: hopefully, this will
aid the reader interested in comparing the x86-64 and the RISC-V
implementations.

After closely annotating SmithForth as seen in the previous chapter,
we slightly adapted the interfaces at the edges of the various
components to better fit the architectural differences between x86-64
and RISC-V:

\begin{itemize}
\item We removed any reliance on the x86-64 \texttt{FLAGS} register. Instead, we
chose appropriate general purpose registers to hold the relevant
flags.

\item All calls were modified to follow the RISC-V software calling
convention, using registers \texttt{a0, a1, s2...} for function arguments
and return values.

\item Local variables were assigned temporary registers where possible.
We tried ``allocating'' and ``releasing'' registers in an orderly
fashion, to make errors less likely.
\end{itemize}

We did not in fact, predict all consequences of some differences: in
particular, we struggled with compiling calls in word definitions at
first, before devising the \texttt{':'}-prologues and \texttt{';'}-epilogues
described below.  Another particularity of RISC-V that has led to many
errors, some difficult to track down, is how immediates are always
sign-extended: some \texttt{addi} instructions, for example, looked innocent,
but behaved less so in practice.

The first concrete step necessary to run machine code on RISC-V is
creating a suitable ELF executable.  This is the topic of the next
section.

\subsection{The ELF Header (RISC-V)}
\label{sec:orgf54d09a}

Adapting the executable preamble for the RISC-V architecture only
required a few field modifications in the two ELF headers.  We believe
this illustrates the benefits of standardization among hardware and
software platforms.

\subsubsection{ELF File Header}
\label{sec:org880645c}

The most obvious field to change is, of course, \texttt{e\_machine}, which
specifies the architecture on which the executable is meant to run.
We changed it to the numeric identifier specially allocated for RISC-V
by the System V ABI specification.  Since RISC-V imposes no
restrictions on the execution entry point, we set it to \texttt{0} to
simplify debugging (field \texttt{e\_entry}).  Every other field remains the
same.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{9}{10.800000}\selectfont
\begin{center}
\begin{tabular}{l|l|l}
\textbf{\&} & \textbf{File Header Bytes} & \textbf{Explanation}\\[0pt]
\hline
\(\overline{\texttt{00}}\) & \hspace{0.000000em}​\texttt{7F 45 4C 46} & \texttt{e\_ident[EI\_MAG]}: ELF magic number.\\[0pt]
 & \hspace{6.318000em}​\texttt{02} & \texttt{e\_ident[EI\_CLASS]}: \texttt{1} → 32-bit, \uline{\texttt{2} → 64-bit}.\\[0pt]
 & \hspace{7.897500em}​\texttt{01} & \texttt{e\_ident[EI\_DATA]}: \uline{\texttt{1} → little-endian}, \texttt{2} → big-endian.\\[0pt]
 & \hspace{9.477000em}​\texttt{01} & \texttt{e\_ident[EI\_VERSION]}: ELF header version; must be \texttt{1}.\\[0pt]
 & \hspace{11.056500em}​\texttt{00} & \texttt{e\_ident[EI\_OSABI]}: Target OS ABI; \texttt{ELFOSABI\_NONE} (\texttt{0}) is fine for Linux.\\[0pt]
 & \hspace{0.000000em}​\texttt{00} & \texttt{e\_ident[EI\_ABIVERSION]}: ABI version; should be \texttt{0} for Linux.\\[0pt]
 & \hspace{1.579500em}​\texttt{00 00 00 00 00 00 00} & \texttt{e\_ident[EI\_PAD]}: Padding; unused; should be \texttt{0}.\\[0pt]
\hline
 & \hspace{0.000000em}​\texttt{02 00} & \texttt{e\_type}: Object file type; \texttt{2} → executable.\\[0pt]
 & \hspace{3.159000em}​\texttt{F3 00} & \texttt{e\_machine}: Instruction set architecture; \texttt{0x3E} → \texttt{x86-64}, \uline{\texttt{0xF3} → \texttt{RISC-V}}.\\[0pt]
 & \hspace{6.318000em}​\texttt{01 00 00 00} & \texttt{e\_version}: ELF identification version; must be \texttt{1}.\\[0pt]
 & \hspace{0.000000em}​\texttt{78 00 00 00 00 00 00 00} & \texttt{e\_entry}: Memory address of entry point (where process starts).\\[0pt]
 & \hspace{0.000000em}​\texttt{40 00 00 00 00 00 00 00} & \texttt{e\_phoff}: File offset of program headers; \texttt{0x34} → \texttt{32-bit}, \uline{\texttt{0x40} → 64-bit}.\\[0pt]
 & \hspace{0.000000em}​\texttt{00 00 00 00 00 00 00 00} & \texttt{e\_shoff}: File offset section headers (we don't have any sections).\\[0pt]
\hline
 & \hspace{0.000000em}​\texttt{00 00 00 00} & \texttt{e\_flags}: 0 for the \texttt{RISC-V} architecture.\\[0pt]
 & \hspace{6.318000em}​\texttt{40 00} & \texttt{e\_ehsize}: Size of this header; \texttt{0x34} → 32-bit, \uline{\texttt{0x40} → 64-bit}.\\[0pt]
 & \hspace{9.477000em}​\texttt{38 00} & \texttt{e\_phentsize}: Size of each program header; \texttt{0x20} → 32-bit, \uline{\texttt{0x38} → 64-bit}.\\[0pt]
 & \hspace{0.000000em}​\texttt{01 00} & \texttt{e\_phnum}: Number of program headers; here \texttt{1}.\\[0pt]
 & \hspace{3.159000em}​\texttt{40 00} & \texttt{e\_shentsize}: Size of each section header; \texttt{0x28} → 32-bit, \uline{\texttt{0x40} → 64-bit}.\\[0pt]
 & \hspace{6.318000em}​\texttt{00 00} & \texttt{e\_shnum}: Number of section headers; here \texttt{0}.\\[0pt]
 & \hspace{9.477000em}​\texttt{00 00} & \texttt{e\_shstrndx}: Index of section header containing section names; N/A.\\[0pt]
\hline
\texttt{40} &  & \\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org163e116}ELF file header for the Linux executable (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\subsubsection{ELF Program Header}
\label{sec:org7a79576}

In the program header we set the virtual address of the loaded segment
to \texttt{0} (field \texttt{p\_vaddr}) so that it is in accordance with field
\texttt{e\_entry} in the ELF file header.  The RISC-V specification demands
segment alignment to be \texttt{4096}, which is the same as what SmithForth
sets for x86-64 (field \texttt{p\_align}).

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{9}{10.800000}\selectfont
\begin{center}
\begin{tabular}{l|l|l}
\textbf{\&} & \textbf{File Header Bytes} & \textbf{Explanation}\\[0pt]
\hline
\texttt{40} & \hspace{0.000000em}​\texttt{01 00 00 00} & \texttt{p\_type}: Segment type; \texttt{1} → loadable.\\[0pt]
 & \hspace{6.318000em}​\texttt{07 00 00 00} & \texttt{p\_flags}: Segment-wise permissions; \uline{1 → execute}, \uline{2 → write}, \uline{4 → read}.\\[0pt]
 & \hspace{0.000000em}​\texttt{00 00 00 00 00 00 00 00} & \texttt{p\_offset}: Offset of segment in file; we load the whole file, so \texttt{0}.\\[0pt]
 & \hspace{0.000000em}​\texttt{00 00 00 00 00 00 00 00} & \texttt{p\_vaddr}: Virtual address of loaded segment; can be 0 in RISC-V. \citeprocitem{35}{[35]}\\[0pt]
 & \hspace{0.000000em}​\texttt{00 00 00 00 00 00 00 00} & \texttt{p\_paddr}: Only used on systems where physical address is relevant.\\[0pt]
 & \hspace{0.000000em}​\texttt{02 1E 01 00 00 00 00 00} & \texttt{p\_filesz}: Size of the segment in the file image.\\[0pt]
 & \hspace{0.000000em}​\texttt{00 00 C0 7F 00 00 00 00} & \texttt{p\_memsz}: Size of the segment in memory (\(\ge\) \texttt{p\_filesz}).\\[0pt]
 & \hspace{0.000000em}​\texttt{00 10 00 00 00 00 00 00} & \texttt{p\_align}: Align segment to RISC-V page size (4096 or \texttt{0x1000}) \citeprocitem{26}{[26]}.\\[0pt]
\hline
\texttt{78} &  & \\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org0d9261f}ELF program header (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}
\clearpage


\subsection{Global Variables (RISC-V)}
\label{sec:org42fb1b3}

In RISC-V the allocation of registers and memory locations for global
variables, shown in Table \ref{tab:org3a70166}, is similar to SmithForth's.
Note that for the first four variables we used ``saved registers'',
designated as callee-saved by RISC-V's software calling convention
\citeprocitem{25}{[25]}.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{l|l|l}
\textbf{Variable} & \textbf{Register}​/​\textbf{Address} & \textbf{Contents}\\[0pt]
\hline
\texttt{INPUT} & \texttt{s0} & Source address of binary interpreter data and commands.\\[0pt]
\texttt{OUTPUT} & \texttt{s1} & Destination address of binary interpreter operations.\\[0pt]
\texttt{VARS} & \texttt{s2} & Base address of globals stored in memory (\texttt{\#IN}, \texttt{TIB} etc).\\[0pt]
\texttt{STACK} & \texttt{s3} & Address of top value on the data stack.\\[0pt]
\hline
\texttt{\#IN} & \texttt{0x10000000 (VARS)} & The number of characters in the current line.\\[0pt]
\texttt{TIB} & \texttt{0x10000008 (VARS+8)} & The address where the current line begins.\\[0pt]
\texttt{>IN} & \texttt{0x10000010 (VARS+16)} & The number of \emph{parsed} characters in the current line.\\[0pt]
\texttt{STATE} & \texttt{0x10000020 (VARS+32)} & Either \texttt{0} (\emph{interpreting} state) or \texttt{1} (\emph{compiling} state).\\[0pt]
\texttt{LATEST} & \texttt{0x10000028 (VARS+40)} & The execution token (\emph{xt}) of the latest defined Forth word.\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org3a70166}Global variables in SmithForth (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

The code that initializes \texttt{INPUT} and \texttt{OUTPUT} is similar, if a bit
more verbose due to RISC-V's splitting of immediate loads in 20-bit
``upper immediate'' loads and 12-bit immediate additions
\citeprocitem{24}{[24]}, \citeprocitem{25}{[25]}.  We have chosen to represent
the sub-byte encoding scheme used by RISC-V in the `Encoding' column,
highlighting source and destination registers, immediates and offsets.
The encoding of the first \texttt{lui} instruction is explained in detail.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{9}{10.800000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{\&} & \textbf{Mach. code}\\[0pt]
\hline
\emph{\# Global variable \texttt{INPUT}.} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Our \texttt{INPUT} begins after the} &  &  &  & \\[0pt]
\emph{\# binary interpreter, just at} &  &  &  & \\[0pt]
\emph{\# the beginning of \texttt{COMPL}.} &  &  &  & \\[0pt]
\texttt{INPUT@s0 ← 0x000000F0;} & \texttt{lui s0,0x00000} & \emph{\texttt{0x00000}}                                 \texttt{01001}​\(^{d}\)   \texttt{0110111} & \texttt{78} & \texttt{37 04 00 00}\\[0pt]
 &  & \emph{\# Group 8-bit groups into bytes:} &  & \\[0pt]
 &  & \emph{\texttt{0x}}​\texttt{⟨}​\emph{\texttt{01}}​\texttt{⟩⟨}​\emph{\texttt{00}}​\texttt{⟩⟨}​\emph{\texttt{0}}                \texttt{0100⟩⟨0}​\(^{d}\) \texttt{0110111⟩} &  & \\[0pt]
 &  & \emph{\# Write as hexadecimal:} &  & \\[0pt]
 &  & \texttt{01 00 04 37} &  & \\[0pt]
 &  & \emph{\# Finally, change to little-endian:} &  & \\[0pt]
 &  & \texttt{37 04 00 01} &  & \\[0pt]
 & \texttt{addi s0,s0,0x0F0} & \emph{\texttt{0x0F0}}                    \texttt{01000}​\(^{s_{1}}\) \texttt{000} \texttt{01000}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 04 04 0F}\\[0pt]
\emph{\# Global variable \texttt{OUTPUT}.} &  &  &  & \\[0pt]
\texttt{OUTPUT@s1 ← 0x10000030;} & \texttt{lui s1,0x10000} & \emph{\texttt{0x10000}}                                 \texttt{01001}​\(^{d}\)   \texttt{0110111} &  & \texttt{B7 04 00 10}\\[0pt]
 & \texttt{addi s1,s1,0x030} & \emph{\texttt{0x030}}   \texttt{01001}​\(^{s_{1}}\) \texttt{000} \texttt{01001}​\(^{d}\)   \texttt{0010011} &  & \texttt{93 84 04 03}\\[0pt]
\emph{\# Global variable \texttt{VARS}.} &  &  &  & \\[0pt]
\texttt{VARS@s2 ← 0x10000000;} & \texttt{lui s2,0x10000} & \emph{\texttt{0x10000}}                                 \texttt{10010}​\(^{d}\)   \texttt{0110111} &  & \texttt{37 09 00 10}\\[0pt]
 & \texttt{addi s2,s2,0x000} & \emph{\texttt{0x000}}   \texttt{10010}​\(^{s_{1}}\) \texttt{000} \texttt{10010}​\(^{d}\)   \texttt{0010011} &  & \texttt{13 09 09 00}\\[0pt]
 &  &  & \texttt{90} & \\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org8308adc}Initialize global variables \texttt{INPUT}, \texttt{OUTPUT} and \texttt{VARS} (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

We initialized \texttt{VARS} here rather than in individual subroutines,
since it spares several instructions.
\clearpage


\subsection{Binary Interpreter (RISC-V)}
\label{sec:org9082b48}

Adapting the binary interpreter loop to RISC-V was mostly
straightforward.  A notable difference between the two architectures
is the way relative offsets for calls, jumps and branches are
calculated.  While in x86-64 the offset is calculated relative to the
PC \emph{after} the jump instruction, in RISC-V it's the address of the
jump instruction itself that matters.  This simplifies calculations
and is reflected in the \textbf{\&} column by placing the address of each jump
on the same line as the instruction.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{\&} & \textbf{Machine code}\\[0pt]
\hline
\texttt{\_bi:} &  &  & \texttt{90} & \\[0pt]
\hspace{1em} \emph{\# Loop the binary interpreter.} &  &  &  & \\[0pt]
\hspace{1em} \texttt{call bi();} & \textbf{jal} ra, 8 & \uline{\texttt{00000000100000000000}}                                     \texttt{00000}​\(^{d}\)  \texttt{1101111} &  & \texttt{EF 00 80 00}\\[0pt]
\hspace{1em} \texttt{goto \_bi.} & \textbf{jal} zero, -4 & \uline{\texttt{11111111110111111111}}                                     \texttt{00000}​\(^{d}\)  \texttt{1101111} &  & \texttt{6F F0 DF FF}\\[0pt]
\texttt{bi():} &  &  & \texttt{98} & \\[0pt]
\hspace{1em} \emph{\# Read next byte from \texttt{INPUT}.} &  &  &  & \\[0pt]
\hspace{1em} \texttt{byte@t0 ← [INPUT@s0];} & \textbf{lbu} t0, 0(s0) & \uline{\texttt{0x000}}                    \texttt{01000}​\(^{s_{1}}\) \texttt{100} \texttt{00101}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 42 04 00}\\[0pt]
\hspace{1em} \emph{\# Does it start a command?} &  &  &  & \\[0pt]
\hspace{1em} \texttt{if byte@t0 = 0x99:} & \textbf{addi} t1, zero, 0x099 & \emph{\texttt{0x099}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{00110}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 03 90 09}\\[0pt]
\hspace{2em}     \texttt{goto \_command.} & \textbf{beq} t0, t1, 0x018 & \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{00110}​\(^{s_{1}}\) \texttt{000} \uline{\texttt{11000}} \texttt{1100011} & \texttt{A0} & \texttt{63 0C 53 00}\\[0pt]
\hspace{1em} \emph{\# This is just an instruction.} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# Copy four bytes to \texttt{OUTPUT}} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# and return.} &  &  &  & \\[0pt]
\hspace{1em} \texttt{instr@t0 ← [INPUT@s0++4];} & \textbf{lwu} t0, 0(s0) & \uline{\texttt{0x000}}                    \texttt{01000}​\(^{s_{1}}\) \texttt{110} \texttt{00101}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 62 04 00}\\[0pt]
\hspace{1em} & \textbf{addi} s0, s0, 4 & \emph{\texttt{0x004}}                    \texttt{01000}​\(^{s_{1}}\) \texttt{000} \texttt{01000}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 04 44 00}\\[0pt]
\hspace{1em} \texttt{[OUTPUT@s1++4] ← instr@t0;} & \textbf{sw} t0, 0(s1) & \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{01001}​\(^{s_{1}}\) \texttt{010} \uline{\texttt{00000}} \texttt{0100011} &  & \texttt{23 A0 54 00}\\[0pt]
\hspace{1em} & \textbf{addi} s1, s1, 4 & \emph{\texttt{0x004}}                    \texttt{01001}​\(^{s_{1}}\) \texttt{000} \texttt{01001}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 84 44 00}\\[0pt]
\hspace{1em} \texttt{return.} & \textbf{jalr} zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} &  & \texttt{67 80 00 00}\\[0pt]
\texttt{\_command:} &  &  & \texttt{B8} & \\[0pt]
\hspace{1em} \emph{\# Get latest dictionary word} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# from \texttt{LATEST} (\texttt{VARS + 40}):} &  &  &  & \\[0pt]
\hspace{1em} \texttt{xt@a0 ← [LATEST];} & \textbf{ld} a0, 40(s2) & \uline{\texttt{0x028}}                    \texttt{10010}​\(^{s_{1}}\) \texttt{011} \texttt{01010}​\(^{d}\)  \texttt{0000011} &  & \texttt{03 35 89 02}\\[0pt]
\hspace{1em} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# Read command argument} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# and advance \texttt{INPUT}.} &  &  &  & \\[0pt]
\hspace{1em} \texttt{arg@a1 ← [INPUT@s0 + 1];} & \textbf{lbu} a1, 1(s0) & \uline{\texttt{0x001}}                    \texttt{01000}​\(^{s_{1}}\) \texttt{100} \texttt{01011}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 45 14 00}\\[0pt]
\hspace{1em} \texttt{INPUT@s0 += 2;} & \textbf{addi} s0, s0, 2 & \emph{\texttt{0x002}}                    \texttt{01000}​\(^{s_{1}}\) \texttt{000} \texttt{01000}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 04 24 00}\\[0pt]
\hspace{1em} \emph{\# Command type by argument:} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# – \texttt{0bi00ccccc}: define;} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# – \texttt{0b011ccccc}: compile;} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# – \texttt{0b111ccccc}: execute.} &  &  &  & \\[0pt]
\hspace{1em} \texttt{if arg@a1} \texttt{\&} \texttt{0b01100000} \texttt{=} \texttt{0:} & \textbf{andi} t0, a1, 0x060 & \emph{\texttt{0x060}}                    \texttt{01011}​\(^{s_{1}}\) \texttt{111} \texttt{00101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 F2 05 06}\\[0pt]
\hspace{2em}     \emph{\# \uline{Define} a new word.} &  &  &  & \\[0pt]
\hspace{2em}     \texttt{goto Head.} & \textbf{beq} t0, zero, \uline{0x07E} & \uline{\texttt{0000011}} \texttt{00101}​\(^{s_{2}}\) \texttt{00000}​\(^{s_{1}}\) \texttt{000} \uline{\texttt{11110}} \texttt{1100011} & \texttt{C8} & \texttt{63 0F 50 06}\\[0pt]
\texttt{\_find1:} &  &  & \texttt{CC} & \\[0pt]
\hspace{1em} \texttt{chr@t0} \texttt{←} \texttt{arg@a1} \texttt{\&} \texttt{0b0111111;} & \textbf{andi} t0, a1, 0x07F & \emph{\texttt{0x07F}}                    \texttt{01011}​\(^{s_{1}}\) \texttt{111} \texttt{00101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 F2 F5 07}\\[0pt]
\hspace{1em} \texttt{if chr@t0 = [xt@a0 + 17]:} & \textbf{lbu} t1, 0x011(a0) & \uline{\texttt{0x011}}                    \texttt{01010}​\(^{s_{1}}\) \texttt{100} \texttt{00110}​\(^{d}\)  \texttt{0000011} &  & \texttt{03 43 15 01}\\[0pt]
\hspace{2em}     \emph{\# We found a word whose} &  &  &  & \\[0pt]
\hspace{2em}     \emph{\# name begins with \texttt{chr}.} &  &  &  & \\[0pt]
\hspace{2em}     \texttt{goto \_match.} & \textbf{beq} t0, t1, \uline{0x00C} & \uline{\texttt{0000000}} \texttt{00110}​\(^{s_{2}}\) \texttt{00101}​\(^{s_{1}}\) \texttt{000} \uline{\texttt{01100}} \texttt{1100011} & \texttt{D4} & \texttt{63 86 62 00}\\[0pt]
\hspace{1em} \emph{\# Follow word's link pointer} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# to previous entry and repeat.} &  &  &  & \\[0pt]
\hspace{1em} \texttt{xt@a0 ← [xt@a0 + 8];} & \textbf{ld} a0, 8(a0) & \uline{\texttt{0x008}}                    \texttt{01010}​\(^{s_{1}}\) \texttt{011} \texttt{01010}​\(^{d}\)  \texttt{0000011} &  & \texttt{03 35 85 00}\\[0pt]
\hspace{1em} \texttt{goto \_find1.} & \textbf{jal} zero, \uline{-16} & \uline{\texttt{11111111000111111111}}                                     \texttt{00000}​\(^{d}\)  \texttt{1101111} & \texttt{DC} & \texttt{6F F0 1F FF}\\[0pt]
\texttt{\_match:} &  &  & \texttt{E0} & \\[0pt]
\hspace{1em} \texttt{if arg@a1 \& 0b1000000 = 0:} & \textbf{andi} t0, a1, 0x080 & \emph{\texttt{0x080}}                    \texttt{01011}​\(^{s_{1}}\) \texttt{111} \texttt{00101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 F2 05 08}\\[0pt]
\hspace{2em}     \emph{\# \uline{Compile}.} &  &  &  & \\[0pt]
\hspace{2em}     \texttt{goto COMPL.} & \textbf{beq} t0, zero, \uline{0x014} & \uline{\texttt{0000000}} \texttt{00000}​\(^{s_{2}}\) \texttt{00101}​\(^{s_{1}}\) \texttt{000} \uline{\texttt{10100}} \texttt{1100011} & \texttt{E4} & \texttt{63 8A 02 00}\\[0pt]
\hspace{1em} \emph{\# \uline{Execute} word's code.} &  &  &  & \\[0pt]
\hspace{1em} \texttt{goto [xt@a0].} & \textbf{ld} t0, 0(a0) & \uline{\texttt{0x000}}                    \texttt{01010}​\(^{s_{1}}\) \texttt{011} \texttt{00101}​\(^{d}\)  \texttt{0000011} & \texttt{E8} & \texttt{83 32 05 00}\\[0pt]
\hspace{1em} & \textbf{jalr} zero, 0(t0) & \uline{\texttt{0x000}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} &  & \texttt{67 80 02 00}\\[0pt]
 &  &  & \texttt{F0} & \\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgec66bbe}The binary interpreter routine and loop (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

Not obvious in the SmithForth implementation is how the special
command byte \texttt{0x99} was chosen.  We presume its value was selected
because it doesn't begin any x86-64 instruction sequence used in the
project.  Consulting the RISC-V specification shows that it's a safe
value for our target architecture as well \citeprocitem{25}{[25]}.

\subsubsection{Subroutine \texttt{COMPL}}
\label{sec:org32a4cf0}

The implementation of \texttt{COMPL}, shown in Table \ref{tab:orgb7b8abe},
proved to be quite subtle.  Whereas x86-64's \texttt{CALL} instruction
implicitly pushes the return address on the stack, RISC-V's mostly
homologous \texttt{jalr} doesn't do such thing.  Instead, it only writes the
return address to a specified destination register.  Thus in \texttt{COMPL}
we had to decide between two alternatives:
\begin{itemize}
\item generate more code to save the return address onto the stack and
retrieve it after the call;
\item handle the saving of the return address in the \emph{callee} word
instead.
\end{itemize}

Because the calling sequence had already increased in length from one
instruction (7 bytes) in x86-64 to two instructions (\texttt{lui} and \texttt{jalr},
giving 8 bytes), we decided for the latter option.  We will see in the
definitions of \texttt{:} and \texttt{;} how we compile prologues and epilogues that
save and restore the return address at the beginning and end of each
Forth word.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{7}{8.400000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{\&} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{COMPL}} & --- & --- & \texttt{F0} & \texttt{[99} \(^{d}\)​\texttt{05} \uline{\texttt{43 4F 4D 50 4C}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( xt@a0 -{}-{} xt@a0 )} &  &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
 &  &  &  & \\[0pt]
\emph{\# Generate two instructions which,} &  &  &  & \\[0pt]
\emph{\# combined, set the PC to \texttt{[xt]}:} &  &  &  & \\[0pt]
\emph{\# 1. Prepare 20 highest bits of \texttt{[xt]}:} &  &  &  & \\[0pt]
\emph{\# – instruction:} \texttt{lui t6, 0xhhhhh} &  &  &  & \\[0pt]
\emph{\# – encoded:} \emph{\texttt{0xhhhhh}} \texttt{11111}​\(^{d}\) \texttt{0110111} &  &  &  & \\[0pt]
\emph{\# 2. Add lowest 12 bits of \texttt{[xt]} and jump:} &  &  &  & \\[0pt]
\emph{\# – instr.:} \texttt{jalr ra, 0xhhh(t6)} &  &  &  & \\[0pt]
\emph{\# – enc.:} \uline{\texttt{0xhhh}} \texttt{11111}​\(^{s_{1}}\) \texttt{000} \texttt{00001}​\(^{d}\) \texttt{1101111} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Thus we generate code as follows:} &  &  &  & \\[0pt]
\emph{\#}\hspace{1.053000em}​\texttt{bbbbbbbb·bbbbbbbb·bbbb1111·10110111} &  &  &  & \\[0pt]
\emph{\#}\hspace{1.053000em}​\texttt{bbbbbbbb·bbbb1111·10000000·11100111} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Care is required to compensate for the} &  &  &  & \\[0pt]
\emph{\# potential sign-extension of \texttt{jalr}​'s} &  &  &  & \\[0pt]
\emph{\# immediate operand.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\emph{\# A useful bit mask.} &  &  &  & \\[0pt]
\texttt{mask@t1 ← 0x00000FFF;} & \textbf{lui} t1, 1 & \emph{\texttt{0x00001}}                                                  \texttt{00110}​\(^{d}\)  \texttt{0110111} & \texttt{F8} & \texttt{37 13 00 00}\\[0pt]
 & \textbf{addi} t1, t1, -1 & \emph{\texttt{0xFFF}}                    \texttt{00110}​\(^{s_{1}}\) \texttt{000} \texttt{00110}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 03 F3 FF}\\[0pt]
\emph{\# Load code address from \texttt{xt}} &  &  &  & \\[0pt]
\emph{\# and extract low \& high bits.} &  &  &  & \\[0pt]
\texttt{addr@t0 ← [xt@a0];} & \textbf{lwu} t0, 0(a0) & \uline{\texttt{0x000}}                    \texttt{01010}​\(^{s_{1}}\) \texttt{110} \texttt{00101}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 62 05 00}\\[0pt]
\texttt{high@t2 ← addr@t0 >{}>{} 12;} & \textbf{srli} t2, t0, 12 & \texttt{000000}​\emph{\texttt{001100}}​\(^{sh}\)         \texttt{00101}​\(^{s_{1}}\) \texttt{101} \texttt{00111}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 D3 C2 00}\\[0pt]
\texttt{low@t3 ← addr@t0 \& 0x00000FFF;} & \textbf{and} t3, t0, t1 & \texttt{0000000} \texttt{00110}​\(^{s_{2}}\) \texttt{00101}​\(^{s_{1}}\) \texttt{111} \texttt{11100}​\(^{d}\)  \texttt{0110011} &  & \texttt{33 FE 62 00}\\[0pt]
 &  &  &  & \\[0pt]
\emph{\# 1. Assemble and write \texttt{lui} instr.} &  &  &  & \\[0pt]
\texttt{sign@t4 ← low@t3 >{}>{} 11;} & \textbf{srli} t4, t3, 11 & \texttt{000000}​\emph{\texttt{001011}}​\(^{sh}\)         \texttt{11100}​\(^{s_{1}}\) \texttt{101} \texttt{11101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 5E BE 00}\\[0pt]
\texttt{high@t2 ← high@t2 + sign@t4;} & \textbf{add} t2, t2, t4 & \texttt{0000000} \texttt{11101}​\(^{s_{2}}\) \texttt{00111}​\(^{s_{1}}\) \texttt{000} \texttt{00111}​\(^{d}\)  \texttt{0110011} &  & \texttt{B3 83 D3 01}\\[0pt]
\texttt{instr@t2 ← (high@t2 <{}<{} 12) + 0x00000FB7;} & \textbf{slli} t2, t2, 12 & \texttt{000000}​\emph{\texttt{001100}}​\(^{sh}\)         \texttt{00111}​\(^{s_{1}}\) \texttt{001} \texttt{00111}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 93 C3 00}\\[0pt]
 & \textbf{andi} t4, t1, 0xFB7 & \emph{\texttt{0xFB7}}                    \texttt{00110}​\(^{s_{1}}\) \texttt{111} \texttt{11101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 7E 73 FB}\\[0pt]
 & \textbf{add} t2, t2, t4 & \texttt{0000000} \texttt{11101}​\(^{s_{2}}\) \texttt{00111}​\(^{s_{1}}\) \texttt{000} \texttt{00111}​\(^{d}\)  \texttt{0110011} &  & \texttt{B3 83 D3 01}\\[0pt]
\texttt{[OUTPUT@s1] ← instr@t2;} & \textbf{sw} t2, 0(s1) & \uline{\texttt{0000000}} \texttt{00111}​\(^{s_{2}}\) \texttt{01001}​\(^{s_{1}}\) \texttt{010} \uline{\texttt{00000}} \texttt{0100011} &  & \texttt{23 A0 74 00}\\[0pt]
 &  &  &  & \\[0pt]
\emph{\# 2. Assemble and write \texttt{jalr} instr.} &  &  &  & \\[0pt]
\texttt{instr@t3 = (low@t3 <{}<{} 20)} \(\vert{}\) \texttt{0x000F80E7;} & \textbf{slli} t3, t3, 20 & \texttt{000000}​\emph{\texttt{010100}}​\(^{sh}\)         \texttt{11100}​\(^{s_{1}}\) \texttt{001} \texttt{11100}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 1E 4E 01}\\[0pt]
 & \textbf{lui} t4, 0xF8 & \emph{\texttt{0x000F8}}                                                  \texttt{11101}​\(^{d}\)  \texttt{0110111} &  & \texttt{B7 8E 0F 00}\\[0pt]
 & \textbf{addi} t4, t4, 0x0E7 & \emph{\texttt{0x0E7}}                    \texttt{11101}​\(^{s_{1}}\) \texttt{000} \texttt{11101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 8E 7E 0E}\\[0pt]
 & \textbf{or} t3, t3, t4 & \texttt{0000000} \texttt{11101}​\(^{s_{2}}\) \texttt{11100}​\(^{s_{1}}\) \texttt{110} \texttt{11100}​\(^{d}\)  \texttt{0110011} &  & \texttt{33 6E DE 01}\\[0pt]
\texttt{[OUTPUT@s1 + 4] ← instr@t3;} & \textbf{sw} t3, 4(s1) & \uline{\texttt{0000000}} \texttt{11100}​\(^{s_{2}}\) \texttt{01001}​\(^{s_{1}}\) \texttt{010} \uline{\texttt{00100}} \texttt{0100011} &  & \texttt{23 A2 C4 01}\\[0pt]
 &  &  &  & \\[0pt]
\texttt{OUTPUT@s1 += 8;} & \textbf{addi} s1, s1, 8 & \emph{\texttt{0x008}}                    \texttt{01001}​\(^{s_{1}}\) \texttt{000} \texttt{01001}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 84 84 00}\\[0pt]
\texttt{return.}  \emph{\# To interpreter loop.} & \textbf{jalr} zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} &  & \texttt{67 80 00 00}\\[0pt]
 &  &  & \texttt{140} & \\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgb7b8abe}\texttt{COMPL} compiles a call to the given execution token (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}
\pagebreak

\subsubsection{Subroutine \texttt{Head}}
\label{sec:org077dd1b}

Subroutine \texttt{Head}, shown in Table \ref{tab:org9639062}, brings a
complication due to RISC-V's \emph{reduced} instruction offer.  While in
x86-64 copying the word name into the dictionary's name field was done
by a single combined \texttt{rep movs [rdi], [rsi]} instruction, in RISC-V we
had to write our own loop for the same purpose.  The proponents of
RISC ISAs argue that this simplifies hardware design enough to justify
the increased complexity of compilers (and code size)
\citeprocitem{24}{[24]}.

Another, more interesting, complication occurs because of RISC-V's
mandatory instruction alignment to even addresses
\citeprocitem{25}{[25]}.  Since the binary interpreter copies all
bytes ``around'' commands to \texttt{OUTPUT}, odd word names in definition
commands can lead to misaligned RISC-V instructions in defined Forth
words.  Actually, even without considering code copied by the binary
interpreter, the simple presence of odd-length commands shifts all
instructions following them to misaligned positions, leading to the
dreaded \texttt{Illegal instruction} trap message that we have so often had
the pleasure to encounter.  The solution is simple:
\begin{itemize}
\item insert a padding byte after odd-length definition commands;
\item perform additional aligning of both \texttt{INPUT} and \texttt{OUTPUT} after
copying word names into the dictionary.
\end{itemize}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{7}{8.400000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{\&} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{Head}} & --- & --- & \texttt{140} & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{48 65 61 64}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( latest@a0} &  &  &  & \\[0pt]
\emph{\#}\hspace{4.9em}   \texttt{flag@a1 -​- )} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# 16-bit align \texttt{OUTPUT}.} &  &  &  & \\[0pt]
\hspace{1.053000em}​\texttt{OUTPUT@s1 += 0x00F;} & \textbf{addi} s1, s1, \emph{0x00F} & \emph{\texttt{0x00F}}                    \texttt{01001}​\(^{s_{1}}\) \texttt{000} \texttt{01001}​\(^{d}\)  \texttt{0010011} & \texttt{146} & \texttt{93 84 F4 00}\\[0pt]
\hspace{1.053000em}​\texttt{OUTPUT@s1 \&= 0xFF0;} & \textbf{andi} s1, s1, \emph{0xFF0} & \emph{\texttt{0xFF0}}                    \texttt{01001}​\(^{s_{1}}\) \texttt{111} \texttt{01001}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 F4 04 FF}\\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# New word starts here.} &  &  &  & \\[0pt]
\hspace{1.053000em}​\texttt{xt@t0 ← OUTPUT@s1;} & \textbf{or} t0, s1, s1 & \texttt{0000000} \texttt{01001}​\(^{s_{2}}\) \texttt{01001}​\(^{s_{1}}\) \texttt{110} \texttt{00101}​\(^{d}\)  \texttt{0110011} &  & \texttt{B3 E2 94 00}\\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# Fill the new dictionary entry:} &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\#} &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# 1. Set the \uline{link} field, then point} &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# \texttt{LATEST} (\texttt{VARS+40}) to new word.} &  &  &  & \\[0pt]
\hspace{1.053000em}​\texttt{[xt@t0 + 8] ← latest@a0;} & \textbf{sd} a0, \uline{8}​(t0) & \uline{\texttt{0000000}} \texttt{01010}​\(^{s_{2}}\) \texttt{00101}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{01000}} \texttt{0100011} &  & \texttt{23 B4 A2 00}\\[0pt]
\hspace{1.053000em}​\texttt{[LATEST] ← xt@t0;} & \textbf{sd} t0, \uline{40}​(s2) & \uline{\texttt{0000001}} \texttt{00101}​\(^{s_{2}}\) \texttt{10010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{01000}} \texttt{0100011} &  & \texttt{23 34 59 02}\\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# 2. Set the \uline{flag+length} field.} &  &  &  & \\[0pt]
\hspace{1.053000em}​\texttt{[xt@t0 + 16] ← flag@a1;} & \textbf{sb} a1, \uline{16}​(t0) & \uline{\texttt{0000000}} \texttt{01011}​\(^{s_{2}}\) \texttt{00101}​\(^{s_{1}}\) \texttt{000} \uline{\texttt{10000}} \texttt{0100011} &  & \texttt{23 88 B2 00}\\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# 3. Extract name length from} &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# \texttt{flag} and fill the \uline{name} field.} &  &  &  & \\[0pt]
\hspace{1.053000em}​\texttt{length@t1 ← flag@a1 \& 0x1F;} & \textbf{andi} t1, a1, \emph{0x01F} & \emph{\texttt{0x01F}}                    \texttt{01011}​\(^{s_{1}}\) \texttt{111} \texttt{00110}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 F3 F5 01}\\[0pt]
\hspace{1.053000em}​\texttt{OUTPUT@s1 ← xt@t0 + 17;} & \textbf{addi} s1, t0, \emph{0x011} & \emph{\texttt{0x011}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{000} \texttt{01001}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 84 12 01}\\[0pt]
\texttt{\_begin:} &  &  & \(\overline{\texttt{00}}\) & \\[0pt]
\hspace{1.053000em}​\texttt{chr@t2 ← [INPUT@s0++];} & \textbf{lbu} t2, \uline{0}​(s0) & \uline{\texttt{0x000}}                    \texttt{01000}​\(^{s_{1}}\) \texttt{100} \texttt{00111}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 43 04 00}\\[0pt]
 & \textbf{addi} s0, s0, \emph{1} & \emph{\texttt{0x001}}                    \texttt{01000}​\(^{s_{1}}\) \texttt{000} \texttt{01000}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 04 14 00}\\[0pt]
\hspace{1.053000em}​\texttt{[OUTPUT@s1] ← chr@t2;} & \textbf{sb} t2, \uline{0}​(s1) & \uline{\texttt{0000000}} \texttt{00111}​\(^{s_{2}}\) \texttt{01001}​\(^{s_{1}}\) \texttt{000} \uline{\texttt{00000}} \texttt{0100011} &  & \texttt{23 80 74 00}\\[0pt]
 & \textbf{addi} s1, s1, \emph{1} & \emph{\texttt{0x001}}                    \texttt{01001}​\(^{s_{1}}\) \texttt{000} \texttt{01001}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 84 14 00}\\[0pt]
\hspace{1.053000em}​\texttt{length@t1-{}-{};} & \textbf{addi} t1, t1, \emph{-1} & \emph{\texttt{0xFFF}}                    \texttt{00110}​\(^{s_{1}}\) \texttt{000} \texttt{00110}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 03 F3 FF}\\[0pt]
\hspace{1.053000em}​\texttt{if length@t1 != 0:} &  &  &  & \\[0pt]
\hspace{2.106000em}​  \texttt{goto \_begin;} & \textbf{bne} t1, zero, \uline{0xFEC} & \uline{\texttt{1111111}} \texttt{00000}​\(^{s_{2}}\) \texttt{00110}​\(^{s_{1}}\) \texttt{001} \uline{\texttt{01101}} \texttt{1100011} & \texttt{14} & \texttt{E3 16 03 FE}\\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# One padding byte might follow} &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# the word's name to abide by} &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# RISC-V's requirement to align} &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# instructions to even addresses \citeprocitem{25}{[25]}.} &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# Both \texttt{INPUT} and \texttt{OUTPUT} need to be} &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# 1-bit aligned: the former to keep} &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# instructions in the executable} &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# aligned and former to make sure} &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# that compiled code is also aligned.} &  &  &  & \\[0pt]
\hspace{1.053000em}​\texttt{INPUT@s0 += 0x001;} & \textbf{addi} s0, s0, \emph{0x001} & \emph{\texttt{0x001}}                    \texttt{01000}​\(^{s_{1}}\) \texttt{000} \texttt{01000}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 04 14 00}\\[0pt]
\hspace{1.053000em}​\texttt{INPUT@s0 \&= 0xFFE;} & \textbf{andi} s0, s0, \emph{0xFFE} & \emph{\texttt{0xFFE}}                    \texttt{01000}​\(^{s_{1}}\) \texttt{111} \texttt{01000}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 74 E4 FF}\\[0pt]
\hspace{1.053000em}​\texttt{OUTPUT@s1 += 0x001;} & \textbf{addi} s1, s1, \emph{0x001} & \emph{\texttt{0x001}}                    \texttt{01001}​\(^{s_{1}}\) \texttt{000} \texttt{01001}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 84 14 00}\\[0pt]
\hspace{1.053000em}​\texttt{OUTPUT@s1 \&= 0xFFE;} & \textbf{andi} s1, s1, \emph{0xFFE} & \emph{\texttt{0xFFE}}                    \texttt{01001}​\(^{s_{1}}\) \texttt{111} \texttt{01001}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 F4 E4 FF}\\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# 4b. Point \uline{code} field to the code} &  &  &  & \\[0pt]
\hspace{1.053000em}​\emph{\# about to be generated at \texttt{OUTPUT}.} &  &  &  & \\[0pt]
\hspace{1.053000em}​\texttt{[xt@t0 + 0] ← OUTPUT@s1;} & \textbf{sd} s1, \uline{0}​(t0) & \uline{\texttt{0000000}} \texttt{01001}​\(^{s_{2}}\) \texttt{00101}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} &  & \texttt{23 B0 92 00}\\[0pt]
\hspace{1.053000em}​\texttt{return.}  \emph{\# To interpreter loop.} & \textbf{jalr} zero, \uline{0}​(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} &  & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org9639062}Subroutine \texttt{Head} defines new words in the dictionary (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

As all programming environments do, low-level RISC-V programming tends
to favor certain idiomatic ways of achieving certain ends.  For
example, copying register \texttt{s1} to register \texttt{t0} is typically done by
an immediate add: \texttt{addi t0, s1, 0}.  The third line in \hyperref[tab:org9639062]{\texttt{Head}} proves
that we didn't learn this right away\ldots{}
\clearpage


\subsection{Interacting with the Outside World (RISC-V)}
\label{sec:org202871c}

Subroutine \texttt{BYE} is straightforward to implement on RISC-V (see Table
\ref{tab:orgda69cc4}).  The calling convention for RISC-V requires placing
the syscall number in register \texttt{a7} and the first syscall argument in
register \texttt{a0}.  Note that, in contrast to x86-64, the same calling
convention is used by both kernel system calls and user-space function
calls.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{BYE}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{03} \uline{\texttt{42 59 45}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( -​- )} &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
 &  &  & \\[0pt]
\emph{\# Goodbye, world (exit syscall).} &  &  & \\[0pt]
\texttt{nr@a7 ← 93;}  \emph{\# \texttt{\_\_NR\_exit}.} & \textbf{addi} a7, zero, 0x05D & \emph{\texttt{0x05D}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{10001}​\(^{d}\)  \texttt{0010011} & \texttt{93 08 D0 05}\\[0pt]
 &  &  & \\[0pt]
\texttt{status@a0 ← 0;} & \textbf{addi} a0, zero, 0 & \emph{\texttt{0x000}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{01010}​\(^{d}\)  \texttt{0010011} & \texttt{13 05 00 00}\\[0pt]
\texttt{syscall exit(status@a0).} & \textbf{ecall} & \texttt{000000000000}     \texttt{00000}                           \texttt{000} \texttt{00000}          \texttt{1110011} & \texttt{73 00 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgda69cc4}\texttt{BYE} terminates the program by performing an \texttt{exit} syscall (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

The translation of \texttt{TYPE} to RISC-V required only the addition of a
subroutine prologue and epilogue that save and restore the return
address and two working registers.

In RISC-V both function calls and returns are done using the \texttt{jalr}
instruction. As already discussed in \texttt{COMPL}, \texttt{jalr} does not
implicitly push the return address on the stack.  It also does not
restore the return address before or after a function return.  The
consequence is that functions need explicit prologues and epilogues
for return address preservation \citeprocitem{25}{[25]}.

In contrast to the x86-64 implementation, we also need to save
argument registers \texttt{a0} and \texttt{a1} to callee-saved registers \texttt{s0} and
\texttt{s1} because they are not preserved by syscalls
\citeprocitem{32}{[32]}.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{7}{8.400000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{\&} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{TYPE}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{54 59 50 45}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( addr@a0 u@a1} -- )\textasciitilde{} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Print memory range \texttt{[addr, addr+u)}.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\hspace{1em} \emph{\# Use saved registers to preserve} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# values of \texttt{addr} and \texttt{a1} across} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# the \texttt{write} system calls \citeprocitem{32}{[32]}.} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# Also save the return address.} &  &  &  & \\[0pt]
\hspace{1em} \texttt{save s10, s11, ra;} & \textbf{addi} sp, sp, -24 & \emph{\texttt{0xFE.8}}                    \texttt{0001.0}​\(^{s_{1}}\) \texttt{000} \texttt{0001.0}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 01 81 FE}\\[0pt]
 & \textbf{sd} ra, 16(sp) & \uline{\texttt{0000000}} \texttt{0.0001}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{1000.0}} \texttt{0100011} &  & \texttt{23 38 11 00}\\[0pt]
 & \textbf{sd} s11, 8(sp) & \uline{\texttt{0000000}} \texttt{1.1011}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0100.0}} \texttt{0100011} &  & \texttt{23 34 B1 01}\\[0pt]
 & \textbf{sd} s10, 0(sp) & \uline{\texttt{0000000}} \texttt{1.1010}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0000.0}} \texttt{0100011} &  & \texttt{23 30 A1 01}\\[0pt]
\hspace{1em} \texttt{addr@s10 ← addr@a0;} & \textbf{addi} s10, a0, 0 & \emph{\texttt{0x00.0}}                    \texttt{0101.0}​\(^{s_{1}}\) \texttt{000} \texttt{1101.0}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 0D 05 00}\\[0pt]
\hspace{1em} \texttt{u@s11 ← u@a1;} & \textbf{addi} s11, a1, 0 & \emph{\texttt{0x00.0}}                    \texttt{0101.1}​\(^{s_{1}}\) \texttt{000} \texttt{1101.1}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 8D 05 00}\\[0pt]
 &  &  &  & \\[0pt]
\texttt{\_begin:} &  &  & \(\overline{\texttt{00}}\)\textsuperscript{\ref{org6c31c71}} & \\[0pt]
\hspace{1em} \texttt{fd@a0 ← 1;}  \emph{\# \texttt{STDOUT\_FILENO}.} & \textbf{addi} a0, zero, 1 & \emph{\texttt{0x00.1}}                    \texttt{0000.0}​\(^{s_{1}}\) \texttt{000} \texttt{0101.0}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 05 10 00}\\[0pt]
\hspace{1em} \texttt{addr@a1 ← addr@s10;} & \textbf{addi} a1, s10, 0 & \emph{\texttt{0x00.0}}                    \texttt{1101.0}​\(^{s_{1}}\) \texttt{000} \texttt{0101.1}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 05 0D 00}\\[0pt]
\hspace{1em} \texttt{u@a2 ← u@s11;} & \textbf{addi} a2, s11, 0 & \emph{\texttt{0x00.0}}                    \texttt{1101.1}​\(^{s_{1}}\) \texttt{000} \texttt{0110.0}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 86 0D 00}\\[0pt]
\hspace{1em} \texttt{nr@a7 ← 64;}  \emph{\# \texttt{\_\_NR\_write}.} & \textbf{addi} a7, zero, 64 & \emph{\texttt{0x04.0}}                    \texttt{0000.0}​\(^{s_{1}}\) \texttt{000} \texttt{1000.1}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 08 00 04}\\[0pt]
\hspace{1em} \texttt{syscall write(fd@a0,} &  &  &  & \\[0pt]
\hspace{1em}\hspace{7.371000em}    \texttt{addr@a1,} &  &  &  & \\[0pt]
\hspace{1em}\hspace{7.371000em}    \texttt{u@a2);} & \textbf{ecall} & \texttt{00000000.0000}                      \texttt{0000.0}          \texttt{000} \texttt{0000.0}          \texttt{1110011} &  & \texttt{73 00 00 00}\\[0pt]
\hspace{1em} \texttt{if ret@a0 < 0:} &  &  &  & \\[0pt]
\hspace{2em} \emph{\# An error occured.} &  &  &  & \\[0pt]
\hspace{2em}     \texttt{goto \_end.} & \textbf{blt} a0, zero, \uline{+0x10} & \uline{\texttt{0000000}} \texttt{0.0000}​\(^{s_{2}}\) \texttt{0101.0}​\(^{s_{1}}\) \texttt{100} \uline{\texttt{1000.0}} \texttt{1100011} & \texttt{14} & \texttt{63 48 05 00}\\[0pt]
\hspace{1em} \emph{\# Advance by \texttt{ret} (printed) bytes.} &  &  &  & \\[0pt]
\hspace{1em} \texttt{addr@s10 += ret@a0;} & \textbf{add} s10, s10, a0 & \texttt{0000000} \texttt{0.1010}​\(^{s_{2}}\) \texttt{1101.0}​\(^{s_{1}}\) \texttt{000} \texttt{1101.0}​\(^{d}\)  \texttt{0110011} &  & \texttt{33 0D AD 00}\\[0pt]
\hspace{1em} \emph{\# Fewer bytes left to print.} &  &  &  & \\[0pt]
\hspace{1em} \texttt{u@s11 -= ret@a0;} & \textbf{sub} s11, s11, a0 & \texttt{0100000} \texttt{0.1010}​\(^{s_{2}}\) \texttt{1101.1}​\(^{s_{1}}\) \texttt{000} \texttt{1101.1}​\(^{d}\)  \texttt{0110011} &  & \texttt{B3 8D AD 40}\\[0pt]
\hspace{1em} \texttt{if u@s11 > 0:} &  &  &  & \\[0pt]
\hspace{2em}     \emph{\# We still have bytes to print.} &  &  &  & \\[0pt]
\hspace{2em}     \texttt{goto \_begin.} & \textbf{blt} zero, s11, \uline{-0x20} & \uline{\texttt{1111111}} \texttt{1.1011}​\(^{s_{2}}\) \texttt{0000.0}​\(^{s_{1}}\) \texttt{100} \uline{\texttt{0000.1}} \texttt{1100011} & \texttt{20} & \texttt{E3 40 B0 FF}\\[0pt]
\texttt{\_end:} &  &  & \texttt{24} & \\[0pt]
\hspace{1em} \emph{\# Restore saved registers and return.} &  &  &  & \\[0pt]
\hspace{1em} \texttt{restore s10, s11, ra;} & \textbf{ld} s10, 0(sp) & \uline{\texttt{0x00.0}}                    \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \texttt{1101.0}​\(^{d}\)  \texttt{0000011} &  & \texttt{03 3D 01 00}\\[0pt]
 & \textbf{ld} s11, 8(sp) & \uline{\texttt{0x00.8}}                    \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \texttt{1101.1}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 3D 81 00}\\[0pt]
 & \textbf{ld} ra, 16(sp) & \uline{\texttt{0x01.0}}                    \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \texttt{0000.1}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 30 01 01}\\[0pt]
 & \textbf{addi} sp, sp, 24 & \emph{\texttt{0x01.8}}                    \texttt{0001.0}​\(^{s_{1}}\) \texttt{000} \texttt{0001.0}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 01 81 01}\\[0pt]
\hspace{1em} \texttt{return.} & \textbf{jalr} zero, 0(ra) & \uline{\texttt{0x00.0}}                    \texttt{0000.1}​\(^{s_{1}}\) \texttt{000} \texttt{0000.0}​\(^{d}\)  \texttt{1100111} &  & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org5add3e7}Subroutine \texttt{TYPE} dumps a memory range to \texttt{STDOUT} (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}
\clearpage


\subsection{Debugging Utilities (RISC-V)}
\label{sec:org59e06af}

Debugging utilities \texttt{dbg} and \texttt{reg} were ported to RISC-V in a
straightforward manner.  Subroutine \texttt{dbg}, shown in Table
\ref{tab:org7286704}, only required the addition of a prologue and
epilogue for saving and restoring the return address.  Since all
functions that call other functions require this modification in
RISC-V, we will not mention it hereafter.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{dbg}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{03} \uline{\texttt{64 52 67}}​\texttt{]}​\\[0pt]
\emph{\# In/Out:} \texttt{( -​- )} &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
\emph{\#} &  &  & \\[0pt]
\emph{\# Dump working memory.} &  &  & \\[0pt]
 &  &  & \\[0pt]
\texttt{save ra;} & \textbf{addi} sp, sp, -8 & \emph{\texttt{0xFF.8}}                    \texttt{0001.0}​\(^{s_{1}}\) \texttt{000} \texttt{0001.0}​\(^{d}\)  \texttt{0010011} & \texttt{13 01 81 FF}\\[0pt]
 & \textbf{sd} ra, 0(sp) & \uline{\texttt{0000000}} \texttt{0.0001}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0000.0}} \texttt{0100011} & \texttt{23 30 11 00}\\[0pt]
 &  &  & \\[0pt]
\emph{\# Dump memory contents} &  &  & \\[0pt]
\emph{\# using subroutine \texttt{TYPE}.} &  &  & \\[0pt]
\texttt{addr@a0 ← 0x0FFFFFE0;} & \textbf{lui} a0, 0x10000 & \emph{\texttt{0x10.00.0}}                                                  \texttt{0101.0}​\(^{d}\)  \texttt{0110111} & \texttt{37 05 00 10}\\[0pt]
 & \textbf{addi} a0, a0, -0x20 & \emph{\texttt{0xFE.0}}                    \texttt{0101.0}​\(^{s_{1}}\) \texttt{000} \texttt{0101.0}​\(^{d}\)  \texttt{0010011} & \texttt{13 05 05 FE}\\[0pt]
\texttt{u@a1 ← 0xA00;} & \textbf{lui} a1, 0x00001 & \emph{\texttt{0x00.00.1}}                                                  \texttt{0101.1}​\(^{d}\)  \texttt{0110111} & \texttt{B7 15 00 00}\\[0pt]
 & \textbf{addi} a1, a1, 0xA00 & \emph{\texttt{0xA0.0}}                    \texttt{0101.1}​\(^{s_{1}}\) \texttt{000} \texttt{0101.1}​\(^{d}\)  \texttt{0010011} & \texttt{93 85 05 A0}\\[0pt]
\emph{\# Compile a call to \texttt{TYPE}.} &  &  & \\[0pt]
\texttt{call TYPE;}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{54}​\(_{T}\)​\texttt{]}\\[0pt]
 &  &  & \\[0pt]
\texttt{restore ra;} & \textbf{ld} ra, 0(sp) & \uline{\texttt{0x00.0}}                    \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \texttt{0000.1}​\(^{d}\)  \texttt{0000011} & \texttt{83 30 01 00}\\[0pt]
 & \textbf{addi} sp, sp, 8 & \emph{\texttt{0x00.8}}                    \texttt{0001.0}​\(^{s_{1}}\) \texttt{000} \texttt{0001.0}​\(^{d}\)  \texttt{0010011} & \texttt{13 01 81 00}\\[0pt]
 &  &  & \\[0pt]
\texttt{return.} & \textbf{jalr} zero, 0(ra) & \uline{\texttt{0x00.0}}                    \texttt{0000.1}​\(^{s_{1}}\) \texttt{000} \texttt{0000.0}​\(^{d}\)  \texttt{1100111} & \texttt{67 80 00 00}\\[0pt]
 &  &  & \\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org7286704}Subroutine \texttt{dbg} dumps the working memory to \texttt{STDOUT} (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

Subroutine \texttt{reg} in RISC-V is a direct translation of its original
x86-64 implementation, except that it has been extended to print the
32 general purpose registers available in the RISC-V architecture.  It
is listed in Table \ref{tab:org03e6a5c}.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{reg}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{03} \uline{\texttt{72 65 67}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( -​- )} &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
\emph{\#} &  &  & \\[0pt]
\emph{\# Dump the registers.} &  &  & \\[0pt]
 &  &  & \\[0pt]
\emph{\# Allocate stack space for all} &  &  & \\[0pt]
\emph{\# 32 RISC-V general-purpose} &  &  & \\[0pt]
\emph{\# registers and for the return} &  &  & \\[0pt]
\emph{\# address (8 * 32 + 8).} &  &  & \\[0pt]
\texttt{save ra;} & \textbf{addi} sp, sp, -264 & \emph{\texttt{0xEF.8}}                    \texttt{0001.0}​\(^{s_{1}}\) \texttt{000} \texttt{0001.0}​\(^{d}\)  \texttt{0010011} & \texttt{13 01 81 EF}\\[0pt]
 & \textbf{sd} ra, 256(sp) & \uline{\texttt{0001000}} \texttt{0.0001}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0000.0}} \texttt{0100011} & \texttt{23 30 11 10}\\[0pt]
 &  &  & \\[0pt]
\emph{\# Push the 32 registers on the} & \textbf{sd} zero,  0(sp) & \uline{\texttt{0000000}} \texttt{0.0000}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0000.0}} \texttt{0100011} & \texttt{23 30 01 00}\\[0pt]
\emph{\# they're displayed like this:} & \textbf{sd} a6,    0(sp) & \uline{\texttt{0000000}} \texttt{1.0000}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0100.0}} \texttt{0100011} & \texttt{23 34 01 01}\\[0pt]
\emph{\# stack so that when printed} & \textbf{sd} ra,    0(sp) & \uline{\texttt{0000000}} \texttt{0.0001}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{1000.0}} \texttt{0100011} & \texttt{23 38 11 00}\\[0pt]
\emph{\#} & \textbf{sd} a7,    8(sp) & \uline{\texttt{0000000}} \texttt{1.0001}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{1100.0}} \texttt{0100011} & \texttt{23 3C 11 01}\\[0pt]
\emph{\#}\hspace{2.106000em} \texttt{·-{}-{}-{}-{}-{}-{}-{}-{}-·} & \textbf{sd} sp,   16(sp) & \uline{\texttt{0000001}} \texttt{0.0010}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0000.0}} \texttt{0100011} & \texttt{23 30 21 02}\\[0pt]
\emph{\#}\hspace{2.106000em} \texttt{¦}​\hspace{0.526500em}​\texttt{x0 ¦ a6 ¦} & \textbf{sd} s2,   24(sp) & \uline{\texttt{0000001}} \texttt{1.0010}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0100.0}} \texttt{0100011} & \texttt{23 34 21 03}\\[0pt]
\emph{\#}\hspace{2.106000em} \texttt{¦}​\hspace{0.526500em}​\texttt{ra ¦ s7 ¦} & \textbf{sd} gp,   32(sp) & \uline{\texttt{0000001}} \texttt{0.0011}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{1000.0}} \texttt{0100011} & \texttt{23 38 31 02}\\[0pt]
\emph{\#}\hspace{2.106000em} \texttt{¦}​\hspace{0.526500em}​\texttt{·· ¦ ·· ¦} & \textbf{sd} s3,   40(sp) & \uline{\texttt{0000001}} \texttt{1.0011}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{1100.0}} \texttt{0100011} & \texttt{23 3C 31 03}\\[0pt]
\emph{\#}\hspace{2.106000em} \texttt{¦}​\hspace{0.526500em}​\texttt{a4 ¦ t5 ¦} & \textbf{sd} tp,   48(sp) & \uline{\texttt{0000010}} \texttt{0.0100}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0000.0}} \texttt{0100011} & \texttt{23 30 41 04}\\[0pt]
\emph{\#}\hspace{2.106000em} \texttt{¦}​\hspace{0.526500em}​\texttt{a5 ¦ p6 ¦} & \textbf{sd} s4,   56(sp) & \uline{\texttt{0000010}} \texttt{1.0100}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0100.0}} \texttt{0100011} & \texttt{23 34 41 05}\\[0pt]
\emph{\#}\hspace{2.106000em} \texttt{¦}​\hspace{0.526500em}​\texttt{pc ¦ -{}-{} ¦} & \textbf{sd} t0,   64(sp) & \uline{\texttt{0000010}} \texttt{0.0101}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{1000.0}} \texttt{0100011} & \texttt{23 38 51 04}\\[0pt]
\emph{\#}\hspace{2.106000em} \texttt{·-{}-{}-{}-{}-{}-{}-{}-{}-·} & \textbf{sd} s5,   72(sp) & \uline{\texttt{0000010}} \texttt{1.0101}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{1100.0}} \texttt{0100011} & \texttt{23 3C 51 05}\\[0pt]
 & \textbf{sd} t1,   80(sp) & \uline{\texttt{0000011}} \texttt{0.0110}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0000.0}} \texttt{0100011} & \texttt{23 30 61 06}\\[0pt]
 & \textbf{sd} s6,   88(sp) & \uline{\texttt{0000011}} \texttt{1.0110}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0100.0}} \texttt{0100011} & \texttt{23 34 61 07}\\[0pt]
 & \textbf{sd} t2,   96(sp) & \uline{\texttt{0000011}} \texttt{0.0111}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{1000.0}} \texttt{0100011} & \texttt{23 38 71 06}\\[0pt]
 & \textbf{sd} s7,  104(sp) & \uline{\texttt{0000011}} \texttt{1.0111}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{1100.0}} \texttt{0100011} & \texttt{23 3C 71 07}\\[0pt]
 & \textbf{sd} s0,  112(sp) & \uline{\texttt{0000100}} \texttt{0.1000}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0000.0}} \texttt{0100011} & \texttt{23 30 81 08}\\[0pt]
 & \textbf{sd} s8,  120(sp) & \uline{\texttt{0000100}} \texttt{1.1000}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0100.0}} \texttt{0100011} & \texttt{23 34 81 09}\\[0pt]
 & \textbf{sd} s1,  128(sp) & \uline{\texttt{0000100}} \texttt{0.1001}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{1000.0}} \texttt{0100011} & \texttt{23 38 91 08}\\[0pt]
 & \textbf{sd} s9,  136(sp) & \uline{\texttt{0000100}} \texttt{1.1001}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{1100.0}} \texttt{0100011} & \texttt{23 3C 91 09}\\[0pt]
 & \textbf{sd} a0,  144(sp) & \uline{\texttt{0000101}} \texttt{0.1010}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0000.0}} \texttt{0100011} & \texttt{23 30 A1 0A}\\[0pt]
 & \textbf{sd} s10, 152(sp) & \uline{\texttt{0000101}} \texttt{1.1010}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0100.0}} \texttt{0100011} & \texttt{23 34 A1 0B}\\[0pt]
 & \textbf{sd} a1,  160(sp) & \uline{\texttt{0000101}} \texttt{0.1011}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{1000.0}} \texttt{0100011} & \texttt{23 38 B1 0A}\\[0pt]
 & \textbf{sd} s11, 168(sp) & \uline{\texttt{0000101}} \texttt{1.1011}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{1100.0}} \texttt{0100011} & \texttt{23 3C B1 0B}\\[0pt]
 & \textbf{sd} a2,  176(sp) & \uline{\texttt{0000110}} \texttt{0.1100}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0000.0}} \texttt{0100011} & \texttt{23 30 C1 0C}\\[0pt]
 & \textbf{sd} t3,  184(sp) & \uline{\texttt{0000110}} \texttt{1.1100}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0100.0}} \texttt{0100011} & \texttt{23 34 C1 0D}\\[0pt]
 & \textbf{sd} a3,  192(sp) & \uline{\texttt{0000110}} \texttt{0.1101}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{1000.0}} \texttt{0100011} & \texttt{23 38 D1 0C}\\[0pt]
 & \textbf{sd} t4,  200(sp) & \uline{\texttt{0000110}} \texttt{1.1101}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{1100.0}} \texttt{0100011} & \texttt{23 3C D1 0D}\\[0pt]
 & \textbf{sd} a4,  208(sp) & \uline{\texttt{0000111}} \texttt{0.1110}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0000.0}} \texttt{0100011} & \texttt{23 30 E1 0E}\\[0pt]
 & \textbf{sd} t5,  216(sp) & \uline{\texttt{0000111}} \texttt{1.1110}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{0100.0}} \texttt{0100011} & \texttt{23 34 E1 0F}\\[0pt]
 & \textbf{sd} a5,  224(sp) & \uline{\texttt{0000111}} \texttt{0.1111}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{1000.0}} \texttt{0100011} & \texttt{23 38 F1 0E}\\[0pt]
 & \textbf{sd} t6,  232(sp) & \uline{\texttt{0000111}} \texttt{1.1111}​\(^{s_{2}}\) \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{1100.0}} \texttt{0100011} & \texttt{23 3C F1 0F}\\[0pt]
\emph{\# Print top 256 stack bytes} &  &  & \\[0pt]
\emph{\# using subroutine \texttt{TYPE}.} &  &  & \\[0pt]
\texttt{addr@a0 ← sp;} & \textbf{addi} a0, sp, 0 & \emph{\texttt{0x00.0}}                    \texttt{0001.0}​\(^{s_{1}}\) \texttt{000} \texttt{0101.0}​\(^{d}\)  \texttt{0010011} & \texttt{13 05 01 00}\\[0pt]
\texttt{u@a1 ← 256;} & \textbf{addi} a1, zero, 256 & \emph{\texttt{0x10.0}}                    \texttt{0000.0}​\(^{s_{1}}\) \texttt{000} \texttt{0101.1}​\(^{d}\)  \texttt{0010011} & \texttt{93 05 00 10}\\[0pt]
\texttt{call TYPE;}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{54}​\(_{T}\)​\texttt{]}\\[0pt]
 &  &  & \\[0pt]
\emph{\# Restore return address and} &  &  & \\[0pt]
\emph{\# clean the stack.} &  &  & \\[0pt]
\texttt{restore ra;} & \textbf{ld} ra, 256(sp) & \uline{\texttt{0x10.0}}                    \texttt{0001.0}​\(^{s_{1}}\) \texttt{011} \texttt{0000.1}​\(^{d}\)  \texttt{0000011} & \texttt{83 30 01 10}\\[0pt]
 & \textbf{addi} sp, sp, 264 & \emph{\texttt{0x10.8}}                    \texttt{0001.0}​\(^{s_{1}}\) \texttt{000} \texttt{0001.0}​\(^{d}\)  \texttt{0010011} & \texttt{13 01 81 10}\\[0pt]
\texttt{return.} & \textbf{jalr} zero, 0(ra) & \uline{\texttt{0x00.0}}                    \texttt{0000.1}​\(^{s_{1}}\) \texttt{000} \texttt{0000.0}​\(^{d}\)  \texttt{1100111} & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org03e6a5c}Subroutine \texttt{reg} dumps the registers to \texttt{STDOUT} (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}
\clearpage


\subsection{Text Interpreter (RISC-V)}
\label{sec:org7326c3d}

In porting SmithForth's text interpreter to RISC-V we followed its
general structure.  We will present the ported RISC-V routines in the
same fashion that we used for their x86-64 versions, commenting only
on local aspects that we found interesting.

\subsubsection{Parsing Forth: \texttt{REFILL}, \texttt{seek}, \texttt{PARSE}, \texttt{pname}, \texttt{(}, \texttt{\textbackslash{}} (RISC-V)}
\label{sec:org399825d}

Explicitly allocating a saved register for the \texttt{VARS} global variable
has payed off in this group of routines, as we were able to indirectly
reference variables \texttt{TIB}, \texttt{\#IN} and \texttt{>IN} without mentioning their
addresses.  This technique, useful in many applications where shared
global state is accessed independently from different routines, is
made easy by RISC-V's large number of callee-saved registers.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{7}{8.400000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{\&} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{REFILL}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{06} \uline{\texttt{52 45 46 49 4C 4C}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( -​- )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Advance \texttt{TIB} and set \texttt{\#IN} so} &  &  &  & \\[0pt]
\emph{\# that \texttt{[TIB, TIB + \#IN)} contains} &  &  &  & \\[0pt]
\emph{\# a new line to be parsed.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\hspace{1em} \emph{\# Advance \texttt{TIB}​ by \texttt{\#IN}.} &  &  &  & \\[0pt]
\hspace{1em} \emph{\#} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# Note:         \texttt{\#IN} is \texttt{VARS+0},} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# \hspace{2.35em} \texttt{TIB} is \texttt{VARS+8},} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# \hspace{2.35em} \texttt{>IN} is \texttt{VARS+16}.} &  &  &  & \\[0pt]
\hspace{1em} \texttt{\#in@t0 ← [\#IN];} & ld t0, 0(s2) & \uline{\texttt{0x000}}                    \texttt{00111}​\(^{s_{1}}\) \texttt{011} \texttt{00101}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 32 09 00}\\[0pt]
\hspace{1em} \texttt{tib@t1 ← [TIB] + \#in@t0;} & ld t1, 8(s2) & \uline{\texttt{0x008}}                    \texttt{10010}​\(^{s_{1}}\) \texttt{011} \texttt{00110}​\(^{d}\)  \texttt{0000011} &  & \texttt{03 33 89 00}\\[0pt]
\hspace{1em} & add t1, t1, t0 & \texttt{0000000} \texttt{00101}​\(^{s_{2}}\) \texttt{00110}​\(^{s_{1}}\) \texttt{000} \texttt{00110}​\(^{d}\)  \texttt{0110011} &  & \texttt{33 03 53 00}\\[0pt]
\hspace{1em} \texttt{[TIB] ← tib@t1;} & sd t1, 8(s2) & \uline{\texttt{0000000}} \texttt{00110}​\(^{s_{2}}\) \texttt{10010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{01000}} \texttt{0100011} &  & \texttt{23 34 69 00}\\[0pt]
\hspace{1em} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# Reset \texttt{\#IN} and \texttt{>IN} to 0.} &  &  &  & \\[0pt]
\hspace{1em} \texttt{\#in@t0 ← 0;} & addi t0, zero, 0 & \emph{\texttt{0x000}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{00101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 02 00 00}\\[0pt]
\hspace{1em} \texttt{[>IN] ← 0;} & sd zero, 16(s2) & \uline{\texttt{0000000}} \texttt{00000}​\(^{s_{2}}\) \texttt{10010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{10000}} \texttt{0100011} &  & \texttt{23 38 09 00}\\[0pt]
\hspace{1em} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# Advance \texttt{\#IN} until just} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# after first \texttt{LF} character.} &  &  &  & \\[0pt]
\texttt{\_begin:} &  &  & \(\overline{\texttt{00}}\) & \\[0pt]
\hspace{1em} \texttt{\#in@t0++;} & addi t0, t0, 1 & \emph{\texttt{0x001}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{000} \texttt{00101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 82 12 00}\\[0pt]
\hspace{1em} \texttt{chr@t3 ← [tib@t1 + \#in@t0 - 1];} & add t2, t1, t0 & \texttt{0000000} \texttt{00101}​\(^{s_{2}}\) \texttt{00110}​\(^{s_{1}}\) \texttt{000} \texttt{00111}​\(^{d}\)  \texttt{0110011} &  & \texttt{B3 03 53 00}\\[0pt]
\hspace{1em} & lbu t3, -1(t2) & \uline{\texttt{0xfff}}                    \texttt{00111}​\(^{s_{1}}\) \texttt{100} \texttt{11100}​\(^{d}\)  \texttt{0000011} &  & \texttt{03 CE F3 FF}\\[0pt]
\hspace{1em} \emph{\# Newline character?} &  &  &  & \\[0pt]
\hspace{1em} \texttt{if chr != 0x0A:} & addi t4, zero, 0x0A & \emph{\texttt{0x00A}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{11101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 0E A0 00}\\[0pt]
\hspace{2em}   \texttt{goto \_begin.} & bne t3, t4, -16 & \uline{\texttt{1111111}} \texttt{11101}​\(^{s_{2}}\) \texttt{11100}​\(^{s_{1}}\) \texttt{001} \uline{\texttt{10001}} \texttt{1100011} & \texttt{10} & \texttt{E3 18 DE FF}\\[0pt]
\hspace{1em} &  &  &  & \\[0pt]
\hspace{1em} \emph{\# Store the new \texttt{\#IN}.} &  &  &  & \\[0pt]
\hspace{1em} \texttt{[\#IN] ← \#in@t0;} & sd t0, 0(s2) & \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{10010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} &  & \texttt{23 30 59 00}\\[0pt]
\hspace{1em} \texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} &  & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org622c505}\texttt{REFILL} replenishes the \emph{parse area} by advancing \texttt{TIB} and \texttt{\#IN} (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{\&} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{seek}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{73 65 65 6B}}​\texttt{]}\\[0pt]
\emph{\# In/Out:}    \texttt{( low@a0 high@a1} &  &  &  & \\[0pt]
\emph{\#}\hspace{4.9em}      \texttt{"ccc"} &  &  &  & \\[0pt]
\emph{\#}\hspace{3.35em} \texttt{-​- eof@a0 )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Advance \texttt{>IN} until next} &  &  &  & \\[0pt]
\emph{\# char is within \texttt{[low, high)}} &  &  &  & \\[0pt]
\emph{\# or parse area is empty.} &  &  &  & \\[0pt]
\emph{\# Return \texttt{1} if the latter.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{eof@t5 ← 0;} & addi t5, zero, 0 & \emph{\texttt{0x000}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{11110}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 0F 00 00}\\[0pt]
\hspace{1.053000em} \texttt{high'@a1 ← high@a1} &  &  &  & \\[0pt]
\hspace{5.791500em}         \texttt{- low@a0;} & sub a1, a1, a0 & \texttt{0100000} \texttt{01010}​\(^{s_{2}}\) \texttt{01011}​\(^{s_{1}}\) \texttt{000} \texttt{01011}​\(^{d}\)  \texttt{0110011} &  & \texttt{B3 85 A5 40}\\[0pt]
\hspace{1.053000em} \texttt{>in@t2 ← [>IN];} & ld t2, 16(s2) & \uline{\texttt{0x010}}                    \texttt{10010}​\(^{s_{1}}\) \texttt{011} \texttt{00111}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 33 09 01}\\[0pt]
\hspace{1.053000em} \texttt{\#in@t0 ← [\#IN];} & ld t0, 0(s2) & \uline{\texttt{0x000}}                    \texttt{10010}​\(^{s_{1}}\) \texttt{011} \texttt{00101}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 32 09 00}\\[0pt]
\texttt{\_begin:} &  &  & \(\overline{\texttt{00}}\) & \\[0pt]
\hspace{1.053000em} \emph{\# Is parse area empty?} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if >in@t2} \(\ge ^{u}\) \texttt{\#in@t0:} &  &  &  & \\[0pt]
\hspace{2.106000em}   \texttt{goto \_end\_eof.} & bgeu t2, t0, 0x20 & \uline{\texttt{0000001}} \texttt{00101}​\(^{s_{2}}\) \texttt{00111}​\(^{s_{1}}\) \texttt{111} \uline{\texttt{00000}} \texttt{1100011} &  & \texttt{63 F0 53 02}\\[0pt]
\hspace{1.053000em} \emph{\# Get current character.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{tib@t1 ← [TIB];} & ld t1, 8(s2) & \uline{\texttt{0x008}}                    \texttt{10010}​\(^{s_{1}}\) \texttt{011} \texttt{00110}​\(^{d}\)  \texttt{0000011} &  & \texttt{03 33 89 00}\\[0pt]
\hspace{1.053000em} \texttt{chr@t3 ← [tib@t1} &  &  &  & \\[0pt]
\hspace{5.265000em}        \texttt{+ >in@t2];} & add t4, t1, t2 & \texttt{0000000} \texttt{00111}​\(^{s_{2}}\) \texttt{00110}​\(^{s_{1}}\) \texttt{000} \texttt{11101}​\(^{d}\)  \texttt{0110011} &  & \texttt{B3 0E 73 00}\\[0pt]
\hspace{1.053000em} & lbu t3, 0(t4) & \uline{\texttt{0x000}}                    \texttt{11101}​\(^{s_{1}}\) \texttt{100} \texttt{11100}​\(^{d}\)  \texttt{0000011} &  & \texttt{03 CE 0E 00}\\[0pt]
\hspace{1.053000em} \emph{\# Is \texttt{chr} in \texttt{[low, high)}?} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{chr'@t3 ← chr@t3} &  &  &  & \\[0pt]
\hspace{5.265000em}        \texttt{- low@a0;} & sub t3, t3, a0 & \texttt{0100000} \texttt{01010}​\(^{s_{2}}\) \texttt{11100}​\(^{s_{1}}\) \texttt{000} \texttt{11100}​\(^{d}\)  \texttt{0110011} &  & \texttt{33 0E AE 40}\\[0pt]
\hspace{1.053000em} \texttt{if chr'@t3} \textless{}\(^{u}\) \texttt{high'@a1:} &  &  &  & \\[0pt]
\hspace{2.106000em}   \texttt{goto \_end.} & bltu t3, a1, 0x10 & \uline{\texttt{0000000}} \texttt{01011}​\(^{s_{2}}\) \texttt{11100}​\(^{s_{1}}\) \texttt{110} \uline{\texttt{10000}} \texttt{1100011} & \texttt{14} & \texttt{63 68 BE 00}\\[0pt]
\hspace{1.053000em} \emph{\# Go to next character.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{>in@t2++;} & addi t2, t2, 1 & \emph{\texttt{0x001}}                    \texttt{00111}​\(^{s_{1}}\) \texttt{000} \texttt{00111}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 83 13 00}\\[0pt]
\hspace{1.053000em} \texttt{goto \_begin.} & jal zero, 0xFE4 & \uline{\texttt{01111110010100000000}}                                     \texttt{00000}​\(^{d}\)  \texttt{1101111} & \texttt{1C} & \texttt{6F F0 5F FE}\\[0pt]
\texttt{\_end\_eof:} &  &  & \texttt{20} & \\[0pt]
\hspace{1.053000em} \texttt{eof@t5 ← 1;} & addi t5, zero, 1 & \emph{\texttt{0x001}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{11110}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 0F 10 00}\\[0pt]
\texttt{\_end:} &  &  & \texttt{24} & \\[0pt]
\hspace{1.053000em} \texttt{[>IN] ← >in@t2;} & sd t2, 16(s2) & \uline{\texttt{0000000}} \texttt{00111}​\(^{s_{2}}\) \texttt{10010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{10000}} \texttt{0100011} &  & \texttt{23 38 79 00}\\[0pt]
\hspace{1.053000em} \texttt{eof@a0 ← eof@t5;} & addi a0, t5, 0 & \emph{\texttt{0x000}}                    \texttt{11110}​\(^{s_{1}}\) \texttt{000} \texttt{01010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 05 0F 00}\\[0pt]
\hspace{1.053000em} \texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} &  & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org5f8fa6a}\texttt{seek} parses characters until it finds one in a given range (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

The x86-64 version of \texttt{PARSE} implicitly received information from
\texttt{seek} through \texttt{CF} (the carry flag).  Since RISC-V completely does
away with the flags register, we adapted \texttt{PARSE} and \texttt{seek} (shown in
Tables \ref{tab:orgd3f81c3} and \ref{tab:org5f8fa6a}) to pass information
explicitly through registers.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{\&} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{PARSE}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{50 41 52 53 45}}​\texttt{]}\\[0pt]
\emph{\# In/Out:}    \texttt{( low@a0 high@a1} &  &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
\emph{\#}\hspace{4.9em}     ​\texttt{"ccc<char>"} &  &  &  & \\[0pt]
\emph{\#}\hspace{3.35em}​ \texttt{-​- addr@a0 u@a1 )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Parse until end of parse area} &  &  &  & \\[0pt]
\emph{\# or until a character in range} &  &  &  & \\[0pt]
\emph{\# \texttt{[low, high)} is encountered.} &  &  &  & \\[0pt]
\emph{\# Return parsed string as its} &  &  &  & \\[0pt]
\emph{\# address and length.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{push ra;} & addi sp, sp, -16 & \emph{\texttt{0xFF0}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 01 01 FF}\\[0pt]
\hspace{1.053000em} & sd ra, 8(sp) & \uline{\texttt{0000000}} \texttt{00001}​\(^{s_{2}}\) \texttt{00010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{01000}} \texttt{0100011} &  & \texttt{23 34 11 00}\\[0pt]
\hspace{1.053000em} \texttt{start@t0 ← [>IN];} & ld t0, 16(s2) & \uline{\texttt{0x010}}                    \texttt{10010}​\(^{s_{1}}\) \texttt{011} \texttt{00101}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 32 09 01}\\[0pt]
\hspace{1.053000em} \texttt{push start@t0;} & sd t0, 0(sp) & \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{00010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} &  & \texttt{23 30 51 00}\\[0pt]
\hspace{1.053000em} \emph{\# Compile a call to \texttt{seek}} &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# that advances \texttt{>IN}.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{call seek;}  \emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{73}​\(_{s}\)​\texttt{]}\\[0pt]
\hspace{1.053000em} \texttt{end@t1 ← [>IN];} & ld t1, 16(s2) & \uline{\texttt{0x010}}                    \texttt{10010}​\(^{s_{1}}\) \texttt{011} \texttt{00110}​\(^{d}\)  \texttt{0000011} &  & \texttt{03 33 09 01}\\[0pt]
\hspace{1.053000em} \texttt{restore start@t0;} & ld t0, 0(sp) & \uline{\texttt{0x000}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{011} \texttt{00101}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 32 01 00}\\[0pt]
\hspace{1.053000em} \emph{\# Did \texttt{seek()} encounter the} &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# end of the parse area?} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if eof@a0 != 0:} &  &  &  & \\[0pt]
\hspace{2.106000em}   \texttt{goto \_end.} & bne a0, zero, 12 & \uline{\texttt{0000000}} \texttt{00000}​\(^{s_{2}}\) \texttt{01010}​\(^{s_{1}}\) \texttt{001} \uline{\texttt{01100}} \texttt{1100011} & \(\overline{\texttt{00}}\) & \texttt{63 16 05 00}\\[0pt]
\hspace{1.053000em} \emph{\# A character in range} &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# \texttt{[low, high)} was found.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{[>IN]++;}  \emph{\# Skip it.} & addi t2, t1, 1 & \emph{\texttt{0x001}}                    \texttt{00110}​\(^{s_{1}}\) \texttt{000} \texttt{00111}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 03 13 00}\\[0pt]
\hspace{1.053000em} & sd t2, 16(s2) & \uline{\texttt{0000000}} \texttt{00111}​\(^{s_{2}}\) \texttt{10010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{10000}} \texttt{0100011} &  & \texttt{23 38 79 00}\\[0pt]
\texttt{\_end:} &  &  & \texttt{0C} & \\[0pt]
\hspace{1.053000em} \emph{\# Compute address and} &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# length of parsed input.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{addr@a0 ← [TIB]} & ld t2, 8(s2) & \uline{\texttt{0x008}}                    \texttt{10010}​\(^{s_{1}}\) \texttt{011} \texttt{00111}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 33 89 00}\\[0pt]
\hspace{5.265000em}         \texttt{+ start@t0;} & add a0, t2, t0 & \texttt{0000000} \texttt{00101}​\(^{s_{2}}\) \texttt{00111}​\(^{s_{1}}\) \texttt{000} \texttt{01010}​\(^{d}\)  \texttt{0110011} &  & \texttt{33 85 53 00}\\[0pt]
\hspace{1.053000em} \texttt{u@a1} \texttt{←} \texttt{end@t1} \texttt{-} \texttt{start@t0;} & sub a1, t1, t0 & \texttt{0100000} \texttt{00101}​\(^{s_{2}}\) \texttt{00110}​\(^{s_{1}}\) \texttt{000} \texttt{01011}​\(^{d}\)  \texttt{0110011} &  & \texttt{B3 05 53 40}\\[0pt]
\hspace{1.053000em} \texttt{pop ra;} & ld ra, 8(sp) & \uline{\texttt{0x008}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{011} \texttt{00001}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 30 81 00}\\[0pt]
\hspace{1.053000em} & addi sp, sp, 16 & \emph{\texttt{0x010}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 01 01 01}\\[0pt]
\hspace{1.053000em} \texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} &  & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgd3f81c3}\texttt{PARSE} returns the address and size of a newly parsed string (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{pname}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{05} \uline{\texttt{70 6E 61 6D 65}}​\texttt{]}\\[0pt]
\emph{\# In/Out:}   \texttt{( "<SPCs>ccc<SPC>"} &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
\emph{\#}\hspace{3.35em} \texttt{-​- addr@a0 u@a1 )} &  &  & \\[0pt]
\emph{\#} &  &  & \\[0pt]
\emph{\# Parse a token: first skip over} &  &  & \\[0pt]
\emph{\# non-printable characters, then} &  &  & \\[0pt]
\emph{\# parse the word itself.} &  &  & \\[0pt]
 &  &  & \\[0pt]
\texttt{push ra;} & addi sp, sp, -8 & \emph{\texttt{0xFF8}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} & \texttt{13 01 81 FF}\\[0pt]
 & sd ra, 0(sp) & \uline{\texttt{0000000}} \texttt{00001}​\(^{s_{2}}\) \texttt{00010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} & \texttt{23 30 11 00}\\[0pt]
\emph{\# Skip non-printables.} &  &  & \\[0pt]
\texttt{low@a0 ← 0x21;}   \emph{\# Char \texttt{'!'}.} & addi a0, zero, 0x021 & \emph{\texttt{0x021}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{01010}​\(^{d}\)  \texttt{0010011} & \texttt{13 05 10 02}\\[0pt]
\texttt{high@a1 ← 0x7F;}  \emph{\# Char \texttt{DEL}.} & addi a1, zero, 0x07F & \emph{\texttt{0x07F}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{01011}​\(^{d}\)  \texttt{0010011} & \texttt{93 05 F0 07}\\[0pt]
\texttt{call seek;}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{73}​\(_{s}\)​\texttt{]}\\[0pt]
\emph{\# Parse token, stopping at first} &  &  & \\[0pt]
\emph{\# non-printable character.} &  &  & \\[0pt]
\texttt{low@a0 ← 0x7F;} & addi a0, zero, 0x7F & \emph{\texttt{0x07F}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{01010}​\(^{d}\)  \texttt{0010011} & \texttt{13 05 F0 07}\\[0pt]
\texttt{high@a1 ← 0x21;} & addi a1, zero, 0x21 & \emph{\texttt{0x021}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{01011}​\(^{d}\)  \texttt{0010011} & \texttt{93 05 10 02}\\[0pt]
\texttt{call PARSE;}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{50}​\(_{P}\)​\texttt{]}\\[0pt]
\texttt{pop ra;} & ld ra, 0(sp) & \uline{\texttt{0x000}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{011} \texttt{00001}​\(^{d}\)  \texttt{0000011} & \texttt{83 30 01 00}\\[0pt]
 & addi sp, sp, 8 & \emph{\texttt{0x008}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} & \texttt{13 01 81 00}\\[0pt]
\texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org7cd7291}Subroutine \texttt{pname} parses a token and returns it as a string (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define immediate:} \uline{\texttt{\textbackslash{}}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{81} \uline{\texttt{5C}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( "ccc<eol>" -​- )} &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
\emph{\#} &  &  & \\[0pt]
\emph{\# Consumes all characters} &  &  & \\[0pt]
\emph{\# left on the current line.} &  &  & \\[0pt]
 &  &  & \\[0pt]
\texttt{\#in@t0 ← [\#IN];} & ld t0, 0(s2) & \uline{\texttt{0x000}}                    \texttt{10010}​\(^{s_{1}}\) \texttt{011} \texttt{00101}​\(^{d}\)  \texttt{0000011} & \texttt{83 32 09 00}\\[0pt]
\texttt{[>IN] ← \#in@t0;} & sd t0, 16(s2) & \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{10010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{10000}} \texttt{0100011} & \texttt{23 38 59 00}\\[0pt]
\texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orge8d1690}Subroutine \texttt{'\textbackslash{}'} implements line comments (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define immediate:} \uline{\texttt{(}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{81} \uline{\texttt{28}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( "ccc<rparen>" -​- )} &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
\emph{\#} &  &  & \\[0pt]
\emph{\# Consume characters until a ')'} &  &  & \\[0pt]
\emph{\# is encountered.} &  &  & \\[0pt]
 &  &  & \\[0pt]
\texttt{push ra;} & addi sp, sp, -8 & \emph{\texttt{0xFF8}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} & \texttt{13 01 81 FF}\\[0pt]
 & sd ra, 0(sp) & \uline{\texttt{0000000}} \texttt{00001}​\(^{s_{2}}\) \texttt{00010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} & \texttt{23 30 11 00}\\[0pt]
\texttt{low@a0 ← ')';} & addi a0, zero, 41 & \emph{\texttt{0x029}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{01010}​\(^{d}\)  \texttt{0010011} & \texttt{13 05 90 02}\\[0pt]
\texttt{high@a1 ← ')' + 1;} & addi a1, zero, 42 & \emph{\texttt{0x02A}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{01011}​\(^{d}\)  \texttt{0010011} & \texttt{93 05 A0 02}\\[0pt]
\texttt{call PARSE;}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{50}​\(_{P}\)​\texttt{]}\\[0pt]
\texttt{pop ra;} & ld ra, 0(sp) & \uline{\texttt{0x000}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{011} \texttt{00001}​\(^{d}\)  \texttt{0000011} & \texttt{83 30 01 00}\\[0pt]
 & addi sp, sp, 8 & \emph{\texttt{0x008}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} & \texttt{13 01 81 00}\\[0pt]
\texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org780aa49}Subroutine \texttt{'('} implements inline comments (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

There is not much to comment on the other parsing routines, as they
were straightforward to translate.

\subsubsection{Defining New Forth Words: \texttt{:}, \texttt{;}, \texttt{[}, \texttt{]}, \texttt{.}, \texttt{LIT} (RISC-V)}
\label{sec:org43f4163}

The word-defining words are more interesting.  When we analyzed
\texttt{COMPL} in SmithForth, we explained how RISC-V is different in the way
it doesn't save return addresses when performing function calls with
\texttt{jalr}.  Return addresses have to be saved and restored around call
sites or in function prologues and epilogues.  In order to keep colon
definitions small, we chose to implement the latter option.  It is
here, in \texttt{':'}, where we have to install a prologue before allowing a
Forth definition to proceed.

Shown in Table \ref{tab:org2160ea2}, in addition to the responsibilities
inherited from the original SmithForth, subroutine \texttt{':'} compiles two
instructions that effectively save the return address on the stack: an
\texttt{addi} instruction that allocates one stack slot, and an \texttt{sd}
instruction that stores return address register \texttt{ra} onto the stack.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{':'}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{01} \uline{\texttt{3A}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( "<SPCs>ccc<SPC>" -​- )} &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
\emph{\#} &  &  & \\[0pt]
\emph{\# Start a word definition and enter} &  &  & \\[0pt]
\emph{\# compiling mode. Temporarily hide} &  &  & \\[0pt]
\emph{\# the word being defined until its} &  &  & \\[0pt]
\emph{\# definition is completed by \texttt{';'}.} &  &  & \\[0pt]
\emph{\#} &  &  & \\[0pt]
\emph{\# RISC-V only: Because calls do not} &  &  & \\[0pt]
\emph{\# implicitly push the return address} &  &  & \\[0pt]
\emph{\# on the stack, we have to generate} &  &  & \\[0pt]
\emph{\# a prologue to the word that does it.} &  &  & \\[0pt]
 &  &  & \\[0pt]
\texttt{push ra;} & addi sp, sp, -8 & \emph{\texttt{0xFF8}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} & \texttt{13 01 81 FF}\\[0pt]
 & sd ra, 0(sp) & \uline{\texttt{0000000}} \texttt{00001}​\(^{s_{2}}\) \texttt{00010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} & \texttt{23 30 11 00}\\[0pt]
\emph{\# Parse word name and create} &  &  & \\[0pt]
\emph{\# its dictionary entry.} &  &  & \\[0pt]
\texttt{call pname;}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{70}​\(_{p}\)​\texttt{]}\\[0pt]
\texttt{INPUT@s0 ← addr@a0;} & addi s0, a0, 0 & \emph{\texttt{0x000}}                    \texttt{01010}​\(^{s_{1}}\) \texttt{000} \texttt{01000}​\(^{d}\)  \texttt{0010011} & \texttt{13 04 05 00}\\[0pt]
\texttt{latest@a0 ← [LATEST];} & ld a0, 40(s2) & \uline{\texttt{0x028}}                    \texttt{10010}​\(^{s_{1}}\) \texttt{011} \texttt{01010}​\(^{d}\)  \texttt{0000011} & \texttt{03 35 89 02}\\[0pt]
\emph{\# Word length \texttt{u@a1} is forwarded} &  &  & \\[0pt]
\emph{\# as \texttt{flag@a1} to \texttt{Head}.} &  &  & \\[0pt]
\texttt{call Head;}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{48}​\(_{H}\)​\texttt{]}\\[0pt]
 &  &  & \\[0pt]
\emph{\# Set the \texttt{HIDDEN} bit (\texttt{0x40}) on} &  &  & \\[0pt]
\emph{\# the dictionary entry's flag.} &  &  & \\[0pt]
\texttt{xt@t0 ← [LATEST];} & ld t0, 40(s2) & \uline{\texttt{0x028}}                    \texttt{10010}​\(^{s_{1}}\) \texttt{011} \texttt{00101}​\(^{d}\)  \texttt{0000011} & \texttt{83 32 89 02}\\[0pt]
\texttt{flag@t1 ← [xt@t0 + 16];} & lbu t1, 16(t0) & \uline{\texttt{0x010}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{100} \texttt{00110}​\(^{d}\)  \texttt{0000011} & \texttt{03 C3 02 01}\\[0pt]
\texttt{flag@t1} \(\vert{}\)​\texttt{=} \texttt{0b01000000;}  \emph{\# \texttt{HIDDEN}.} & ori t1, t1, 0x040 & \emph{\texttt{0x040}}                    \texttt{00110}​\(^{s_{1}}\) \texttt{110} \texttt{00110}​\(^{d}\)  \texttt{0010011} & \texttt{13 63 03 04}\\[0pt]
\texttt{[xt@t0 + 16] ← flag@t1;} & sb t1, 16(t0) & \uline{\texttt{0000000}} \texttt{00110}​\(^{s_{2}}\) \texttt{00101}​\(^{s_{1}}\) \texttt{000} \uline{\texttt{10000}} \texttt{0100011} & \texttt{23 88 62 00}\\[0pt]
 &  &  & \\[0pt]
\emph{\# Generate a prologue that pushes} &  &  & \\[0pt]
\emph{\# register \texttt{ra} on the stack:} &  &  & \\[0pt]
\emph{\# 1. Allocate stack space:} &  &  & \\[0pt]
\emph{\# – instruction:} \texttt{addi sp, sp, -8} &  &  & \\[0pt]
\emph{\# – encoded:} \emph{\texttt{0xFF8}} \texttt{00010}​\(^{s_{1}}\) &  &  & \\[0pt]
\emph{\#}\hspace{5.1em} \(\hookrightarrow\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} &  &  & \\[0pt]
\emph{\# 2. Save \texttt{ra} on the stack:} &  &  & \\[0pt]
\emph{\# – instruction:} \texttt{sd ra, 0(sp)} &  &  & \\[0pt]
\emph{\# – enc.:} \uline{\texttt{0000000}} \texttt{00001}​\(^{s_{2}}\) \texttt{00010}​\(^{s_{1}}\) &  &  & \\[0pt]
\emph{\#}\hspace{3.5em} \(\hookrightarrow\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} &  &  & \\[0pt]
\emph{\# Thus we generate code as follows:} &  &  & \\[0pt]
\emph{\#}\hspace{1.053000em}​\texttt{13·01·81·FF} &  &  & \\[0pt]
\emph{\#}\hspace{1.053000em}​\texttt{23·30·11·00} &  &  & \\[0pt]
 &  &  & \\[0pt]
\emph{\# 1. Assemble and write \texttt{addi}.} &  &  & \\[0pt]
\texttt{t0 ← 0xFF810113;} & lui t0, 0xFF810 & \emph{\texttt{0xFF810}}                                                  \texttt{00101}​\(^{d}\)  \texttt{0110111} & \texttt{B7 02 81 FF}\\[0pt]
 & addi t0, t0, 0x113 & \emph{\texttt{0x113}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{000} \texttt{00101}​\(^{d}\)  \texttt{0010011} & \texttt{93 82 32 11}\\[0pt]
\texttt{[OUTPUT@s1] ← t0;} & sw t0, 0(s1) & \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{01001}​\(^{s_{1}}\) \texttt{010} \uline{\texttt{00000}} \texttt{0100011} & \texttt{23 A0 54 00}\\[0pt]
 &  &  & \\[0pt]
\emph{\# 2. Assemble and write \texttt{sd}.} &  &  & \\[0pt]
\texttt{t0 ← 0x00113023;} & lui t0, 0x00113 & \emph{\texttt{0x00113}}                                                  \texttt{00101}​\(^{d}\)  \texttt{0110111} & \texttt{B7 32 11 00}\\[0pt]
 & addi t0, t0, 0x023 & \emph{\texttt{0x023}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{000} \texttt{00101}​\(^{d}\)  \texttt{0010011} & \texttt{93 82 32 02}\\[0pt]
\texttt{[OUTPUT@s1 + 4] ← t0;} & sw t0, 4(s1) & \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{01001}​\(^{s_{1}}\) \texttt{010} \uline{\texttt{00100}} \texttt{0100011} & \texttt{23 A2 54 00}\\[0pt]
\texttt{OUTPUT@s1 += 8;} & addi s1, s1, 8 & \emph{\texttt{0x008}}                    \texttt{01001}​\(^{s_{1}}\) \texttt{000} \texttt{01001}​\(^{d}\)  \texttt{0010011} & \texttt{93 84 84 00}\\[0pt]
 &  &  & \\[0pt]
\emph{\# Switch to compiling state.} &  &  & \\[0pt]
\texttt{call ];}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{5D}​\(_{]}\)​\texttt{]}\\[0pt]
\texttt{pop ra;} & ld ra, 0(sp) & \uline{\texttt{0x000}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{011} \texttt{00001}​\(^{d}\)  \texttt{0000011} & \texttt{83 30 01 00}\\[0pt]
 & addi sp, sp, 8 & \emph{\texttt{0x008}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} & \texttt{13 01 81 00}\\[0pt]
\texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org2160ea2}\texttt{':'} sets up a word's dictionary entry and begins compilation (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

The semicolon routine, listed in Table \ref{tab:orgf5af8c2},
compiles code that performs the reverse operation: an \texttt{ld} instruction
that loads the return address from the stack back into the register
\texttt{ra}, and an \texttt{addi} instruction that releases the unused stack slot.
Finally, it also compiles a return operation as a \texttt{jalr} instruction.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define immediate:} \uline{\texttt{;}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{81} \uline{\texttt{3B}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( C: -​- )} &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
\emph{\#} &  &  & \\[0pt]
\emph{\# Finalize a colon definition and} &  &  & \\[0pt]
\emph{\# switch back to interpreting state.} &  &  & \\[0pt]
\emph{\#} &  &  & \\[0pt]
\emph{\# RISC-V only: similar to the} &  &  & \\[0pt]
\emph{\# prologue in \texttt{`:`}, we need to} &  &  & \\[0pt]
\emph{\# compile an epilogue that pops} &  &  & \\[0pt]
\emph{\# the return address off the stack.} &  &  & \\[0pt]
 &  &  & \\[0pt]
\emph{\# Generate an epilogue as follows:} &  &  & \\[0pt]
\emph{\# 1. Restore return address register:} &  &  & \\[0pt]
\emph{\# – instruction:} \texttt{ld ra, 0(sp)} &  &  & \\[0pt]
\emph{\# – enc.:} \uline{\texttt{0x000}} \texttt{00010}​\(^{s_{1}}\) &  &  & \\[0pt]
\emph{\#}\hspace{3.5em} \(\hookrightarrow\) \texttt{011} \texttt{00001}​\(^{d}\)  \texttt{0000011} &  &  & \\[0pt]
\emph{\# 2. Deallocate stack space:} &  &  & \\[0pt]
\emph{\# – instruction:} \texttt{addi sp, sp, 8} &  &  & \\[0pt]
\emph{\# – enc.:} \emph{\texttt{0x008}} \texttt{00010}​\(^{s_{1}}\) &  &  & \\[0pt]
\emph{\#}\hspace{3.5em} \(\hookrightarrow\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} &  &  & \\[0pt]
\emph{\# 3. Return to calling word:} &  &  & \\[0pt]
\emph{\# – instruction:} \texttt{jalr zero, 0(ra)} &  &  & \\[0pt]
\emph{\# – enc.:} \uline{\texttt{0x000}} \texttt{00001}​\(^{s_{1}}\) &  &  & \\[0pt]
\emph{\#}\hspace{3.5em} \(\hookrightarrow\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} &  &  & \\[0pt]
\emph{\#} &  &  & \\[0pt]
\emph{\# Thus we generate code as follows:} &  &  & \\[0pt]
\emph{\#}\hspace{1.053000em}​\texttt{83·30·01·00} &  &  & \\[0pt]
\emph{\#}\hspace{1.053000em}​\texttt{13·01·81·00} &  &  & \\[0pt]
\emph{\#}\hspace{1.053000em}​\texttt{67·80·00·00} &  &  & \\[0pt]
 &  &  & \\[0pt]
\texttt{push ra;} & addi sp, sp, -8 & \emph{\texttt{0xFF8}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} & \texttt{13 01 81 FF}\\[0pt]
 & sd ra, 0(sp) & \uline{\texttt{0000000}} \texttt{00001}​\(^{s_{2}}\) \texttt{00010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} & \texttt{23 30 11 00}\\[0pt]
\emph{\# 1. Assemble and write \texttt{ld}.} &  &  & \\[0pt]
\texttt{t0 ← 0x00013083;} & lui t0, 0x00013 & \emph{\texttt{0x00013}}                                                  \texttt{00101}​\(^{d}\)  \texttt{0110111} & \texttt{B7 32 01 00}\\[0pt]
 & addi t0, t0, 0x083 & \emph{\texttt{0x083}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{000} \texttt{00101}​\(^{d}\)  \texttt{0010011} & \texttt{93 82 32 08}\\[0pt]
\texttt{[OUTPUT@s1] ← t0;} & sw t0, 0(s1) & \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{01001}​\(^{s_{1}}\) \texttt{010} \uline{\texttt{00000}} \texttt{0100011} & \texttt{23 A0 54 00}\\[0pt]
 &  &  & \\[0pt]
\emph{\# 2. Assemble and write \texttt{addi}.} &  &  & \\[0pt]
\texttt{t0 ← 0x00810113;} & lui t0, 0x00810 & \emph{\texttt{0x00810}}                                                  \texttt{00101}​\(^{d}\)  \texttt{0110111} & \texttt{B7 02 81 00}\\[0pt]
 & addi t0, t0, 0x113 & \emph{\texttt{0x113}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{000} \texttt{00101}​\(^{d}\)  \texttt{0010011} & \texttt{93 82 32 11}\\[0pt]
\texttt{[OUTPUT@s1 + 4] ← t0;} & sw t0, 4(s1) & \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{01001}​\(^{s_{1}}\) \texttt{010} \uline{\texttt{00100}} \texttt{0100011} & \texttt{23 A2 54 00}\\[0pt]
 &  &  & \\[0pt]
\emph{\# 3. Assemble and write \texttt{jalr}.} &  &  & \\[0pt]
\texttt{t0 ← 0x00008067;} & lui t0, 0x00008 & \emph{\texttt{0x00008}}                                                  \texttt{00101}​\(^{d}\)  \texttt{0110111} & \texttt{B7 82 00 00}\\[0pt]
 & addi t0, t0, 0x067 & \emph{\texttt{0x067}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{000} \texttt{00101}​\(^{d}\)  \texttt{0010011} & \texttt{93 82 72 06}\\[0pt]
\texttt{[OUTPUT@s1 + 8] ← t0;} & sw t0, 8(s1) & \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{01001}​\(^{s_{1}}\) \texttt{010} \uline{\texttt{01000}} \texttt{0100011} & \texttt{23 A4 54 00}\\[0pt]
\texttt{OUTPUT@s1 += 12;} & addi s1, s1, 12 & \emph{\texttt{0x00C}}                    \texttt{01001}​\(^{s_{1}}\) \texttt{000} \texttt{01001}​\(^{d}\)  \texttt{0010011} & \texttt{93 84 C4 00}\\[0pt]
 &  &  & \\[0pt]
\emph{\# Clear the \texttt{HIDDEN} bit (\texttt{0x40}) on} &  &  & \\[0pt]
\emph{\# the dictionary entry's flag.} &  &  & \\[0pt]
\texttt{xt@t0 ← [LATEST];} & ld t0, 40(s2) & \uline{\texttt{0x028}}                    \texttt{10010}​\(^{s_{1}}\) \texttt{011} \texttt{00101}​\(^{d}\)  \texttt{0000011} & \texttt{83 32 89 02}\\[0pt]
\texttt{flag@t1 ← [xt@t0 + 16];} & lbu t1, 16(t0) & \uline{\texttt{0x010}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{100} \texttt{00110}​\(^{d}\)  \texttt{0000011} & \texttt{03 C3 02 01}\\[0pt]
\texttt{flag@t1 \&= 0b10111111;} & andi t1, t1, 0xBF & \emph{\texttt{0x0BF}}                    \texttt{00110}​\(^{s_{1}}\) \texttt{111} \texttt{00110}​\(^{d}\)  \texttt{0010011} & \texttt{13 73 F3 0B}\\[0pt]
\texttt{[xt@t0 + 16] ← flag@t1;} & sb t1, 16(t0) & \uline{\texttt{0000000}} \texttt{00110}​\(^{s_{2}}\) \texttt{00101}​\(^{s_{1}}\) \texttt{000} \uline{\texttt{10000}} \texttt{0100011} & \texttt{23 88 62 00}\\[0pt]
 &  &  & \\[0pt]
\emph{\# Switch to interpreting state.} &  &  & \\[0pt]
\texttt{call [;}  \emph{\# Compiled.} & --- & --- & \texttt{[99} \(^{c}\)​\texttt{5B}​\(_{[}\)​\texttt{]}\\[0pt]
\texttt{pop ra;} & ld ra, 0(sp) & \uline{\texttt{0x000}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{011} \texttt{00001}​\(^{d}\)  \texttt{0000011} & \texttt{83 30 01 00}\\[0pt]
 & addi sp, sp, 8 & \emph{\texttt{0x008}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} & \texttt{13 01 81 00}\\[0pt]
\texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgf5af8c2}\texttt{';'} wraps up a colon definition and goes back to interpreting (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define immediate:} \uline{\texttt{[}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{81} \uline{\texttt{5B}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( -​- )} &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
\emph{\#} &  &  & \\[0pt]
\emph{\# Switch to interpreting state.} &  &  & \\[0pt]
 &  &  & \\[0pt]
\emph{\# Set \texttt{STATE} to 0.} &  &  & \\[0pt]
\texttt{[STATE] ← 0;} & sd zero, 32(s2) & \uline{\texttt{0000001}} \texttt{00000}​\(^{s_{2}}\) \texttt{10010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} & \texttt{23 30 09 02}\\[0pt]
\texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org4be6782}Subroutine \texttt{'['} changes Forth's \texttt{STATE} to interpreting (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{]}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{01} \uline{\texttt{5D}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( -​- )} &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
\emph{\#} &  &  & \\[0pt]
\emph{\# Switch to compiling state.} &  &  & \\[0pt]
 &  &  & \\[0pt]
\emph{\# Set \texttt{STATE} to 1.} &  &  & \\[0pt]
\texttt{[STATE] ← 1;} & addi t0, zero, 1 & \emph{\texttt{0x001}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{00101}​\(^{d}\)  \texttt{0010011} & \texttt{93 02 10 00}\\[0pt]
 & sd t0, 32(s2) & \uline{\texttt{0000001}} \texttt{00101}​\(^{s_{2}}\) \texttt{10010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} & \texttt{23 30 59 02}\\[0pt]
\texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgba3694e}Subroutine \texttt{']'} changes Forth's \texttt{STATE} back to compiling (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

The \texttt{'.'} subroutine, shown in Table \ref{tab:org57b46f1}, is equivalent to
its x86-64 version.  There is a significant difference in its later
utilisation, however.  While the x86-64 instruction encoding scheme is
byte-oriented, allowing for any instruction to be easily encoded by
appending whole bytes or sequences of bytes, RISC-V encodes
instructions as concatenated bit ranges of various lengths.
Therefore, using \texttt{'.'} for assembling instructions in the next stage
is not as direct in RISC-V as in x86-64.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{.}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{01} \uline{\texttt{2E}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( u -​- )} &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
\emph{\#} &  &  & \\[0pt]
\emph{\# Non-standard name for \texttt{C,}.} &  &  & \\[0pt]
\emph{\#} &  &  & \\[0pt]
\emph{\# Pop a byte off the stack and} &  &  & \\[0pt]
\emph{\# write it to \texttt{OUTPUT}.} &  &  & \\[0pt]
 &  &  & \\[0pt]
\texttt{byte@t0 ← [STACK@s3]} & lbu t0, 0(s3) & \uline{\texttt{0x000}}                    \texttt{10011}​\(^{s_{1}}\) \texttt{100} \texttt{00101}​\(^{d}\)  \texttt{0000011} & \texttt{83 C2 09 00}\\[0pt]
\texttt{STACK@s3 += 8;} & addi s3, s3, 8 & \emph{\texttt{0x008}}                    \texttt{10011}​\(^{s_{1}}\) \texttt{000} \texttt{10011}​\(^{d}\)  \texttt{0010011} & \texttt{93 89 89 00}\\[0pt]
\texttt{[OUTPUT@s1++] ← byte@t0;} & sb t0, 0(s1) & \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{01001}​\(^{s_{1}}\) \texttt{000} \uline{\texttt{00000}} \texttt{0100011} & \texttt{23 80 54 00}\\[0pt]
 & addi s1, s1, 1 & \emph{\texttt{0x001}}                    \texttt{01001}​\(^{s_{1}}\) \texttt{000} \texttt{01001}​\(^{d}\)  \texttt{0010011} & \texttt{93 84 14 00}\\[0pt]
\texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org57b46f1}Subroutine \texttt{'.'} compiles a byte from the stack to \texttt{OUTPUT} (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

The RISC-V translation of \texttt{LIT}, listed in Table \ref{tab:org225a692}, is
mostly equivalent to the original.  It is slightly more complicated to
load an immediate byte in a register, for the same reason given in our
comments on \texttt{'.'}: it requires bit twiddling as opposed to simply
embedding the byte in the flow of instructions as in x86-64.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define immediate:} \uline{\texttt{LIT}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{83} \uline{\texttt{4C 49 54}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( C: x -​- ) ( -{}-{} x )} &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
\emph{\#} &  &  & \\[0pt]
\emph{\# Pop a byte off the data stack at compile time.} &  &  & \\[0pt]
\emph{\# Compile it as the immediate part of a push} &  &  & \\[0pt]
\emph{\# sequence that inserts it on the data stack} &  &  & \\[0pt]
\emph{\# when the word being defined is executed.} &  &  & \\[0pt]
 &  &  & \\[0pt]
\emph{\# Let \texttt{lit} be the top byte on the data stack.} &  &  & \\[0pt]
\emph{\# We will generate three instructions that will} &  &  & \\[0pt]
\emph{\# effectively push \texttt{lit} on the data stack at} &  &  & \\[0pt]
\emph{\# execution time:} &  &  & \\[0pt]
\emph{\# – an \texttt{addi} instruction that loads \texttt{lit} into} &  &  & \\[0pt]
\emph{\# register \texttt{t0} as an immediate value;} &  &  & \\[0pt]
\emph{\# – a pair of `addi` \& `sd` instructions that} &  &  & \\[0pt]
\emph{\# push register \texttt{t0} on the data stack.} &  &  & \\[0pt]
 &  &  & \\[0pt]
\emph{\# 1. Load \texttt{lit} in register \texttt{t0}:} &  &  & \\[0pt]
\emph{\# – effect:} \texttt{t0 ← 0x0XY;}  \emph{\# \texttt{XY} stands for \texttt{lit}.} &  &  & \\[0pt]
\emph{\# – instruction:} \texttt{addi t0, zero, 0x0XY} &  &  & \\[0pt]
\emph{\# – encoded:} \emph{\texttt{0x0XY}} \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{00101}​\(^{d}\) \texttt{0010011} &  &  & \\[0pt]
\emph{\# – bits:} \texttt{0000xxxx·yyyy0000·00000010·10010011} &  &  & \\[0pt]
\texttt{lit@t0 ← [STACK@s3];} & lbu t0, 0(s3) & \uline{\texttt{0x000}}                    \texttt{10011}​\(^{s_{1}}\) \texttt{100} \texttt{00101}​\(^{d}\)  \texttt{0000011} & \texttt{83 C2 09 00}\\[0pt]
\texttt{STACK@s3 += 8;} & addi s3, s3, 8 & \emph{\texttt{0x008}}                    \texttt{10011}​\(^{s_{1}}\) \texttt{000} \texttt{10011}​\(^{d}\)  \texttt{0010011} & \texttt{93 89 89 00}\\[0pt]
\texttt{t0 <{}<{}= 20;} & slli t0, t0, 20 & \texttt{000000}​\emph{\texttt{010100}}​\(^{sh}\)         \texttt{00101}​\(^{s_{1}}\) \texttt{001} \texttt{00101}​\(^{d}\)  \texttt{0010011} & \texttt{93 92 42 01}\\[0pt]
\texttt{t0} \(\vert{}\)​\texttt{= 0x293;} & ori t0, t0, 0x293 & \emph{\texttt{0x293}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{110} \texttt{00101}​\(^{d}\)  \texttt{0010011} & \texttt{93 E2 32 29}\\[0pt]
\texttt{[OUTPUT@s1] ← t0;} & sw t0, 0(s1) & \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{01001}​\(^{s_{1}}\) \texttt{010} \uline{\texttt{00000}} \texttt{0100011} & \texttt{23 A0 54 00}\\[0pt]
 &  &  & \\[0pt]
\emph{\# 2. Allocate stack space:} &  &  & \\[0pt]
\emph{\# – effect:} \texttt{STACK@s3 -= 8;} &  &  & \\[0pt]
\emph{\# – instruction:} \texttt{addi s3, s3, -8} &  &  & \\[0pt]
\emph{\# – encoded:} \emph{\texttt{0xFF8}} \texttt{10011}​\(^{s_{1}}\) \texttt{000} \texttt{10011}​\(^{d}\) \texttt{0010011} &  &  & \\[0pt]
\texttt{t0 ← 0xFF898993;} & lui t0, 0xFF899 & \emph{\texttt{0xFF899}}                                                  \texttt{00101}​\(^{d}\)  \texttt{0110111} & \texttt{B7 92 89 FF}\\[0pt]
 & addi t0, t0, 0x993 & \emph{\texttt{0x993}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{000} \texttt{00101}​\(^{d}\)  \texttt{0010011} & \texttt{93 82 32 99}\\[0pt]
\texttt{[OUTPUT@s1 + 4] ← t0;} & sw t0, 4(s1) & \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{01001}​\(^{s_{1}}\) \texttt{010} \uline{\texttt{00100}} \texttt{0100011} & \texttt{23 A2 54 00}\\[0pt]
 &  &  & \\[0pt]
\emph{\# 3. Write register \texttt{t0} to stack:} &  &  & \\[0pt]
\emph{\# – effect:} \texttt{[STACK@s3] ← t0;} &  &  & \\[0pt]
\emph{\# – instruction:} \texttt{sd t0, 0(s3)} &  &  & \\[0pt]
\emph{\# – encoded:} \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{10011}​\(^{s_{1}}\) &  &  & \\[0pt]
\emph{\#} \hspace{4.7em} \(\hookrightarrow\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} &  &  & \\[0pt]
\texttt{t0 ← 0x0059B023;} & lui t0, 0x0059B & \emph{\texttt{0x0059B}}                                                  \texttt{00101}​\(^{d}\)  \texttt{0110111} & \texttt{B7 B2 59 00}\\[0pt]
 & addi t0, t0, 0x023 & \emph{\texttt{0x023}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{000} \texttt{00101}​\(^{d}\)  \texttt{0010011} & \texttt{93 82 32 02}\\[0pt]
\texttt{[OUTPUT@s1 + 8] ← t0;} & sw t0, 8(s1) & \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{01001}​\(^{s_{1}}\) \texttt{010} \uline{\texttt{01000}} \texttt{0100011} & \texttt{23 A4 54 00}\\[0pt]
\texttt{OUTPUT@s1 += 12;} & addi s1, s1, 12 & \emph{\texttt{0x00C}}                    \texttt{01001}​\(^{s_{1}}\) \texttt{000} \texttt{01001}​\(^{d}\)  \texttt{0010011} & \texttt{93 84 C4 00}\\[0pt]
\texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org225a692}Subroutine \texttt{LIT} compiles a literal byte into a word definition (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\subsubsection{Searching the Dictionary: \texttt{xt=}, \texttt{FIND} (RISC-V)}
\label{sec:orgc547ab8}

The subroutine used to test dictionary entries for a matching name,
\texttt{xt=}, is given in Table \ref{tab:orgc192d41}.  In contrast to its x86-64
variant, it does not use the \texttt{FLAGS} register for information passing.
Additionally, it needs to implement an explicit loop where SmithForth
simply used the \texttt{REPE CMPS} repeated comparison instruction sequence.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{\&} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{xt=}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{03} \uline{\texttt{78 74 3D}}​\texttt{]}\\[0pt]
\emph{\# In/Out:}    \texttt{( addr@a0 u@a1 xt@a2} &  &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
\emph{\#}\hspace{3.35em} \texttt{-{}-{} equal@a0     xt@a2)} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Returns with \texttt{equal} set if \texttt{xt} is} &  &  &  & \\[0pt]
\emph{\# either zero or is not hidden and its} &  &  &  & \\[0pt]
\emph{\# name matches the string given by} &  &  &  & \\[0pt]
\emph{\# address \texttt{addr} and length \texttt{u}.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# "Equal" if \texttt{xt} zero.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if xt@a2 = 0:} &  &  &  & \\[0pt]
\hspace{2.106000em}   \texttt{goto \_equal.} & beq a2, zero, 0x44 & \uline{\texttt{0000010}} \texttt{01100}​\(^{s_{2}}\) \texttt{00000}​\(^{s_{1}}\) \texttt{000} \uline{\texttt{00100}} \texttt{1100011} & \(\overline{\texttt{00}}\) & \texttt{63 02 C0 04}\\[0pt]
\hspace{1.053000em} \emph{\# Not equal if hidden word.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{flag@t0 ← [xt@a2 + 16];} & lbu t0, 16(a2) & \uline{\texttt{0x010}}                    \texttt{01100}​\(^{s_{1}}\) \texttt{100} \texttt{00101}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 42 06 01}\\[0pt]
\hspace{1.053000em} \texttt{if flag@t0 \& 0x40 != 0:} & andi t1, t0, 0x40 & \emph{\texttt{0x040}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{111} \texttt{00110}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 F3 02 04}\\[0pt]
\hspace{2.106000em}   \texttt{goto \_not\_equal.} & bne t1, zero, 0x30 & \uline{\texttt{0000001}} \texttt{00110}​\(^{s_{2}}\) \texttt{00000}​\(^{s_{1}}\) \texttt{001} \uline{\texttt{10000}} \texttt{1100011} & \texttt{0C} & \texttt{63 18 60 02}\\[0pt]
\hspace{1.053000em} \emph{\# Not equal if lengths don't match.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{length@t0 ← flag@t0 \& 0x1F;} & andi t0, t0, 0x1F & \emph{\texttt{0x01F}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{111} \texttt{00101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 F2 F2 01}\\[0pt]
\hspace{1.053000em} \texttt{if length@t0 != u@a1:} &  &  &  & \\[0pt]
\hspace{2.106000em}   \texttt{goto \_not\_equal.} & bne t0, a1, 0x28 & \uline{\texttt{0000001}} \texttt{00101}​\(^{s_{2}}\) \texttt{01011}​\(^{s_{1}}\) \texttt{001} \uline{\texttt{01000}} \texttt{1100011} & \texttt{14} & \texttt{63 94 55 02}\\[0pt]
\hspace{1.053000em} \emph{\# Compare word name (\texttt{xt@a0+17})} &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# and \texttt{addr@a1} upto length \texttt{u@a2}.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{addr'@t0 ← xt@a2 + 17;} & addi t0, a2, 17 & \emph{\texttt{0x011}}                    \texttt{01100}​\(^{s_{1}}\) \texttt{000} \texttt{00101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 02 16 01}\\[0pt]
\texttt{\_begin:} &  &  & \texttt{1C} & \\[0pt]
\hspace{1.053000em} \emph{\# No more characters?} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if u@a1 = 0;} &  &  &  & \\[0pt]
\hspace{2.106000em}   \texttt{goto \_equal.} & beq a1, zero, 0x28 & \uline{\texttt{0000001}} \texttt{01011}​\(^{s_{2}}\) \texttt{00000}​\(^{s_{1}}\) \texttt{000} \uline{\texttt{01000}} \texttt{1100011} & \texttt{1C} & \texttt{63 04 B0 02}\\[0pt]
\hspace{1.053000em} \emph{\# First characters different?} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{chr@t1 ← [addr@a0];} & lbu t1, 0(a0) & \uline{\texttt{0x000}}                    \texttt{01010}​\(^{s_{1}}\) \texttt{100} \texttt{00110}​\(^{d}\)  \texttt{0000011} &  & \texttt{03 43 05 00}\\[0pt]
\hspace{1.053000em} \texttt{chr'@t2 ← [addr'@t0];} & lbu t2, 0(t0) & \uline{\texttt{0x000}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{100} \texttt{00111}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 C3 02 00}\\[0pt]
\hspace{1.053000em} \texttt{if chr@t1 != chr'@t2:} &  &  &  & \\[0pt]
\hspace{2.106000em}   \texttt{goto \_not\_equal.} & bne t1, t2, 0x14 & \uline{\texttt{0000000}} \texttt{00110}​\(^{s_{2}}\) \texttt{00111}​\(^{s_{1}}\) \texttt{001} \uline{\texttt{10100}} \texttt{1100011} & \texttt{28} & \texttt{63 9A 63 00}\\[0pt]
\hspace{1.053000em} \emph{\# Proceed to next characters.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{addr@a0++;} & addi a0, a0, 1 & \emph{\texttt{0x001}}                    \texttt{01010}​\(^{s_{1}}\) \texttt{000} \texttt{01010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 05 15 00}\\[0pt]
\hspace{1.053000em} \texttt{addr'@t0++;} & addi t0, t0, 1 & \emph{\texttt{0x001}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{000} \texttt{00101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 82 12 00}\\[0pt]
\hspace{1.053000em} \texttt{u@a1-{}-{};} & addi a1, a1, -1 & \emph{\texttt{0xFFF}}                    \texttt{01011}​\(^{s_{1}}\) \texttt{000} \texttt{01011}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 85 F5 FF}\\[0pt]
\hspace{1.053000em} \texttt{goto \_begin.} & jal zero, -0x1C & \uline{\texttt{11111110010111111111}}                                     \texttt{00000}​\(^{d}\)  \texttt{1101111} & \texttt{38} & \texttt{6F F0 5F FE}\\[0pt]
\texttt{\_not\_equal:} &  &  & \texttt{3C} & \\[0pt]
\hspace{1.053000em} \texttt{equal@a0 ← 0;} & addi a0, zero, 0 & \emph{\texttt{0x000}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{01010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 05 00 00}\\[0pt]
\hspace{1.053000em} \texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} &  & \texttt{67 80 00 00}\\[0pt]
\texttt{\_equal:} &  &  & \texttt{44} & \\[0pt]
\hspace{1.053000em} \texttt{equal@a0 ← 1;} & addi a0, zero, 1 & \emph{\texttt{0x001}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{01010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 05 10 00}\\[0pt]
\hspace{1.053000em} \texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} &  & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgc192d41}\texttt{xt=} compares an execution token's name with a given string (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\texttt{FIND}, shown in Table \ref{tab:orgcfc00f0}, is an almost direct
translation of SmithForth's \texttt{FIND}.  The only significant change is
the same as done for \texttt{xt=}, that is, explicitly receiving return
information instead of using the \texttt{FLAGS} register.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{\&} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{FIND}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{46 49 4E 44}}​\texttt{]}\\[0pt]
\emph{\# In/Out:}    \texttt{( addr@a0 u@a1} &  &  &  & \\[0pt]
\emph{\#}\hspace{3.35em} \texttt{-{}-{} addr@a0 u@a1} &  &  &  & \\[0pt]
\emph{\#}\hspace{4.9em}      \texttt{xt@a2 )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Search the dictionary for a} &  &  &  & \\[0pt]
\emph{\# word with name matching} &  &  &  & \\[0pt]
\emph{\# \texttt{addr}​/​\texttt{u}. Return \texttt{xt = 0} if} &  &  &  & \\[0pt]
\emph{\# no matching word is found.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{push ra;} & addi sp, sp, -24 & \emph{\texttt{0xFE8}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 01 81 FE}\\[0pt]
\hspace{1.053000em} & sd ra, 16(sp) & \uline{\texttt{0000000}} \texttt{00001}​\(^{s_{2}}\) \texttt{00010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{10000}} \texttt{0100011} &  & \texttt{23 38 11 00}\\[0pt]
\hspace{1.053000em} \emph{\# Begin search at \texttt{LATEST}.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{xt@a2 ← [LATEST];} & ld a2, 40(s2) & \uline{\texttt{0x028}}                    \texttt{10010}​\(^{s_{1}}\) \texttt{011} \texttt{01100}​\(^{d}\)  \texttt{0000011} &  & \texttt{03 36 89 02}\\[0pt]
\texttt{\_begin:} &  &  & \(\overline{\texttt{00}}\) & \\[0pt]
\hspace{1.053000em} \emph{\# Save registers that are} &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# not preserved by \texttt{xt=}.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{push addr@a0;} & sd a0, 8(sp) & \uline{\texttt{0000000}} \texttt{01010}​\(^{s_{2}}\) \texttt{00010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{01000}} \texttt{0100011} &  & \texttt{23 34 A1 00}\\[0pt]
\hspace{1.053000em} \texttt{push u@a1;} & sd a1, 0(sp) & \uline{\texttt{0000000}} \texttt{01011}​\(^{s_{2}}\) \texttt{00010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} &  & \texttt{23 30 B1 00}\\[0pt]
\hspace{1.053000em} \emph{\# Does \texttt{xt} match \texttt{addr}​/​\texttt{u}?} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{call xt=;}  \emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{78}​\(_{x}\)​\texttt{]}\\[0pt]
\hspace{1.053000em} \texttt{equal@t0 ← equal@a0;} & addi t0, a0, 0 & \emph{\texttt{0x000}}                    \texttt{01010}​\(^{s_{1}}\) \texttt{000} \texttt{00101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 02 05 00}\\[0pt]
\hspace{1.053000em} \texttt{pop u@a1;} & ld a1, 0(sp) & \uline{\texttt{0x000}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{011} \texttt{01011}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 35 01 00}\\[0pt]
\hspace{1.053000em} \texttt{pop addr@a0;} & ld a0, 8(sp) & \uline{\texttt{0x008}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{011} \texttt{01010}​\(^{d}\)  \texttt{0000011} &  & \texttt{03 35 81 00}\\[0pt]
\hspace{1.053000em} \emph{\# If matched, we're done!} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if equal@t0:} &  &  &  & \\[0pt]
\hspace{2.106000em}   \texttt{goto \_end.} & bne t0, zero, 0x0C & \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{00000}​\(^{s_{1}}\) \texttt{001} \uline{\texttt{01100}} \texttt{1100011} & \texttt{1C} & \texttt{63 16 50 00}\\[0pt]
\hspace{1.053000em} \emph{\# Otherwise, follow \texttt{xt}'s} &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# link pointer and repeat.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{xt@a2 ← [xt@a2 + 8];} & ld a2, 8(a2) & \uline{\texttt{0x008}}                    \texttt{01100}​\(^{s_{1}}\) \texttt{011} \texttt{01100}​\(^{d}\)  \texttt{0000011} &  & \texttt{03 36 86 00}\\[0pt]
\hspace{1.053000em} \texttt{goto \_begin.} & jal zero, -0x24 & \uline{\texttt{11111101110111111111}}                                     \texttt{00000}​\(^{d}\)  \texttt{1101111} & \texttt{24} & \texttt{6F F0 DF FD}\\[0pt]
\texttt{\_end:} &  &  & \texttt{28} & \\[0pt]
\hspace{1.053000em} \texttt{pop ra;} & ld ra, 16(sp) & \uline{\texttt{0x010}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{011} \texttt{00001}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 30 01 01}\\[0pt]
\hspace{1.053000em} & addi sp, sp, 24 & \emph{\texttt{0x018}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 01 81 01}\\[0pt]
\hspace{1.053000em} \texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} &  & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgcfc00f0}\texttt{FIND} searches the dictionary for a word matching a given name (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\subsubsection{Handling Numbers: \texttt{Num}, \texttt{miss} (RISC-V)}
\label{sec:org55b1483}

The porting of words \texttt{Num} and \texttt{miss}, shown in Tables
\ref{tab:org8fa2daa} and \ref{tab:orgd3987af}, was straightforward, almost
line-by-line.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{\&} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{Num}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{03} \uline{\texttt{4E 75 6D}}​\texttt{]}\\[0pt]
\emph{\# In/Out:}    \texttt{( addr@a0 u@a1} &  &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
\emph{\#}\hspace{3.35em} \texttt{-​- n )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Parse string given by \texttt{addr}​/​\texttt{u}} &  &  &  & \\[0pt]
\emph{\# as a number and push it on} &  &  &  & \\[0pt]
\emph{\# the data stack.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{num@t0 ← 0;} & addi t0, zero, 0 & \emph{\texttt{0x000}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{00101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 02 00 00}\\[0pt]
\texttt{\_begin:} &  &  & \(\overline{\texttt{00}}\) & \\[0pt]
\hspace{1.053000em} \emph{\# Parse one character.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{chr@t1 ← [addr@a0++];} & lbu t1, 0(a0) & \uline{\texttt{0x000}}                    \texttt{01010}​\(^{s_{1}}\) \texttt{100} \texttt{00110}​\(^{d}\)  \texttt{0000011} &  & \texttt{03 43 05 00}\\[0pt]
\hspace{1.053000em} & addi a0, a0, 1 & \emph{\texttt{0x001}}                    \texttt{01010}​\(^{s_{1}}\) \texttt{000} \texttt{01010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 05 15 00}\\[0pt]
\hspace{1.053000em} \emph{\# Is it a \texttt{[0-9]} digit?} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if chr@t1 < 'A':} & addi t2, zero, 65 & \emph{\texttt{0x041}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{00111}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 03 10 04}\\[0pt]
\hspace{2.106000em}   \texttt{goto \_digit.} & bltu t1, t2, 0x08 & \uline{\texttt{0000000}} \texttt{00111}​\(^{s_{2}}\) \texttt{00110}​\(^{s_{1}}\) \texttt{110} \uline{\texttt{01000}} \texttt{1100011} & \texttt{0C} & \texttt{63 64 73 00}\\[0pt]
\hspace{1.053000em} \emph{\# It's an \texttt{[A-F]} digit.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{chr@t1 -= 7;} & addi t1, t1, -7 & \emph{\texttt{0xFF9}}                    \texttt{00110}​\(^{s_{1}}\) \texttt{000} \texttt{00110}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 03 93 FF}\\[0pt]
\texttt{\_digit:} &  &  & \texttt{14} & \\[0pt]
\hspace{1.053000em} \texttt{digit@t1 = chr@t1 - '0';} & addi t1, t1, -48 & \emph{\texttt{0xFD0}}                    \texttt{00110}​\(^{s_{1}}\) \texttt{000} \texttt{00110}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 03 03 FD}\\[0pt]
\hspace{1.053000em} \emph{\# Multiply by base and add} &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# the new digit.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{num@t0 <{}<{}= 4}; & slli t0, t0, 4 & \texttt{000000}​\emph{\texttt{000100}}​\(^{sh}\)         \texttt{00101}​\(^{s_{1}}\) \texttt{001} \texttt{00101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 92 42 00}\\[0pt]
\hspace{1.053000em} \texttt{num@t0} \(\vert{}\)​\texttt{= digit@t1;} & or t0, t0, t1 & \texttt{0000000} \texttt{00110}​\(^{s_{2}}\) \texttt{00101}​\(^{s_{1}}\) \texttt{110} \texttt{00101}​\(^{d}\)  \texttt{0110011} &  & \texttt{B3 E2 62 00}\\[0pt]
\hspace{1.053000em} \emph{\# Repeat while there are} &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# unparsed characters left.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if -{}-{}u@a1 != 0:} & addi a1, a1, -1 & \emph{\texttt{0xFFF}}                    \texttt{01011}​\(^{s_{1}}\) \texttt{000} \texttt{01011}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 85 F5 FF}\\[0pt]
\hspace{2.106000em}   \texttt{goto \_begin.} & bne a1, zero, -0x24 & \uline{\texttt{1111110}} \texttt{01011}​\(^{s_{2}}\) \texttt{00000}​\(^{s_{1}}\) \texttt{001} \uline{\texttt{11101}} \texttt{1100011} & \texttt{24} & \texttt{E3 1E B0 FC}\\[0pt]
\hspace{1.053000em} \emph{\# Push the parsed number} &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# on the data stack.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{STACK@s3 -= 8;} & addi s3, s3, -8 & \emph{\texttt{0xFF8}}                    \texttt{10011}​\(^{s_{1}}\) \texttt{000} \texttt{10011}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 89 89 FF}\\[0pt]
\hspace{1.053000em} \texttt{[STACK@s3] ← num@t0;} & sd t0, 0(s3) & \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{10011}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} &  & \texttt{23 B0 59 00}\\[0pt]
\hspace{1.053000em} \texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} &  & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org8fa2daa}\texttt{Num} parses a character string as a number and pushes it on the stack (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{\&} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{miss}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{6D 69 73 73}}​\texttt{]}\\[0pt]
\emph{\# In/Out:}     \texttt{( addr@a0 u@a1} &  &  &  & \\[0pt]
\emph{\#}\hspace{4.9em}       \texttt{xt@a2} &  &  &  & \\[0pt]
\emph{\#}\hspace{3.35em} \texttt{-​- [num] xt@a0 )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# If \texttt{xt} is zero, try parsing} &  &  &  & \\[0pt]
\emph{\# the string given by \texttt{addr}​/​\texttt{u}} &  &  &  & \\[0pt]
\emph{\# as a number. If successful} &  &  &  & \\[0pt]
\emph{\# and if we're in compiling} &  &  &  & \\[0pt]
\emph{\# state, compile the number} &  &  &  & \\[0pt]
\emph{\# as a literal.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{push ra;} & addi sp, sp, -8 & \emph{\texttt{0xFF8}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 01 81 FF}\\[0pt]
\hspace{1.053000em} & sd ra, 0(sp) & \uline{\texttt{0000000}} \texttt{00001}​\(^{s_{2}}\) \texttt{00010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} &  & \texttt{23 30 11 00}\\[0pt]
\hspace{1.053000em} \texttt{if xt@a2 != 0:} &  &  &  & \\[0pt]
\hspace{2.106000em}   \texttt{goto \_end.} & bne a2, zero, 0x20 & \uline{\texttt{0000001}} \texttt{01100}​\(^{s_{2}}\) \texttt{00000}​\(^{s_{1}}\) \texttt{001} \uline{\texttt{00000}} \texttt{1100011} & \(\overline{\texttt{00}}\) & \texttt{63 10 C0 02}\\[0pt]
\hspace{1.053000em} \emph{\# We shouldn't call \texttt{Num}} &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# with an empty string.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if u@a1 = 0:} &  &  &  & \\[0pt]
\hspace{2.106000em}   \texttt{goto \_end.} & beq a1, zero, 0x1C & \uline{\texttt{0000000}} \texttt{01011}​\(^{s_{2}}\) \texttt{00000}​\(^{s_{1}}\) \texttt{000} \uline{\texttt{11100}} \texttt{1100011} & \texttt{04} & \texttt{63 0E B0 00}\\[0pt]
\hspace{1.053000em} \texttt{call Num;}  \emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{4E}​\(_{N}\)​\texttt{]}\\[0pt]
\hspace{1.053000em} \emph{\# Are we compiling?} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if [STATE] == 0:} & ld t0, 32(s2) & \uline{\texttt{0x020}}                    \texttt{10010}​\(^{s_{1}}\) \texttt{011} \texttt{00101}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 32 09 02}\\[0pt]
\hspace{2.106000em}   \texttt{goto \_end.} & beq t0, zero, 0x0C & \uline{\texttt{0000000}} \texttt{00101}​\(^{s_{2}}\) \texttt{00000}​\(^{s_{1}}\) \texttt{000} \uline{\texttt{01100}} \texttt{1100011} & \texttt{14} & \texttt{63 06 50 00}\\[0pt]
\hspace{1.053000em} \emph{\# Compile top of stack} &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# number as literal.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{call LIT;}  \emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{4C}​\(_{L}\)​\texttt{]}\\[0pt]
\texttt{\_end:} &  &  & \texttt{20} & \\[0pt]
\hspace{1.053000em} \texttt{xt@a0 ← xt@a2;} & addi a0, a2, 0 & \emph{\texttt{0x000}}                    \texttt{01100}​\(^{s_{1}}\) \texttt{000} \texttt{01010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 05 06 00}\\[0pt]
\hspace{1.053000em} \texttt{pop ra;} & ld ra, 0(sp) & \uline{\texttt{0x000}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{011} \texttt{00001}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 30 01 00}\\[0pt]
\hspace{1.053000em} & addi sp, sp, 8 & \emph{\texttt{0x008}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 01 81 00}\\[0pt]
\hspace{1.053000em} \texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} &  & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgd3987af}\texttt{miss} treats a token as a number, possible compiling it as a literal (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}
\pagebreak

\subsubsection{Compile or Execute: \texttt{EXEC}, \texttt{exec}, \texttt{compl}, \texttt{hit} (RISC-V)}
\label{sec:orge39408c}

The RISC-V \texttt{EXEC}, listed in Table \ref{tab:org625d637}, is likely the
only translation significantly shorter than the original.  As
explained before, we believe this could have been implemented in a
more direct manner in x86-64 as well.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{EXEC}} & --- & --- & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{45 58 45 43}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( xt@a0 -{}-{} )} &  &  & \\[0pt]
\emph{\#} &  &  & \\[0pt]
\emph{\# Execute word given by \texttt{xt}.} &  &  & \\[0pt]
 &  &  & \\[0pt]
\emph{\# Retrieve code address.} &  &  & \\[0pt]
\texttt{code@t0 ← [xt@a0];} & ld t0, 0(a0) & \uline{\texttt{0x000}}                    \texttt{01010}​\(^{s_{1}}\) \texttt{011} \texttt{00101}​\(^{d}\)  \texttt{0000011} & \texttt{83 32 05 00}\\[0pt]
 &  &  & \\[0pt]
\emph{\# Call that code, making} &  &  & \\[0pt]
\emph{\# sure the return address} &  &  & \\[0pt]
\emph{\# is saved and restored.} &  &  & \\[0pt]
\texttt{push ra;} & addi sp, sp, -8 & \emph{\texttt{0xFF8}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} & \texttt{13 01 81 FF}\\[0pt]
 & sd ra, 0(sp) & \uline{\texttt{0000000}} \texttt{00001}​\(^{s_{2}}\) \texttt{00010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} & \texttt{23 30 11 00}\\[0pt]
\texttt{call [code@t0];} & jalr ra, 0(t0) & \uline{\texttt{0x000}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{000} \texttt{00001}​\(^{d}\)  \texttt{1100111} & \texttt{E7 80 02 00}\\[0pt]
\texttt{pop ra;} & ld ra, 0(sp) & \uline{\texttt{0x000}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{011} \texttt{00001}​\(^{d}\)  \texttt{0000011} & \texttt{83 30 01 00}\\[0pt]
 & addi sp, sp, 8 & \emph{\texttt{0x008}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} & \texttt{13 01 81 00}\\[0pt]
\texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org625d637}Subroutine \texttt{EXEC} executes a Forth word (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{\&} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{exec}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{65 78 65 63}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( xt@a0} &  &  &  & \\[0pt]
\emph{\#}\hspace{4.9em}   \texttt{imm+state@a1 -{}-{} )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Execute \texttt{xt} if we're in interpreting} &  &  &  & \\[0pt]
\emph{\# mode or if it's an immediate word.} &  &  &  & \\[0pt]
\emph{\# In other words, don't execute if we} &  &  &  & \\[0pt]
\emph{\# are compiling and the word is not} &  &  &  & \\[0pt]
\emph{\# immediate (if \texttt{imm+state} is \texttt{1}).} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if imm+state@a1 = 1:} & addi t0, zero, 1 & \emph{\texttt{0x001}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{00101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 02 10 00}\\[0pt]
\hspace{2.106000em}   \texttt{goto \_end.} & beq a1, t0, 0x1C & \uline{\texttt{0000000}} \texttt{01011}​\(^{s_{2}}\) \texttt{00101}​\(^{s_{1}}\) \texttt{000} \uline{\texttt{11100}} \texttt{1100011} & \(\overline{\texttt{00}}\) & \texttt{63 8E B2 00}\\[0pt]
\hspace{1.053000em} \emph{\# Execute word using \texttt{EXEC}.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{push ra;} & addi sp, sp, -8 & \emph{\texttt{0xFF8}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 01 81 FF}\\[0pt]
 & sd ra, 0(sp) & \uline{\texttt{0000000}} \texttt{00001}​\(^{s_{2}}\) \texttt{00010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} &  & \texttt{23 30 11 00}\\[0pt]
\hspace{1.053000em} \texttt{call EXEC;}  \emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{45}​\(_{E}\)​\texttt{]}\\[0pt]
\hspace{1.053000em} \texttt{pop ra;} & ld ra, 0(sp) & \uline{\texttt{0x000}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{011} \texttt{00001}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 30 01 00}\\[0pt]
\hspace{1.053000em} & addi sp, sp, 8 & \emph{\texttt{0x008}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 01 81 00}\\[0pt]
\texttt{\_end:} &  &  & \texttt{1C} & \\[0pt]
\hspace{1.053000em} \texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} &  & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orgb7d268b}\texttt{exec} executes a word if if it's immediate or if we're interpreting (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{\&} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{compl}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{05} \uline{\texttt{63 6F 6D 70 6C}}​\texttt{]}\\[0pt]
\emph{\# In/Out:}    \texttt{( xt@a0 imm+state@a1} &  &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
\emph{\#}\hspace{3.35em} \texttt{-{}-{} xt@a0 imm+state@a1 )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Compile \texttt{xt} in the current definition} &  &  &  & \\[0pt]
\emph{\# if we're in compiling state and \texttt{xt} is} &  &  &  & \\[0pt]
\emph{\# not immediate (if \texttt{imm+state} is \texttt{1}).} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if imm+state@a1 != 1:} & addi t0, zero, 1 & \emph{\texttt{0x001}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{00101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 02 10 00}\\[0pt]
\hspace{2.106000em}   \texttt{goto \_end.} & bne a1, t0, 0x20 & \uline{\texttt{0000001}} \texttt{01011}​\(^{s_{2}}\) \texttt{00101}​\(^{s_{1}}\) \texttt{001} \uline{\texttt{00000}} \texttt{1100011} & \(\overline{\texttt{00}}\) & \texttt{63 90 B2 02}\\[0pt]
\hspace{1.053000em} \emph{\# Compile word using \texttt{COMPL}.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{push ra;} & addi sp, sp, -8 & \emph{\texttt{0xFF8}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 01 81 FF}\\[0pt]
\hspace{1.053000em} & sd ra, 0(sp) & \uline{\texttt{0000000}} \texttt{00001}​\(^{s_{2}}\) \texttt{00010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} &  & \texttt{23 30 11 00}\\[0pt]
\hspace{1.053000em} \texttt{call COMPL;}  \emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{43}​\(_{}\)​\texttt{]}\\[0pt]
\hspace{1.053000em} \texttt{pop ra;} & ld ra, 0(sp) & \uline{\texttt{0x000}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{011} \texttt{00001}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 30 01 00}\\[0pt]
\hspace{1.053000em} & addi sp, sp, 8 & \emph{\texttt{0x008}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 01 81 00}\\[0pt]
\hspace{1.053000em} \emph{\# Restore \texttt{a1} after \texttt{COMPL}.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{imm+state@a1 ← 1;} & addi a1, zero, 1 & \emph{\texttt{0x001}}                    \texttt{00000}​\(^{s_{1}}\) \texttt{000} \texttt{01011}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 05 10 00}\\[0pt]
\texttt{\_end:} &  &  & \texttt{20} & \\[0pt]
\hspace{1.053000em} \texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} &  & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org399c9f0}\texttt{compl} compiles a word in compiling state if it's not immediate (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Opcode} & \textbf{\&} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{hit}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{03} \uline{\texttt{68 69 74}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( xt@a0 -{}-{} )} &  &  &  & \texttt{[00}​\(^{pad}\)​\texttt{]}\\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Either compile or execute a} &  &  &  & \\[0pt]
\emph{\# word that has been found in} &  &  &  & \\[0pt]
\emph{\# the dictionary, depending on} &  &  &  & \\[0pt]
\emph{\# current state and whether it's} &  &  &  & \\[0pt]
\emph{\# an immediate word.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{if xt@a0 = 0:} &  &  &  & \\[0pt]
\hspace{2.106000em}   \texttt{goto \_end.} & beq a0, zero, 0x34 & \uline{\texttt{0000001}} \texttt{00000}​\(^{s_{2}}\) \texttt{01010}​\(^{s_{1}}\) \texttt{000} \uline{\texttt{10100}} \texttt{1100011} & \(\overline{\texttt{00}}\) & \texttt{63 0A 05 02}\\[0pt]
\hspace{1.053000em} \emph{\# Combine word's immediate} &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# flag with current state.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{flag@t0 ← [xt@a0 + 16];} & lbu t0, 16(a0) & \uline{\texttt{0x010}}                    \texttt{01010}​\(^{s_{1}}\) \texttt{100} \texttt{00101}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 42 05 01}\\[0pt]
\hspace{1.053000em} \texttt{imm@t0 ← flag@t0 \& 0x80;} & andi t0, t0, 0x80 & \emph{\texttt{0x080}}                    \texttt{00101}​\(^{s_{1}}\) \texttt{111} \texttt{00101}​\(^{d}\)  \texttt{0010011} &  & \texttt{93 F2 02 08}\\[0pt]
\hspace{1.053000em} \texttt{imm+state@a1 ← imm@t0} & lbu t1, 32(s2) & \uline{\texttt{0x020}}                    \texttt{10010}​\(^{s_{1}}\) \texttt{100} \texttt{00110}​\(^{d}\)  \texttt{0000011} &  & \texttt{03 43 09 02}\\[0pt]
\hspace{7.897500em}              \(\vert{}\) \texttt{[STATE];} & or a1, t0, t1 & \texttt{0000000} \texttt{00110}​\(^{s_{2}}\) \texttt{00101}​\(^{s_{1}}\) \texttt{110} \texttt{01011}​\(^{d}\)  \texttt{0110011} &  & \texttt{B3 E5 62 00}\\[0pt]
\hspace{1.053000em} \emph{\# Let \texttt{compl} and \texttt{exec} decide} &  &  &  & \\[0pt]
\hspace{1.053000em} \emph{\# what to do.} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{push ra;} & addi sp, sp, -8 & \emph{\texttt{0xFF8}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 01 81 FF}\\[0pt]
\hspace{1.053000em} & sd ra, 0(sp) & \uline{\texttt{0000000}} \texttt{00001}​\(^{s_{2}}\) \texttt{00010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} &  & \texttt{23 30 11 00}\\[0pt]
\hspace{1.053000em} \texttt{call compl;}  \hspace{0.000000em}​\emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{63}​\(_{c}\)​\texttt{]}\\[0pt]
\hspace{1.053000em} \texttt{call exec;}   \hspace{0.526500em}​\emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{65}​\(_{e}\)​\texttt{]}\\[0pt]
\hspace{1.053000em} \texttt{pop ra;} & ld ra, 0(sp) & \uline{\texttt{0x000}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{011} \texttt{00001}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 30 01 00}\\[0pt]
\hspace{1.053000em} & addi sp, sp, 8 & \emph{\texttt{0x008}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 01 81 00}\\[0pt]
\texttt{\_end:} &  &  & \texttt{34} & \\[0pt]
\hspace{1.053000em} \texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} &  & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org5c01d9f}\texttt{hit} compiles or executes a word found in the dictionary (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

We make no further comments on the other subroutines ported in this
section, as they are very similar to their x86-64 original source
code.

\subsubsection{Bringing Everything Together: \texttt{SVAL}, \texttt{ti} (RISC-V)}
\label{sec:org3773e57}

We have almost reached the end of our efforts to port SmithForth to
RISC-V.  In the final two translated subroutines, displayed in Tables
\ref{tab:orga8004d0} and \ref{tab:org84a015f}, word evaluation and the
interpreter loop are being set up.  Similarly to SmithForth, all file
contents following the last \texttt{jalr} instruction in \texttt{ti} is interpreted
by the loop as Forth source code.  In the next chapter, we will show a
possible way to continue extending our Forth in Forth itself.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{7}{8.400000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{\&} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{SVAL}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{04} \uline{\texttt{53 56 41 4C}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( ··· -{}-{} ··· )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Evaluate a Forth line: repeatedly} &  &  &  & \\[0pt]
\emph{\# parse a token, attempt finding it} &  &  &  & \\[0pt]
\emph{\# in the dictionary, then allow \texttt{miss}} &  &  &  & \\[0pt]
\emph{\# and \texttt{hit} to choose the appropriate} &  &  &  & \\[0pt]
\emph{\# action in context.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{push ra;} & addi sp, sp, -8 & \emph{\texttt{0xFF8}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 01 81 FF}\\[0pt]
 & sd ra, 0(sp) & \uline{\texttt{0000000}} \texttt{00001}​\(^{s_{2}}\) \texttt{00010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{00000}} \texttt{0100011} &  & \texttt{23 30 11 00}\\[0pt]
\texttt{\_begin:} &  &  & \(\overline{\texttt{00}}\) & \\[0pt]
\hspace{1.053000em} \texttt{call pname;}  \hspace{0.000000em}​\emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{70}​\(_{p}\)​\texttt{]}\\[0pt]
\hspace{1.053000em} \texttt{call FIND;}   \hspace{0.526500em}​\emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{46}​\(_{F}\)​\texttt{]}\\[0pt]
\hspace{1.053000em} \texttt{call miss;}   \hspace{0.526500em}​\emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{6D}​\(_{m}\)​\texttt{]}\\[0pt]
\hspace{1.053000em} \texttt{call hit;}    \hspace{1.053000em}​\emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{68}​\(_{h}\)​\texttt{]}\\[0pt]
\hspace{1.053000em} \emph{\# Characters left in current line?} &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{>in@t0 ← [>IN];} & ld t0, 16(s2) & \uline{\texttt{0x010}}                    \texttt{10010}​\(^{s_{1}}\) \texttt{011} \texttt{00101}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 32 09 01}\\[0pt]
\hspace{1.053000em} \texttt{\#in@t1 ← [\#IN];} & ld t1, 0(s2) & \uline{\texttt{0x000}}                    \texttt{10010}​\(^{s_{1}}\) \texttt{011} \texttt{00110}​\(^{d}\)  \texttt{0000011} &  & \texttt{03 33 09 00}\\[0pt]
\hspace{1.053000em} \texttt{if >in@t0 < \#in@t1:} &  &  &  & \\[0pt]
\hspace{2.106000em}   \texttt{goto \_begin.} & bltu t0, t1, -0x28 & \uline{\texttt{1111110}} \texttt{00110}​\(^{s_{2}}\) \texttt{00101}​\(^{s_{1}}\) \texttt{110} \uline{\texttt{11001}} \texttt{1100011} & \texttt{28} & \texttt{E3 EC 62 FC}\\[0pt]
\hspace{1.053000em} \texttt{pop ra;} & ld ra, 0(sp) & \uline{\texttt{0x000}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{011} \texttt{00001}​\(^{d}\)  \texttt{0000011} &  & \texttt{83 30 01 00}\\[0pt]
\hspace{1.053000em} & addi sp, sp, 8 & \emph{\texttt{0x008}}                    \texttt{00010}​\(^{s_{1}}\) \texttt{000} \texttt{00010}​\(^{d}\)  \texttt{0010011} &  & \texttt{13 01 81 00}\\[0pt]
\hspace{1.053000em} \texttt{return.} & jalr zero, 0(ra) & \uline{\texttt{0x000}}                    \texttt{00001}​\(^{s_{1}}\) \texttt{000} \texttt{00000}​\(^{d}\)  \texttt{1100111} &  & \texttt{67 80 00 00}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:orga8004d0}Subroutine \texttt{SVAL} evaluates a line of Forth code (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{8}{9.600000}\selectfont
\begin{center}
\begin{tabular}{l|ll|l|l}
\textbf{Pseudocode} & \textbf{Instruction} & \textbf{Encoding} & \textbf{\&} & \textbf{Machine code}\\[0pt]
\hline
\emph{\# Define:} \uline{\texttt{ti}} & --- & --- &  & \texttt{[99} \(^{d}\)​\texttt{02} \uline{\texttt{74 69}}​\texttt{]}\\[0pt]
\emph{\# In/Out:} \texttt{( -{}-{} )} &  &  &  & \\[0pt]
\emph{\#} &  &  &  & \\[0pt]
\emph{\# Initialize data stack and text} &  &  &  & \\[0pt]
\emph{\# input, then repeatedly refill} &  &  &  & \\[0pt]
\emph{\# lines and evaluate them.} &  &  &  & \\[0pt]
 &  &  &  & \\[0pt]
\hspace{1.053000em} \texttt{STACK@s3 ← 0x10000000;} & lui s3, 0x10000 & \emph{\texttt{0x00001}}                                                  \texttt{10011}​\(^{d}\)  \texttt{0110111} &  & \texttt{B7 09 00 10}\\[0pt]
\hspace{1.053000em} \texttt{[TIB] ← INPUT@s0;} & sd s0, 8(s2) & \uline{\texttt{0000000}} \texttt{01000}​\(^{s_{2}}\) \texttt{10010}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{01000}} \texttt{0100011} &  & \texttt{23 34 89 00}\\[0pt]
\hspace{1.053000em} \texttt{call [;}  \emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{5B}​\(_{[}\)​\texttt{]}\\[0pt]
\texttt{\_begin:} &  &  & \(\overline{\texttt{00}}\) & \\[0pt]
\hspace{1.053000em} \texttt{call REFILL;}  \hspace{0.000000em}​\emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{52}​\(_{R}\)​\texttt{]}\\[0pt]
\hspace{1.053000em} \texttt{call SVAL;}    \hspace{1.053000em}​\emph{\# Compiled.} & --- & --- &  & \texttt{[99} \(^{c}\)​\texttt{53}​\(_{S}\)​\texttt{]}\\[0pt]
\hspace{1.053000em} \texttt{goto \_begin.} & jal zero, -0x10 & \uline{\texttt{11111111000111111111}}                                     \texttt{00000}​\(^{d}\)  \texttt{1101111} & \texttt{10} & \texttt{6F F0 1F FF}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org84a015f}Finally, subroutine \texttt{ti} reads and evaluates Forth in a loop (RISC-V).}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}
\clearpage


\section{Forth in Forth}
\label{sec:org2f0b45c}

In this chapter we continue building on top of the basic Forth system
that we bootstrapped in Chapter \ref{sec:org9c46462}.  Since
the text interpreter can now execute Forth, we can use the existing
routines to extend the available functionality by defining additional
Forth words.

As a challenge, we set to develop enough Forth utilities to solve the
classical FizzBuzz problem by the end of the chapter
\citeprocitem{36}{[36]}.  This requires at least arithmetic, conditional
execution, loops and the ability to print numbers and strings to the
terminal.

\subsection{A Few Basic Utilities}
\label{sec:org4d31794}

Subroutine \texttt{'.'} defined in machine code allows us to embed further
machine code in Forth definitions.  Here we define a few simple
primitive helpers for navigating the stack and for transferring data
between the data stack and registers \texttt{t0} and \texttt{t1}.  Note that words
\texttt{\textasciicircum{}}, \texttt{v} and \texttt{\%} move only the stack pointer; care must be taken to
not accidentally overwrite stack data:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
\ Load current stack item into register `t0` or `t1`.
: >t0 ( x -- x )   83 . B2 . 09 . 00 . ;                       \ t0 = [s3]      ld t0, 0(s3)
: >t1 ( x -- x )   03 . B3 . 09 . 00 . ;                       \ t1 = [s3]      ld t1, 0(s3)
\ Store register `t0` or `t1` over current stack item.
: t0> ( ? -- x )   23 . B0 . 59 . 00 . ;                       \ [s3] = t0      sd t0, 0(s3)
: t1> ( ? -- x )   23 . B0 . 69 . 00 . ;                       \ [s3] = t1      sd t1, 0(s3)
\ Navigate the stack.
: ^ ( x -- .. )    93 . 89 . 89 . 00 . ;                       \ s3 += 8        addi s3, s3, 8
: v ( .. -- x )    93 . 89 . 89 . FF . ;                       \ s3 -= 8        addi s3, s3, -8
\ "Float" current stack item "up" the stack, exchanging with item
\ above.  Stack pointer follows the item.
: % ( x1 x2 -- x2 .. )
  >t1 ^  >t0 v
  t0> ^  t1> ;
\end{verbatim}
\normalsize

Using these helpers we now define the classic Forth words for stack
manipulation \citeprocitem{9}{[9]}:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
: DROP ( x -- )                   [ ^ ] ;
: DUP  ( x -- x x )               [ >t0 v t0> ] ;
: SWAP ( x1 x2 -- x2 x1 )         [ % v ] ;
: OVER ( x1 x2 -- x1 x2 x1 )      [ ^ >t0 v v t0> ] ;
: ROT  ( x1 x2 x3 -- x2 x3 x1 )   [ ^ % v v % v ]  ;
: 2SWAP ( d1 d2 -- d2 d1 )        [ ^ % % v v v % % v v ] ;
: 2DUP ( d -- d d )               [ ^ >t0 v >t1 v t0> v t1> ] ;
: 2OVER ( d1 d2 -- d1 d2 d1 )     [ ^ ^ ^ >t0 v >t1 v v v t0> v t1> ] ;
: 2DROP ( d1 d2 -- d1 )           [ ^ ^ ] ;
\end{verbatim}
\normalsize


\subsection{A RISC-V Assembler in Forth}
\label{sec:orga98b7ef}

By now we have written enough machine code by hand.  Since we have
Forth at our disposal, we can write an assembler (or at least an
instruction encoder) for RISC-V.  Several bit twiddling utilities are
defined first:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
\ Left shift, OR, AND, Minus.
: << ( n u -- n' )   [ >t1 ^ >t0 ] [ B3 . 92 . 62 . 00 . ] [ t0> ] ;        \ sll t0, t0, t1
: | ( u1 u2 -- u )   [ >t1 ^ >t0 ] [ B3 . E2 . 62 . 00 . ] [ t0> ] ;        \ or  t0, t0, t1
: & ( u1 u2 -- u )   [ >t1 ^ >t0 ] [ B3 . F2 . 62 . 00 . ] [ t0> ] ;        \ and t0, t0, t1
: - ( n1 n2 -- n )   [ >t1 ^ >t0 ] [ B3 . 82 . 62 . 40 . ] [ t0> ] ;        \ sub t0, t0, t1

\ Pick bits `i` (high) through `j` (low) from `n`.
: [:] ( u i j -- u' )
  [ >t1 ]                   \ t1 = j
  [ ^ ^ >t0 ]               \ t0 = u                   ( -- u .. )
  [ B3 . D2 . 62 . 00 . ]   \ t0 <<= t1                srl t0, t0, t1
  [ t0> v v ]               \ v = t0                   ( -- v i j )
  1 -  -                    \ len = i - (j - 1)        ( -- v len )
  1 SWAP <<  1 -            \ mask = (1 << len) - 1    ( -- v mask )
  & ;                       \ u' = v & mask            ( -- u' )
\end{verbatim}
\normalsize

Using the bit selection word \texttt{[:]} we can now define \texttt{`} (backtick),
an improved version of \texttt{'.'}​.  Instead of operating on bytes, it
writes entire 32-bit instructions at \texttt{OUTPUT}, respecting the correct
endianness:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}

\ Compile a 32-bit instruction (in the form of a 32-bit
\ unsigned integer) to `OUTPUT`, ensuring correct endianness.
: ` ( u -- )
  DUP 1F 18 [:] SWAP  ( -- u[31:24] u )
  DUP 17 10 [:] SWAP  ( -- u[31:24] u[23:16] u )
  DUP 0F 08 [:] SWAP  ( -- u[31:24] u[23:16] u[15:8] u )
  07 00 [:]           ( -- u[31:24] u[23:16] u[15:8] u[7:0] )
  . . . . ;
\end{verbatim}
\normalsize

As discussed in a previous chapter, all RISC-V instructions belong to
one of six types and are encoded to binary accordingly.  Some of the
six formats have a shared structure; this is the case for types \texttt{R},
\texttt{S} and \texttt{B}.  Below we create a generic, shared encoding word for
these types, which we then use to define the format for type \texttt{R}.
Finally we specify all instructions belonging to type \texttt{R}, including
the ones added by the 64-bit extension:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
\ Common format for R/S/B-type instructions.
: `instr/rsb ( op rd/imm5 fn3 rs1 rs2 fn7/imm7 -- )
  5 << | 5 << | 3 << | 5 << | 7 << | ` ;

\ R-type instructions.
: `instr/r ( rd rs1 rs2 fn7 fn3 op -- )
  [ % % % % % v v v v v ]  ( -- op rd rs1 rs2 fn7 fn3 )
  [ % % %         v v v ]  ( -- op rd fn3 rs1 rs2 fn7 )
  `instr/rsb ;
: `add  ( rd rs1 rs2 -- )   00 0 33 `instr/r ;
: `sub  ( rd rs1 rs2 -- )   20 0 33 `instr/r ;
: `sll  ( rd rs1 rs2 -- )   00 1 33 `instr/r ;
: `slt  ( rd rs1 rs2 -- )   00 2 33 `instr/r ;
: `sltu ( rd rs1 rs2 -- )   00 3 33 `instr/r ;
: `xor  ( rd rs1 rs2 -- )   00 4 33 `instr/r ;
: `srl  ( rd rs1 rs2 -- )   00 5 33 `instr/r ;
: `sra  ( rd rs1 rs2 -- )   20 5 33 `instr/r ;
: `or   ( rd rs1 rs2 -- )   00 6 33 `instr/r ;
: `and  ( rd rs1 rs2 -- )   00 7 33 `instr/r ;
\ RV64 instructions.
: `addw ( rd rs1 rs2 -- )   00 0 3B `instr/r ;
: `subw ( rd rs1 rs2 -- )   20 0 3B `instr/r ;
: `sllw ( rd rs1 rs2 -- )   00 1 3B `instr/r ;
: `srlw ( rd rs1 rs2 -- )   00 5 3B `instr/r ;
: `sraw ( rd rs1 rs2 -- )   20 5 3B `instr/r ;
\end{verbatim}
\normalsize

Next are defined all \texttt{I}-type instructions:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
\ I-type instructions.
: `instr/i ( rd rs1 imm fn3 op -- )
  [ % % % % v v v v ]  ( -- op rd rs1 imm fn3 )
  [ % %         v v ]  ( -- op rd fn3 rs1 imm )
  5 << | 3 << | 5 << | 7 << | ` ;
: `instr/i/shift ( rd rs1 shamt fn7 fn3 op -- )
  2SWAP          ( -- rd rs1 fn3 op shamt fn7 )
  5 << |         ( -- rd rs1 fn3 op imm )
  ROT ROT        ( -- rd rs1 imm fn3 op )
  `instr/i ;
: `ecall ( -- )                0 0 000 0 73 `instr/i ;
: `jalr  ( rd rs1 imm   -- )           0 67 `instr/i ;
: `lb    ( rd rs1 imm   -- )           0 03 `instr/i ;
: `lh    ( rd rs1 imm   -- )           1 03 `instr/i ;
: `lw    ( rd rs1 imm   -- )           2 03 `instr/i ;
: `lbu   ( rd rs1 imm   -- )           4 03 `instr/i ;
: `lhu   ( rd rs1 imm   -- )           5 03 `instr/i ;
: `addi  ( rd rs1 imm   -- )           0 13 `instr/i ;
: `slti  ( rd rs1 imm   -- )           2 13 `instr/i ;
: `sltiu ( rd rs1 imm   -- )           3 13 `instr/i ;
: `xori  ( rd rs1 imm   -- )           4 13 `instr/i ;
: `ori   ( rd rs1 imm   -- )           6 13 `instr/i ;
: `andi  ( rd rs1 imm   -- )           7 13 `instr/i ;
: `slli  ( rd rs1 shamt -- )        00 1 13 `instr/i/shift ;
: `srli  ( rd rs1 shamt -- )        00 5 13 `instr/i/shift ;
: `srai  ( rd rs1 shamt -- )        20 5 13 `instr/i/shift ;
\ RV64 instructions.
: `lwu   ( rd rs1 imm   -- )           6 03 `instr/i ;
: `ld    ( rd rs1 imm   -- )           3 03 `instr/i ;
: `addiw ( rd rs1 imm   -- )           0 1B `instr/i ;
: `slliw ( rd rs1 shamt -- )        00 1 1B `instr/i/shift ;
: `srliw ( rd rs1 shamt -- )        00 5 1B `instr/i/shift ;
: `sraiw ( rd rs1 shamt -- )        20 5 1B `instr/i/shift ;
\end{verbatim}
\normalsize

Instructions of type \texttt{S} ``inherit'' from \texttt{instr/rsb}, as do \texttt{B}-type instructions:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
\ S-type instructions.
: `instr/s ( rs2 rs1 offset fn3 op -- )
  [ % % % % v v v v ]  ( -- op rs2 rs1 offset fn3 )
  [ % % %     v v v ]  ( -- op fn3 rs2 rs1 offset )
  DUP 4 0 [:]          ( -- op fn3 rs2 rs1 offset imm5 )
  [ % % % % v v v v ]  ( -- op imm5 fn3 rs2 rs1 offset )
  B 5 [:]              ( -- op imm5 fn3 rs2 rs1 imm7 )
  [ ^ %         v v ]  ( -- op imm5 fn3 rs1 rs2 imm7 )
  `instr/rsb ;
: `sb  ( rs2 rs1 offset -- )   0 23 `instr/s ;
: `sh  ( rs2 rs1 offset -- )   1 23 `instr/s ;
: `sw  ( rs2 rs1 offset -- )   2 23 `instr/s ;
: `sd  ( rs2 rs1 offset -- )   3 23 `instr/s ;

\ B-type instructions.
: `instr/b ( rs1 rs2 offset fn3 op -- )
  [ % % % % v v v v ]   ( -- op rs1 rs2 offset fn3 )
  [ % % %     v v v ]   ( -- op fn3 rs1 rs2 offset )
  DUP DUP  4 1 [:]      ( -- op fn3 rs1 rs2 offset offset offset[4:1] )
  1 << SWAP  B B [:] |  ( -- op fn3 rs1 rs2 offset imm5 )
  [ % % % % v v v v ]   ( -- op imm5 fn3 rs1 rs2 offset )
  DUP  C C [:]          ( -- op imm5 fn3 rs1 rs2 offset offset[12] )
  6 << SWAP  A 5 [:] |  ( -- op imm5 fn3 rs1 rs2 imm7 )
  `instr/rsb ;
: `beq  ( rs1 rs2 offset -- )   0 63 `instr/b ;
: `bne  ( rs1 rs2 offset -- )   1 63 `instr/b ;
: `blt  ( rs1 rs2 offset -- )   4 63 `instr/b ;
: `bge  ( rs1 rs2 offset -- )   5 63 `instr/b ;
: `bltu ( rs1 rs2 offset -- )   6 63 `instr/b ;
: `bgeu ( rs1 rs2 offset -- )   7 63 `instr/b ;
\end{verbatim}
\normalsize

Instructions of types \texttt{U} and \texttt{J} also use a shared structure:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
\ Common format for U/J-type instructions.
: `instr/uj  ( op rd imm20 -- )
  5 << | 7 << | ` ;

\ U-type instructions.
: `instr/u ( rd imm opcode -- )
  ROT ROT `instr/uj ;
: `lui   ( rd imm -- )   37 `instr/u ;
: `auipc ( rd imm -- )   17 `instr/u ;

\ J-type instructions.
: `instr/j ( rd offset op -- )
  ROT ROT               ( -- op rd offset )
  DUP 13 0C [:] SWAP    ( -- op rd offset[19:12] offset )
  DUP 0B 0B [:] SWAP    ( -- op rd offset[19:12] offset[11] offset )
  DUP 0A 01 [:] SWAP    ( -- op rd offset[19:12] offset[11] offset[10:1] offset )
      14 14 [:]         ( -- op rd offset[19:12] offset[11] offset[10:1] offset[20] )
  A << | 1 << | 8 << |  ( -- op rd imm20 )
  `instr/uj ;
: `jal ( rd offset -- )  6F `instr/j ;
\end{verbatim}
\normalsize

Finally, we give aliases to registers according to their ABI names:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
\ ABI names for registers.
: zero 00 ;   : s0   08 ;   : a6  10 ;   : s8  18 ;
: ra   01 ;   : s1   09 ;   : a7  11 ;   : s9  19 ;
: sp   02 ;   : a0   0A ;   : s2  12 ;   : s10 1A ;
: gp   03 ;   : a1   0B ;   : s3  13 ;   : s11 1B ;
: tp   04 ;   : a2   0C ;   : s4  14 ;   : t3  1C ;
: t0   05 ;   : a3   0D ;   : s5  15 ;   : t4  1D ;
: t1   06 ;   : a4   0E ;   : s6  16 ;   : t5  1E ;
: t2   07 ;   : a5   0F ;   : s7  17 ;   : t6  1F ;
\end{verbatim}
\normalsize

The assembler is complete in less than 200 lines.  One can now
assemble instructions to \texttt{OUTPUT} using a syntax very similar to
conventional assembly.  For example \texttt{t0 s2 4 `lb} loads a byte from
memory location \texttt{s2 + 4} into register \texttt{t0}.


\subsection{Arithmetic, Logic and Comparison Operators}
\label{sec:org14516bc}

This section defines common arithmetic, logic and comparison
operators.  Notably, we do not include any multiplication and division
operators, since it would require the \texttt{RV32M} and/or \texttt{RV64M} RISC-V
extensions and we purposely set out to only work with \texttt{RV64I}.

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
\ Arithmetic operators.
: NEGATE ( n -- n' )      [ >t0 ]       [ t0 zero t0 `sub ] [ t0> ] ;
: +      ( n1 n2 -- n )   [ >t1 ^ >t0 ] [ t0   t0 t1 `add ] [ t0> ] ;
: 1+     ( n -- n' )      [ >t0 ]       [ t0 t0   1 `addi ] [ t0> ] ;
: 1-     ( n -- n' )      [ >t0 ]       [ t0 t0 FFF `addi ] [ t0> ] ;
: LSHIFT ( n u -- n' )    [ >t1 ^ >t0 ] [ t0 t0  t1 `sll  ] [ t0> ] ;
: RSHIFT ( n u -- n' )    [ >t1 ^ >t0 ] [ t0 t0  t1 `srl  ] [ t0> ] ;
: 2*     ( n -- n' )      [ >t0 ]       [ t0 t0   1 `slli ] [ t0> ] ;
: 2/     ( n -- n' )      [ >t0 ]       [ t0 t0   1 `srai ] [ t0> ] ;
: ABS    ( n -- n' )      [ >t0   >t1 ] [ t1 t1  3F `srai ]            \ mask@t1 >>= 63
                                        [ t0 t0  t1 `xor  ]            \ t0 = t0 xor mask@t1
                                        [ t0 t0  t1 `sub  ] [ t0> ] ;  \ t0 -= mask@t1
: MIN    ( n1 n2 -- nmin )   2DUP -        ( -- n1 n2 n1-n2 )
                             DUP ABS       ( -- n1 n2 n1-n2 |n1-n2| )
                             - 2/ +        ( -- n1 nmin )
                             SWAP DROP ;   ( -- nmin )
: MAX    ( n1 n2 -- n )   2DUP -  DUP ABS  + 2/ +  SWAP DROP ;
\end{verbatim}
\normalsize

Note how Forth uses \texttt{-1} (all bits set to \texttt{1}) as the \emph{true} value:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
\ Logic (bitwise) operators.
: FALSE  ( -- false )     0 ;
: TRUE   ( -- true )      [ t0 zero FFF `addi ] [ v t0> ] ;
: AND    ( x1 x2 -- x )   & ;
: OR     ( x1 x2 -- x )   | ;
: XOR    ( x1 x2 -- x )   [ >t1 ^ >t0 ] [ t0 t0  t1 `xor  ] [ t0> ] ;
: INVERT ( x -- x' )      [ >t0 ]       [ t0 t0 FFF `xori ] [ t0> ] ;
\end{verbatim}
\normalsize

The comparison operators defined below will be especially useful once
we introduce conditional execution through \texttt{IF..ELSE..THEN}:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
\ Comparison operators.
: t0<>0   t1 zero  t0 `sub
          t0   t0  t1 `or
          t0   t0  3F `srai ;
: 0<> ( n -- flag )       [ >t0 ]                          [ t0<>0 ] [ t0> ] ;
: 0=  ( n -- flag )       0<> INVERT ;
: <>  ( n1 n2 -- flag )   [ >t1 ^ >t0 ] [ t0 t0 t1 `xor  ] [ t0<>0 ] [ t0> ] ;
: =   ( n1 n2 -- flag )   <> INVERT ;
: <   ( n1 n2 -- flag )   [ >t1 ^ >t0 ] [ t0 t0 t1 `slt  ] [ t0<>0 ] [ t0> ] ;
: >   ( n1 n2 -- flag )   [ >t1 ^ >t0 ] [ t0 t1 t0 `slt  ] [ t0<>0 ] [ t0> ] ;
: U<  ( u1 u2 -- flag )   [ >t1 ^ >t0 ] [ t0 t0 t1 `sltu ] [ t0<>0 ] [ t0> ] ;
: U>  ( u1 u2 -- flag )   [ >t1 ^ >t0 ] [ t0 t1 t0 `sltu ] [ t0<>0 ] [ t0> ] ;
: 0<  ( n -- flag )       0 < ;
: 0>  ( n -- flag )       0 > ;
\end{verbatim}
\normalsize


\subsection{Accessing Memory and Defining Words}
\label{sec:org6c59b1f}

Below are defined the standard memory access words:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
\ Memory access.
: C! ( c addr -- )   [ >t1 ^ >t0 ^ ] [ t0 t1  0 `sb  ]         ;
: C@ ( addr -- c )   [ >t1         ] [ t0 t1  0 `lbu ] [ t0> ] ;
: !  ( n addr -- )   [ >t1 ^ >t0 ^ ] [ t0 t1  0 `sd  ]         ;
: @  ( addr -- n )   [ >t1         ] [ t0 t1  0 `ld  ] [ t0> ] ;
: +! ( n addr -- )   DUP @  ( -- n addr n0 )
                     ROT +  ( -- addr n' )
                     SWAP ! ;
\end{verbatim}
\normalsize

We also give access to some of the global variables:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
: STATE  ( -- addr )   [ t0 s2 20 `ld ] [ v t0> ] ;
: LATEST ( -- addr )   [ t0 s2 28 `ld ] [ v t0> ] ;
\end{verbatim}
\normalsize

Here we give standard words for working with the \emph{data space}.  In
conjunction with \texttt{CREATE}, also defined soon, they make it possible to
create arbitrary named data structures.  One first \texttt{CREATE}​s a name in
the dictionary and then allocates memory with \texttt{ALLOT} or writes it
directly with \texttt{,} or \texttt{C,}:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
: HERE   ( -- addr )   [ t0 s1  0 `addi ] [ v t0> ] ;
: HERE!  ( addr -- )   [ >t0 ^ ] [ s1 t0  0 `addi ] ;

: ALLOT ( n -- )      [ >t0 ^ ] [ s1 s1 t0 `add ] ;
: CHARS ( n -- n' )            ;
: CELLS ( n -- n' )   3 LSHIFT ;

: , ( n -- )
  1 CELLS ALLOT
  [ >t0 ^ ] [ t0 s1  8 NEGATE  `sd ] ;
: C, ( n -- )   . ;
\end{verbatim}
\normalsize

Below we define \texttt{IMMEDIATE}, which enables the \emph{immediate} flag on the
most recent dictionary word.  \texttt{LITERAL} reimplements \texttt{LIT} in Forth.

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
: IMMEDIATE ( -- ) 
  LATEST 10 +                        ( -- flag-addr )
  DUP C@  80 |                       ( -- flag-addr flag' )
  SWAP C! ;

: LITERAL ( C: x -- ) ( -- x )
  \ Compile "lui t0, 0xHHHHH[+1]".
  DUP  ( mask: ) FF 4 LSHIFT F |  &  ( -- n low )
  DUP B RSHIFT ROT                   ( -- low sign n )
  C RSHIFT +  t0 SWAP  `lui          ( -- low )
  \ Compile "addi t0, 0xLLL".
  t0 t0 ROT  `addi                   ( -- )
  \ Compile a sequence that pushes `t0` on the stack.
  v t0> ;
\end{verbatim}
\normalsize

\texttt{CREATE}, mentioned above, calls \texttt{pname} and \texttt{Head} to create a
dictionary entry for the next word at input.  Related are \texttt{VARIABLE}
and \texttt{CONSTANT}, which allow creating variables and constants,
respectively.  When executed, a variable pushes its own address on the
stack while a constant pushes its own value.

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}

: create ( "<spaces>name" -- )
  pname
  [ v ] [ s0 s3  0 `sd   ]         \ save INPUT@s0
        [ s0 a0  0 `addi ]         \ INPUT@s0 = addr@a0
        [ a0 s2 28 `ld   ]         \ latest@a0 = [LATEST] (as required by Head)
  Head  [ s0 s3  0 `ld   ] [ ^ ] ; \ restore INPUT@s0

: CREATE ( "<spaces>name" -- ) ( -- addr )
  create
  \ Compile code that pushes on the stack the address of the empty
  \ space following the CREATEd definition.
  t0 0 `auipc
  t0 t0 14 `addi
  v t0>
  \ Compile "jalr zero, 0(ra)".
  zero ra 0 `jalr ;

: VARIABLE ( "<spaces>name" -- ) ( -- addr )   CREATE  0 , ;
: CONSTANT ( x "<spaces>name" -- ) ( -- x )    create  LITERAL  zero ra 0 `jalr ;
\end{verbatim}
\normalsize


\subsection{Control Flow}
\label{sec:orgacfbe56}

We are finally ready add control flow constructs to our language.
First we give Forth direct access to the return stack, called the
\emph{control stack} in Forth.  Note the special definition of \texttt{>R}, \texttt{R>}
and \texttt{R@}: since they operate on the return stack, the prologue and
epilogue installed by \texttt{':'} and \texttt{';'} must not be used.  We \texttt{ALLOT}
with a negative amount to overwrite the prologue and we explicitly
encode an early return to shortcircuit the epilogue.

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
: >>t0 ( R: n -- n )    t0   sp 0        `ld   ;
: t0>> ( R: ? -- n )    t0   sp 0        `sd   ;
: ^^   ( R: n -- .. )   sp   sp 8        `addi ;
: vv   ( R: .. -- n )   sp   sp 8 NEGATE `addi ;
: ret  ( -- )           zero ra 0        `jalr ;

: >R ( x --   ) ( R:   -- x )   [ 8 NEGATE ALLOT ] [  >t0  ^ ] [ vv t0>> ] [ ret ] ;
: R> (   -- x ) ( R: x --   )   [ 8 NEGATE ALLOT ] [ >>t0 ^^ ] [  v t0>  ] [ ret ] ;
: R@ (   -- x ) ( R: x -- x )   [ 8 NEGATE ALLOT ] [ >>t0    ] [  v t0>  ] [ ret ] ;
\end{verbatim}
\normalsize

Below we define the \texttt{IF..ELSE..THEN} ``syntactical construct''.  We
use the quotes because in Forth there's no rigid syntactical
structure.  The semantics of the whole is simply derived from the
semantics of the parts:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
: IF ( C: -- orig ) ( flag -- )
  \ Run-time:
  \ - pop a flag off the stack into a register:
  \   -> ">t0 ^"
  \ - branch based on the register value (offset currently unknown):
  \   -> "beq t0, zero, +???"
  >t0 ^                          \ t0 = flag                       ( -- )
  t0 zero 0 `beq                 \ if flag@t0 = 0:
                                 \   goto +???.                    \ To be backpatched by ELSE/THEN.
  \ Compilation:
  \ - push address of the branch instruction on the stack;
  \   - this address is backpatched by the corresponding ELSE/THEN.
  HERE 4 -                       \ push HERE-4 (`beq` is previous instruction)  ( C: -- orig )
  ; IMMEDIATE

: resolve ( C: orig -- ) ( -- )
  \ Compilation:
  \ - backpatch branch instruction at `orig` to use offset `HERE - orig`.
  \ - NOTE: this could be simplified if the assembler supported
  \   writing instructions on the stack rather than at `OUTPUT`.
  HERE                           \ save OUTPUT@s1                  ( C: -- orig OUTPUT )
  OVER HERE!                     \ OUTPUT@s1 = orig
  DUP ROT -                      \ offset = OUTPUT - orig          ( C: -- OUTPUT offset )
  t0 zero ROT  `beq              \ compile "beq t0, zero, offset"  ( C: -- OUTPUT )
  HERE! ;                        \ restore OUTPUT@s1               ( C: -- )

: ELSE ( C: orig -- orig' ) ( -- )
  \ Run-time:
  \ - jump forward unconditionally (offset currently unknown):
  \   -> "addi t0, zero, 0
  \   -> "beq t0, zero, +???"
  t0 zero 0 `addi                \ t0 = 0
  t0 zero 0 `beq                 \ if t0 = 0:  \ Always true!
                                 \   goto +???.                    \ To be backpatched by THEN.
  \ Compilation:
  \ - backpatch branch instr. at `orig` to jump HERE (same as THEN);
  \ - push address of the (unconditionalized) branch on the stack;
  \   - this address is backpatched by the corresponding THEN.
  resolve
  HERE 4 -                       \ push HERE-4 (`beq` is previous instruction)  ( C: -- orig' )
  ; IMMEDIATE

: THEN ( C: orig -- ) ( -- )
  \ Compilation:
  resolve ; IMMEDIATE
\end{verbatim}
\normalsize

With \texttt{resolve} already in place, defining \texttt{BEGIN..WHILE..REPEAT}
becomes almost trivial:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
\ BEGIN ... WHILE ... REPEAT
: BEGIN ( C: -- dest ) ( -- )
  \ Compilation:
  HERE ; IMMEDIATE

: WHILE ( C: dest -- orig dest ) ( flag -- )
  \ Append run-time semantics to current definition:
  >t0
  ^
  t0 zero BAD `beq              \ Will be backpatched by REPEAT.

  \ Compilation:
  HERE 4 - SWAP ; IMMEDIATE

: REPEAT ( C: orig dest -- ) ( -- )
  \ Run-time:
  HERE -                        ( C: orig offset )
  zero SWAP  `jal

  \ Compilation:
  resolve ; IMMEDIATE
\end{verbatim}
\normalsize


\subsection{I/O and a FizzBuzz Demonstration}
\label{sec:org38649f3}

One last thing is required before we can attempt to solve the FizzBuzz
problem: I/O.  Below we implement several printing routines, all built
around the machine-coded \texttt{TYPE}.  Note how \texttt{TYPE} in Forth wraps
machine-coded \texttt{TYPE} without triggering any recursion; this is
possible because incomplete words are marked as hidden in the
dictionary and thus cannot be found and compiled inside themselves.

The number printing word, called \texttt{'.'} (dot), is standard in Forth, as
are most words defined in this chapter.

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
: TYPE ( c-addr u -- )
  [ a1 s3 0 `ld ] [ ^ ]
  [ a0 s3 0 `ld ] [ ^ ]
  TYPE ;
: EMIT ( c -- )
  [ t0 s3 0 `addi ] [ v t0> ] ( -- c c-addr )
  1 TYPE  DROP ;
: CR ( -- )       0A EMIT ;
: SPACE  ( -- )   20 EMIT ;
: SPACES ( n -- )
  BEGIN DUP 0> WHILE
    SPACE
    1-
  REPEAT ;
: . ( n -- )
  0 >R  >R                    ( -- ) ( R: -- count n )
  BEGIN                       ( -- digit* )
    R@ F AND                  ( -- digit* digit )
    R> 4 RSHIFT               ( -- digit* digit n' ) ( R: -- count )
    R> 1+ >R                  ( -- digit* digit n' ) ( R: -- count' )
    DUP >R                    ( -- digit* digit n' ) ( R: -- count' n' )
    0 U>                      ( -- digit* digit flag )
  WHILE REPEAT                ( -- digit* digit ) ( R: -- count' n' )
  R> DROP                     ( R: -- count )
  BEGIN                       ( -- digit* digit ) ( R: -- count )
    DUP  9 > IF               ( -- digit* digit letter? )
      7 +
    THEN  30 +                ( -- digit* char )
    EMIT                      ( -- digit* )
    R> 1- DUP >R              ( -- digit* count' ) ( R: -- count' )
    0>                        ( -- digit* flag )
  WHILE REPEAT                ( -- digit* ) ( R: -- count' )
  R> DROP  SPACE ;            ( R: -- )
\end{verbatim}
\normalsize

Now we can solve FizzBuzz!  We can allocate strings \texttt{"Fizz"} and
\texttt{"Buzz"}, we can iterate and execute code conditionally, and we can
print to the \texttt{STDOUT}.  We have come a long way from our first
hand-written machine instructions.

Note that in the absence of standard multiplication and division
words, we implemented a simple \texttt{MOD} algorithm that calculates
remainders by successive subtractions:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
CREATE Fizz   46 C, 69 C, 7A C, 7A C,
CREATE Buzz   42 C, 75 C, 7A C, 7A C,

: MOD ( n1 n2 -- n )
  SWAP                        ( -- n2 n1 )
  BEGIN 2DUP -                ( -- n2 n1 diff )
        DUP 0<                ( -- n2 n1 diff flag1 )
        SWAP 0=               ( -- n2 n1 flag1 flag2 )
        OR                    ( -- n2 n1 flag )
  WHILE                       ( -- n2 n1 )
    OVER -                    ( -- n2 n1' )
  REPEAT
  SWAP DROP ;                 ( -- n1' )

: FizzBuzz
  64 0 BEGIN                  ( -- limit i )
    2DUP >                    ( -- limit i flag )
  WHILE                       ( -- .. i )
    1+  FALSE                 ( -- .. i' flag )
    OVER  3 MOD 0=            ( -- .. i' flag flag/3 )
    DUP IF
      Fizz 4 TYPE             \ Print "Fizz".
    THEN OR                   ( -- .. i' flag' )
    OVER  5 MOD 0=            ( -- .. i' flag' flag/5 )
    DUP IF
      Buzz 4 TYPE             \ Print "Buzz".
    THEN OR                   ( -- .. i' flag'' )
    0= IF                     ( -- .. i' )
      DUP .                   \ Otherwise print the number.
    THEN                      ( -- .. i' )
    CR                        \ Print newline.
  REPEAT ;
\end{verbatim}
\normalsize

Finally, we invoke our program:

\fontsize{9pt}{9.000000pt}\selectfont
\begin{verbatim}
FizzBuzz BYE
\end{verbatim}
\normalsize

Success!
\pagebreak


\section{Conclusions}
\label{sec:org21e39ae}

We have implemented a usable Forth system using only RISC-V machine
code and the Linux operating system as foundations.  We used the
excellent SmithForth as inspiration, created by David Smith for the
x86-64 architecture.  We have thoroughly analyzed its machine code
implementation, porting and adapting it to the idiosyncrasies of
RISC-V.  We have also provided an extension of this Forth system
written in Forth itself: we provide a RISC-V assembler, useful
arithmetic and logic operators, conditional and looping constructs.
We complete our demonstration with a Forth implementation of FizzBuzz,
showing the usability of the system.

In conclusion, we have shown one possible path starting from the
extremely low-level machine code and leading towards increasing
abstraction all the way to a powerful, extendable high-level language.
We have used the RISC-V architecture as our host, showing that it is
very appropriate for exploring the fundamental principles of
computing.
\clearpage


\section{Bibliography}
\label{sec:org6def4cf}

References:

\hypertarget{citeproc_bib_item_1}{[1] “Rust: Overview of the compiler.” 2024. \textsc{\url{https://rustc-dev-guide.rust-lang.org/overview.html\#overview-of-the-compiler}}}

\hypertarget{citeproc_bib_item_2}{[2] A. Ghuloum, “An Incremental Approach to Compiler Construction,” \textit{Proceedings of the 2006 scheme and functional programming workshop}, 2006, \textsc{\url{http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf}}}

\hypertarget{citeproc_bib_item_3}{[3] Forth 200x Standards Committee, “Forth 2012 Standard.” \textsc{\url{https://forth-standard.org}}}

\hypertarget{citeproc_bib_item_4}{[4] E. D. Rather, D. R. Colburn, and C. H. Moore, “The evolution of forth,” in \textit{History of programming languages–-ii}, New York, NY, USA: Association for Computing Machinery, 1996, pp. 625–670. \textsc{\url{https://doi.org/10.1145/234286.1057832}}}

\hypertarget{citeproc_bib_item_5}{[5] J. McCarthy, “Recursive functions of symbolic expressions and their computation by machine, part i,” \textit{Communications of the acm}, vol. 3, no. 4, pp. 184–195, 1960.}

\hypertarget{citeproc_bib_item_6}{[6] H. Abelson and G. J. Sussman, \textit{Structure and interpretation of computer programs}, 2nd ed. Cambridge, MA, USA: MIT Press, 1996.}

\hypertarget{citeproc_bib_item_7}{[7] PUC-Rio, “About Lua.” \textsc{\url{https://www.lua.org/about.html}}}

\hypertarget{citeproc_bib_item_8}{[8] Mike Pall, “LuaJIT: a Just-In-Time Compiler (JIT) for the Lua programming language.” \textsc{\url{http://luajit.org/luajit.html}}}

\hypertarget{citeproc_bib_item_9}{[9] L. Brodie, \textit{Starting FORTH}. Prentice-Hall, 1981. \textsc{\url{https://forth.com/starting-forth}}}

\hypertarget{citeproc_bib_item_10}{[10] L. Brodie, \textit{Thinking FORTH}. Punchy Publishing, 2004. \textsc{\url{https://forth.com/wp-content/uploads/2018/11/thinking-forth-color.pdf}}}

\hypertarget{citeproc_bib_item_11}{[11] A. Ertl and B. Paysan, “Gforth: A free, fast, featureful and portable implementation of the Forth 2012 language.” \textsc{\url{https://gforth.org}}}

\hypertarget{citeproc_bib_item_12}{[12] R. W. Jones, “JONESFORTH: A sometimes minimal FORTH compiler and tutorial for Linux / i386 systems.” 2009. \textsc{\url{http://git.annexia.org/?p=jonesforth.git}}}

\hypertarget{citeproc_bib_item_13}{[13] C. Blum, “sectorforth. A 16-bit x86 Forth that fits in a 512-byte boot sector.” 2020. \textsc{\url{https://github.com/cesarblum/sectorforth/}}}

\hypertarget{citeproc_bib_item_14}{[14] @fuzzballcat, “milliForth. A FORTH in 340 bytes — the smallest real programming language ever as of yet.” 2023. \textsc{\url{https://github.com/fuzzballcat/milliForth}}}

\hypertarget{citeproc_bib_item_15}{[15] D. Smith, “SmithForth: A Forth for x86-64 personal computers.” 2022. \textsc{\url{https://dacvs.neocities.org/SF/}}}

\hypertarget{citeproc_bib_item_16}{[16] R. G. Loeliger, \textit{Threaded Interpretive Languages}. McGraw-Hill, Inc., 1981. \textsc{\url{https://archive.org/details/loeliger-threaded-interpretive-languages-1981}}}

\hypertarget{citeproc_bib_item_17}{[17] M. A. Ertl, “Threaded Code Variations and Optimizations (Extended Version),” in \textit{Forth-Tagung 2002}, Garmisch-Partenkirchen, 2002. \textsc{\url{http://www.complang.tuwien.ac.at/anton/euroforth/ef01/ertl01.pdf}}}

\hypertarget{citeproc_bib_item_18}{[18] P. M. Kogge, “An Architectural Trail to Threaded-Code Systems,” \textit{Ieeecomputer}, pp. 22–32, Mar. 1982.}

\hypertarget{citeproc_bib_item_19}{[19] \textit{Intel® 64 and IA-32 Architectures Software Developer’s Manual. Volume 2 (2A, 2B, 2C, \& 2D): Instruction Set Reference, A-Z}. Intel; Intel Corporation, 2024. \textsc{\url{https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html}}}

\hypertarget{citeproc_bib_item_20}{[20] M. Kerner and N. Padgett, “A History of Modern 64-bit Computing,” CS Department, University of Washington, 2007. \textsc{\url{https://courses.cs.washington.edu/courses/csep590/06au/projects/history-64-bit.pdf}}}

\hypertarget{citeproc_bib_item_21}{[21] \textit{Intel® 64 and IA-32 Architectures Software Developer Manuals}. Intel; Intel Corporation, 2024. \textsc{\url{https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html\#inpage-nav-2}}}

\hypertarget{citeproc_bib_item_22}{[22] A. S. Waterman, “Design of the RISC-V Instruction Set Architecture – PhD Thesis,” EECS Department, University of California, Berkeley, 2016. \textsc{\url{https://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-1.html}}}

\hypertarget{citeproc_bib_item_23}{[23] “RISC-V Ratified Extensions.” RISC-V International. \textsc{\url{https://wiki.riscv.org/display/HOME/Ratified+Extensions}}}

\hypertarget{citeproc_bib_item_24}{[24] D. Patterson and A. Waterman, \textit{The RISC-V Reader: An Open Architecture Atlas}, 1st ed. Strawberry Canyon, 2017. \textsc{\url{http://riscvbook.com}}}

\hypertarget{citeproc_bib_item_25}{[25] \textit{The RISC-V Instruction Set Manual: Volume I (Unprivileged Architecture). Version 20240411}. RISC-V International, 2024. \textsc{\url{https://riscv.org/technical/specifications/}}}

\hypertarget{citeproc_bib_item_26}{[26] \textit{The RISC-V Instruction Set Manual: Volume II (Privileged Architecture). Version 20240411}. RISC-V International, 2024. \textsc{\url{https://riscv.org/technical/specifications/}}}

\hypertarget{citeproc_bib_item_27}{[27] \textit{Linux man-pages 6.9.1 – syscalls(2)}. \textsc{\url{https://man7.org/linux/man-pages/man2/syscalls.2.html}}}

\hypertarget{citeproc_bib_item_28}{[28] \textit{Linux man-pages 6.9.1 – syscall(2) – NOTES}. \textsc{\url{https://man7.org/linux/man-pages/man2/syscall.2.html\#NOTES}}}

\hypertarget{citeproc_bib_item_29}{[29] “Linux System Call Table.” The Chromium Projects. \textsc{\url{https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/}}}

\hypertarget{citeproc_bib_item_30}{[30] “System V Application Binary Interface (`gABI’). DRAFT Version, June 10, 2013.” \textsc{\url{https://www.sco.com/developers/gabi/latest/contents.html}}}

\hypertarget{citeproc_bib_item_31}{[31] H. Lu, M. Matz, M. Girkar, J. Hubička, A. Jaeger, and M. Mitchell, \textit{System V Application Binary Interface. AMD64 Architecture Processor Supplement (`psABI’). Version 1.0, June 3, 2024}. \textsc{\url{https://gitlab.com/x86-psABIs/x86-64-ABI}}}

\hypertarget{citeproc_bib_item_32}{[32] K. Cheng and J. Clarke, Eds., \textit{RISC-V ABIs Specification, Document Version 1.0}. RISC-V International, 2022. \textsc{\url{https://github.com/riscv-non-isa/riscv-elf-psabi-doc}}}

\hypertarget{citeproc_bib_item_33}{[33] F. Bellard, “QEMU, a Fast and Portable Dynamic Translator,” in \textit{Proceedings of the FREENIX Track: 2005 USENIX Annual Technical Conference, April 10-15, 2005, Anaheim, CA, USA}, USENIX, 2005. \textsc{\url{http://www.usenix.org/events/usenix05/tech/freenix/bellard.html}}}

\hypertarget{citeproc_bib_item_34}{[34] F. Bellard and the QEMU community, “QEMU: A generic and open source machine emulator and virtualizer.” \textsc{\url{https://www.qemu.org}}}

\hypertarget{citeproc_bib_item_35}{[35] \textit{RISC-V Assembly Programmer’s Manual}. \textsc{\url{https://github.com/riscv-non-isa/riscv-asm-manual/blob/main/riscv-asm.md}}}

\hypertarget{citeproc_bib_item_36}{[36] “Fizz buzz.” \textsc{\url{https://en.wikipedia.org/wiki/Fizz_buzz}}}\bigskip
\clearpage
\appendix


\section{Appendix: A Short List of RISC-V Instructions}
\label{sec:org0770758}

We thought it interesting to include as an appendix the surprinsingly
short list of all RISC-V instructions used in the machine code part of
our Forth system.  It is displayed in Table
\ref{tab:org72bd592}.

\begin{table}[!htbp] \begin{adjustwidth}{-1cm}{-1cm} \fontsize{10}{12.000000}\selectfont
\begin{center}
\begin{tabular}{lll}
\textbf{Instruction} & \textbf{Type} & \textbf{Encoding}\\[0pt]
\hline
ecall & I & \texttt{000000000000}                      \texttt{00000}          \texttt{000} \texttt{00000}          \texttt{1110011}\\[0pt]
\hline
slli rd, rs1, shamt & I & \texttt{000000}​\emph{\texttt{bbbbbb}}​\(^{sh}\)         \texttt{rrrrr}​\(^{s_{1}}\) \texttt{001} \texttt{rrrrr}​\(^{d}\)  \texttt{0010011}\\[0pt]
srli rd, rs1, shamt & I & \texttt{000000}​\emph{\texttt{bbbbbb}}​\(^{sh}\)         \texttt{rrrrr}​\(^{s_{1}}\) \texttt{101} \texttt{rrrrr}​\(^{d}\)  \texttt{0010011}\\[0pt]
addi rd, rs1, immediate & I & \emph{\texttt{0xhhh}}                    \texttt{rrrrr}​\(^{s_{1}}\) \texttt{000} \texttt{rrrrr}​\(^{d}\)  \texttt{0010011}\\[0pt]
andi rd, rs1, immediate & I & \emph{\texttt{0xhhh}}                    \texttt{rrrrr}​\(^{s_{1}}\) \texttt{111} \texttt{rrrrr}​\(^{d}\)  \texttt{0010011}\\[0pt]
\hline
ld  rd, offset(rs1) & I & \uline{\texttt{0xhhh}}                    \texttt{rrrrr}​\(^{s_{1}}\) \texttt{011} \texttt{rrrrr}​\(^{d}\)  \texttt{0000011}\\[0pt]
lbu rd, offset(rs1) & I & \uline{\texttt{0xhhh}}                    \texttt{rrrrr}​\(^{s_{1}}\) \texttt{100} \texttt{rrrrr}​\(^{d}\)  \texttt{0000011}\\[0pt]
lwu rd, offset(rs1) & I & \uline{\texttt{0xhhh}}                    \texttt{rrrrr}​\(^{s_{1}}\) \texttt{110} \texttt{rrrrr}​\(^{d}\)  \texttt{0000011}\\[0pt]
\hline
jalr rd, offset(rs1) & I & \uline{\texttt{0xhhh}}                    \texttt{rrrrr}​\(^{s_{1}}\) \texttt{000} \texttt{rrrrr}​\(^{d}\)  \texttt{1100111}\\[0pt]
\hline
add rd, rs1, rs2 & R & \texttt{0000000} \texttt{rrrrr}​\(^{s_{2}}\) \texttt{rrrrr}​\(^{s_{1}}\) \texttt{000} \texttt{rrrrr}​\(^{d}\)  \texttt{0110011}\\[0pt]
or  rd, rs1, rs2 & R & \texttt{0000000} \texttt{rrrrr}​\(^{s_{2}}\) \texttt{rrrrr}​\(^{s_{1}}\) \texttt{110} \texttt{rrrrr}​\(^{d}\)  \texttt{0110011}\\[0pt]
and rd, rs1, rs2 & R & \texttt{0000000} \texttt{rrrrr}​\(^{s_{2}}\) \texttt{rrrrr}​\(^{s_{1}}\) \texttt{111} \texttt{rrrrr}​\(^{d}\)  \texttt{0110011}\\[0pt]
sub rd, rs1, rs2 & R & \texttt{0100000} \texttt{rrrrr}​\(^{s_{2}}\) \texttt{rrrrr}​\(^{s_{1}}\) \texttt{000} \texttt{rrrrr}​\(^{d}\)  \texttt{0110011}\\[0pt]
\hline
sb rs2, offset(rs1) & S & \uline{\texttt{bbbbbbb}} \texttt{rrrrr}​\(^{s_{2}}\) \texttt{rrrrr}​\(^{s_{1}}\) \texttt{000} \uline{\texttt{bbbbb}} \texttt{0100011}\\[0pt]
sw rs2, offset(rs1) & S & \uline{\texttt{bbbbbbb}} \texttt{rrrrr}​\(^{s_{2}}\) \texttt{rrrrr}​\(^{s_{1}}\) \texttt{010} \uline{\texttt{bbbbb}} \texttt{0100011}\\[0pt]
sd rs2, offset(rs1) & S & \uline{\texttt{bbbbbbb}} \texttt{rrrrr}​\(^{s_{2}}\) \texttt{rrrrr}​\(^{s_{1}}\) \texttt{011} \uline{\texttt{bbbbb}} \texttt{0100011}\\[0pt]
\hline
beq rs1, rs2, offset & B & \uline{\texttt{bbbbbbb}} \texttt{rrrrr}​\(^{s_{2}}\) \texttt{rrrrr}​\(^{s_{1}}\) \texttt{000} \uline{\texttt{bbbbb}} \texttt{1100011}\\[0pt]
bne rs1, rs2, offset & B & \uline{\texttt{bbbbbbb}} \texttt{rrrrr}​\(^{s_{2}}\) \texttt{rrrrr}​\(^{s_{1}}\) \texttt{001} \uline{\texttt{bbbbb}} \texttt{1100011}\\[0pt]
blt rs1, rs2, offset & B & \uline{\texttt{bbbbbbb}} \texttt{rrrrr}​\(^{s_{2}}\) \texttt{rrrrr}​\(^{s_{1}}\) \texttt{100} \uline{\texttt{bbbbb}} \texttt{1100011}\\[0pt]
bltu rs1, rs2, offset & B & \uline{\texttt{bbbbbbb}} \texttt{rrrrr}​\(^{s_{2}}\) \texttt{rrrrr}​\(^{s_{1}}\) \texttt{110} \uline{\texttt{bbbbb}} \texttt{1100011}\\[0pt]
bgeu rs1, rs2, offset & B & \uline{\texttt{bbbbbbb}} \texttt{rrrrr}​\(^{s_{2}}\) \texttt{rrrrr}​\(^{s_{1}}\) \texttt{111} \uline{\texttt{bbbbb}} \texttt{1100011}\\[0pt]
\hline
lui rd, immediate & U & \emph{\texttt{0xhhhhh}}                                                  \texttt{rrrrr}​\(^{d}\)  \texttt{0110111}\\[0pt]
\hline
jal rd, offset & J & \uline{\texttt{bbbbbbbbbbbbbbbbbbbb}}                                     \texttt{rrrrr}​\(^{d}\)  \texttt{1101111}\\[0pt]
\end{tabular}
\captionof{table}{\label{tab:org72bd592}All RISC-V instructions used in our machine code implementation.}

\end{center}
\normalsize \end{adjustwidth} \end{table} \vspace{0}
\end{document}
