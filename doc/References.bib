%%% Context %%%

@Article{ghuloum2006,
  title =	 {{An Incremental Approach to Compiler Construction}},
  author =	 {Ghuloum, Abdulaziz},
  year =	 2006,
  journal =	 {Proceedings of the 2006 Scheme and Functional
                  Programming Workshop},
  url =		 {http://scheme2006.cs.uchicago.edu/11-ghuloum.pdf}
}

@Misc{rust_compiler_overview,
  title =	 {{Rust: Overview of the compiler}},
  year =	 2024,
  url =
                  {https://rustc-dev-guide.rust-lang.org/overview.html#overview-of-the-compiler}
}

@Misc{lua_puc_rio,
  title =	 {{About Lua}},
  author =	 {{PUC-Rio}},
  url =		 {https://www.lua.org/about.html}
}

@Misc{lua_luajit,
  title =	 {{LuaJIT: a Just-In-Time Compiler (JIT) for the Lua
                  programming language}},
  author =	 {{Mike Pall}},
  url =		 {http://luajit.org/luajit.html}
}

%%% Forth %%%

@InBook{rather1996_evolution,
  author =	 {Rather, Elizabeth D. and Colburn, Donald R. and
                  Moore, Charles H.},
  title =	 {The evolution of Forth},
  year =	 1996,
  isbn =	 0201895021,
  publisher =	 {Association for Computing Machinery},
  address =	 {New York, NY, USA},
  url =		 {https://doi.org/10.1145/234286.1057832},
  abstract =	 {Forth is unique among programming languages in that
                  its development and proliferation has been a
                  grass-roots effort unsupported by any major
                  corporate or academic sponsors. Originally conceived
                  and developed by a single individual, its later
                  development has progressed under two significant
                  influences: professional programmers who developed
                  tools to solve application problems and then
                  commercialized them, and the interests of hobbyists
                  concerned with free distribution of Forth. These
                  influences have produced a language markedly
                  different from traditional programming languages.},
  booktitle =	 {History of Programming Languages---II},
  pages =	 {625–670},
  numpages =	 46
}

@Misc{forth_2012_standard,
  title =	 {{Forth 2012 Standard}},
  author =	 {{Forth 200x Standards Committee}},
  url =		 {https://forth-standard.org}
}

@Book{brodie2004thinking,
  title =	 {{Thinking FORTH}},
  author =	 {Brodie, Leo},
  year =	 2004,
  publisher =	 {Punchy Publishing},
  url =
                  {https://www.forth.com/wp-content/uploads/2018/11/thinking-forth-color.pdf}
}

@Book{brodie1981starting,
  title =	 {{Starting FORTH}},
  author =	 {Brodie, Leo},
  year =	 1981,
  publisher =	 {Prentice-Hall},
  url =		 {https://www.forth.com/starting-forth/},
}

@Book{loeliger1981threaded,
  title =	 {{Threaded Interpretive Languages}},
  author =	 {Loeliger, Ronald G.},
  year =	 1981,
  publisher =	 {McGraw-Hill, Inc.},
  isbn =	 {007038360X},
  url =
                  {https://archive.org/details/loeliger-threaded-interpretive-languages-1981}
}

@Misc{smithforth,
  title =	 {{SmithForth: A Forth for x86-64 personal computers}},
  author =	 {David Smith},
  year =	 2022,
  url =		 {https://dacvs.neocities.org/SF/}
}

@Misc{sectorforth,
  title =	 {{sectorforth. A 16-bit x86 Forth that fits in a
                  512-byte boot sector.}},
  author =	 {Blum, Cesar},
  year =	 2020,
  url =		 {https://github.com/cesarblum/sectorforth/},
}

@Misc{milliforth,
  title =	 {{milliForth. A FORTH in 340 bytes — the smallest
                  real programming language ever as of yet.}},
  author =	 {@fuzzballcat},
  year =	 2023,
  url =		 {https://github.com/fuzzballcat/milliForth}
}

@Article{kogge82,
  author =	 "Peter M. Kogge",
  title =	 {{An Architectural Trail to Threaded-Code Systems}},
  journal =	 ieeecomputer,
  year =	 1982,
  pages =	 "22--32",
  month =	 mar,
  annote =	 "Explains the design of (a classical implementation
                  of) Forth, starting with threaded code, then adding
                  the parameter stack, constants, variables, control
                  structures, dictionary, outer interpreter and
                  compiler."
}

@InProceedings{ertl02,
  author =	 {M. Anton Ertl},
  title =	 {{Threaded Code Variations and Optimizations
                  (Extended Version)}},
  booktitle =	 {{Forth-Tagung 2002}},
  year =	 2002,
  address =	 {Garmisch-Partenkirchen},
  url =
                  {https://www.complang.tuwien.ac.at/papers/ertl02.ps.gz},
  abstract =	 {Forth has been traditionally implemented as indirect
                  threaded code, where the code for non-primitives is
                  the code-field address of the word. To get the
                  maximum benefit from combining sequences of
                  primitives into superinstructions, the code produced
                  for a non-primitive should be a primitive followed
                  by a parameter (e.g., \code{lit} \emph{addr} for
                  variables). This paper takes a look at the steps
                  from a traditional threaded-code implementation to
                  superinstructions, and at the size and speed effects
                  of the various steps.\comment{It also compares these
                  variants of Gforth to various other Forth
                  implementations on contemporary machines.} The use
                  of superinstructions gives speedups of up to a
                  factor of 2 on large benchmarks on processors with
                  branch target buffers, but requires more space for
                  the primitives and the optimization tables, and also
                  a little more space for the threaded code.}
}

%%% System V %%%

@Misc{system_v_gabi,
  title =	 {{System V Application Binary Interface
                  (`gABI'). DRAFT Version, June 10, 2013}},
  url =
                  {https://www.sco.com/developers/gabi/latest/contents.html},
  annote =	 {1997 SCO version at:
                  https://www.sco.com/developers/devspecs/gabi41.pdf},
}

@Manual{system_v_psabi_amd64,
  title =	 {{System V Application Binary Interface. AMD64
                  Architecture Processor Supplement (`psABI'). Version
                  1.0, June 3, 2024}},
  author =	 { Lu, H.J. and Matz, Michael and Girkar, Milind and
                  Hubička, Jan and Jaeger, Andreas and Mitchell, Mark},
  url =		 {https://gitlab.com/x86-psABIs/x86-64-ABI},
  annote =	 {PDF version at:
                  https://gitlab.com/x86-psABIs/x86-64-ABI/-/jobs/artifacts/master/raw/x86-64-ABI/abi.pdf?job=build}
}

@Manual{system_v_psabi_riscv,
  title =	 {{RISC-V ABIs Specification, Document Version 1.0}},
  editor =	 {Kito Cheng and Jessica Clarke},
  institution =	 {RISC-V International},
  month =	 {November},
  year =	 2022,
  url =
                  {https://github.com/riscv-non-isa/riscv-elf-psabi-doc},
}

@Article{elf_sti_1995,
  title =	 {{Executable and Linking Format (ELF) Specification
                  Version 1.2}},
  author =	 {Standard, Tool Interface},
  journal =	 {TIS Committee},
  pages =	 {1--106},
  year =	 1995
}

%%% Linux %%%

@Misc{linux_system_calls_table,
  title =	 {{Linux System Call Table}},
  institution =	 {The Chromium Projects},
  url =
                  {https://www.chromium.org/chromium-os/developer-library/reference/linux-constants/syscalls/},
}

@Manual{linux_man_syscall,
  title =	 {{Linux man-pages 6.9.1 -- syscall(2) -- NOTES}},
  url =
                  {https://man7.org/linux/man-pages/man2/syscall.2.html#NOTES},
}

%%% ELF files %%%

@Misc{smith_handmade_executables,
  title =	 {{Handmade Linux x86 executables}},
  author =	 {David Smith},
  year =	 2021,
  url =
                  {https://www.youtube.com/playlist?list=PLZCIHSjpQ12woLj0sjsnqDH8yVuXwTy3p}
}

@Misc{raiter_teensy_elf_executables,
  title =	 {A Whirlwind Tutorial on Creating Really Teensy ELF
                  Executables for Linux},
  author =	 {Brian Raiter},
  year =	 1999,
  url =
                  {http://www.muppetlabs.com/~breadbox/software/tiny/teensy.html},
}

%%% x86-64 %%%

@Manual{intel_manual_volume_2,
  title =	 {{Intel® 64 and IA-32 Architectures Software
                  Developer’s Manual. Volume 2 (2A, 2B, 2C, & 2D):
                  Instruction Set Reference, A-Z}},
  institution =	 {Intel},
  publisher =	 {Intel Corporation},
  year =	 2024,
  url =
                  {https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html}
}

@TechReport{kerner2007history,
  title =	 {{A History of Modern 64-bit Computing}},
  author =	 {Kerner, Matthew and Padgett, Neil},
  institution =	 {CS Department, University of Washington},
  url =
                  {https://courses.cs.washington.edu/courses/csep590/06au/projects/history-64-bit.pdf},
  month =	 {February},
  year =	 2007
}

%%% RISC-V %%%

@Book{patterson2017,
  title =	 {{The RISC-V Reader: An Open Architecture Atlas}},
  author =	 {Patterson, David and Waterman, Andrew},
  year =	 2017,
  isbn =	 0999249118,
  publisher =	 {Strawberry Canyon},
  edition =	 {1st},
  abstract =	 {The RISC-V Reader is a concise introduction and
                  reference for embedded systems programmers,
                  students, and the curious to a modern, popular, open
                  architecture. RISC-V spans from the cheapest 32-bit
                  embedded microcontroller to the fastest 64-bit cloud
                  computer. The text shows how RISC-V followed the
                  good ideas of past architectures while avoiding
                  their mistake.},
  url =		 {http://riscvbook.com}
}

@TechReport{waterman2016,
  title =	 {{Design of the RISC-V Instruction Set Architecture
                  -- PhD Thesis}},
  author =	 {Waterman, Andrew Shell},
  year =	 2016,
  institution =	 {EECS Department, University of California, Berkeley},
  url =
                  {https://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-1.html}
}

@Book{riscv_spec_vol_i,
  title =	 {{The RISC-V Instruction Set Manual: Volume I
                  (Unprivileged Architecture). Version 20240411}},
  editors =	 {Waterman, Andrew and Asanović, Krste},
  institution =	 {{RISC-V International}},
  year =	 2024,
  url =		 {https://riscv.org/technical/specifications/},
}

@Book{riscv_spec_vol_ii,
  title =	 {{The RISC-V Instruction Set Manual: Volume II
                  (Privileged Architecture). Version 20240411}},
  editors =	 {Waterman, Andrew and Asanović, Krste},
  institution =	 {{RISC-V International}},
  year =	 2024,
  url =		 {https://riscv.org/technical/specifications/},
}

@Manual{riscv_assembly_manual,
  title =	 {{RISC-V Assembly Programmer's Manual}},
  url =
                  {https://github.com/riscv-non-isa/riscv-asm-manual/blob/main/riscv-asm.md}
}

@Misc{riscv_ratified_extensions,
  title =	 {{RISC-V Ratified Extensions}},
  institution =	 {{RISC-V International}},
  url =
                  {https://wiki.riscv.org/display/HOME/Ratified+Extensions},
}

%%% QEMU %%%

@InProceedings{bellard2005qemu,
  author =	 {Fabrice Bellard},
  title =	 {{QEMU, a Fast and Portable Dynamic Translator}},
  booktitle =	 {{Proceedings of the FREENIX Track: 2005 USENIX
                  Annual Technical Conference, April 10-15, 2005,
                  Anaheim, CA, USA}},
  publisher =	 {{USENIX}},
  year =	 2005,
  url =
                  {http://www.usenix.org/events/usenix05/tech/freenix/bellard.html},
}

%%% LISP %%%

@Article{mccarthy1960lisp,
  title =	 {Recursive functions of symbolic expressions and
                  their computation by machine, part I},
  author =	 {McCarthy, John},
  journal =	 {Communications of the ACM},
  volume =	 3,
  number =	 4,
  pages =	 {184--195},
  year =	 1960,
  publisher =	 {ACM New York, NY, USA}
}

@book{abelson1996_sicp,
  author =	 {Abelson, Harold and Sussman, Gerald J.},
  title =	 {Structure and Interpretation of Computer Programs},
  year =	 1996,
  isbn =	 0262011530,
  publisher =	 {MIT Press},
  address =	 {Cambridge, MA, USA},
  edition =	 {2nd},
  abstract =	 {From the Publisher:With an analytical and rigorous
                  approach to problem solving and programming
                  techniques,this book is oriented toward
                  engineering. Structure and Interpretation of
                  Computer Programs emphasizes the central role played
                  by different approaches to dealing with time in
                  computational models. Its unique approach makes it
                  appropriate for an introduction to computer science
                  courses,as well as programming languages and program
                  design.}
}

%%% Other %%%

@Book{pratt75,
  author =	 {Pratt, Terrence W.},
  title =	 {Programming Languages: Design and Implementation},
  year =	 1975,
  isbn =	 0137304323,
  publisher =	 {Prentice Hall PTR},
  address =	 {USA},
  abstract =	 {From the Publisher: Exceptionally comprehensive in
                  approach, this book explores the major issues in
                  both design and implementation of modern programming
                  languages and provides a basic introduction to the
                  underlying theoretical models on which these
                  languages are based. The emphasis throughout is on
                  fundamental concepts—readers learn important ideas,
                  not minor language differences—but several languages
                  are highlighted in sufficient detail to enable
                  readers to write programs that demonstrate the
                  relationship between a source program and its
                  execution behavior—e.g., C, C++, JAVA, ML, LISP,
                  Prolog, Smalltalk, Postscript, HTML, PERL, FORTRAN,
                  Ada, COBOL, BASIC SNOBOL4, PL/I, Pascal. Begins with
                  a background review of programming languages and the
                  underlying hardware that will execute the given
                  program; then covers the underlying grammatical
                  model for programming languages and their compilers
                  (elementary data types, data structures and
                  encapsulation, inheritance, statements, procedure
                  invocation, storage management, distributed
                  processing, and network programming). Includes an
                  advanced chapter on language semantics—program
                  verification, denotational semantics, and the lambda
                  calculus. For computer engineers and others
                  interested in programming language designs.}
}

@Misc{jargon_file,
  title =	 {The Jargon File, Version 4.4.7, 29 December 2003},
  author =	 {Raymond, Eric S and Steele, Guy L},
  url =		 {http://jargon-file.org/archive/jargon-4.4.7.dos.txt},
  year =	 2003,
}
